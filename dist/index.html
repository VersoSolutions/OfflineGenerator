<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Verso Cards - Offline Generator</title>
    <style>
      body {
      	font-family: Helvetica, Arial, sans-serif;
      }
      
      #addCard {
      	margin-bottom: 1em;
      }
      
      #cardData {
      	padding: 5px;
      	width: 470px;
      	border: 1px solid black;
      	background-color: #ccc;
      	margin-bottom: 1em;
      }
      
      #cardData label {
      	display: inline-block;
      	width: 50%;
      	text-align: right;
      }
      
      #cardData .buttons {
      	padding-left: calc(50% + 5px);
      }
      
      #cardData .error {
      	display: none;
      	color: red;
      }
      
      #cards {
      	width: 482px;
      	border: 1px solid black;
      	background-color: #ccc;
      	table-layout: fixed;
      }
      
      #cards thead {
      	font-weight: bold;
      	text-align: left;
      }
      
      #cards th:nth-child(1),
      #cards td:nth-child(1) {
      	width: 20%;
      }
      
      #cards th:nth-child(2),
      #cards td:nth-child(2) {
      	width: 40%;
      }
      
      #cards th:nth-child(3),
      #cards td:nth-child(3) {
      	width: 20%;
      }
      
      #cards th,
      #cards td {
      	overflow: hidden;
      	text-overflow: ellipsis;
      }
      
      #cards .none {
      	font-style: italic;
      	text-align: center;
      }
      
      #orderData {
      	width: 480px;
      	height: 320px;
      }
    </style>
  </head>
  <body>

    <script type="text/javascript">
      /*
      CryptoJS v3.1.2
      code.google.com/p/crypto-js
      (c) 2009-2013 by Jeff Mott. All rights reserved.
      code.google.com/p/crypto-js/wiki/License
      */
      /**
       * CryptoJS core components.
       */
      var CryptoJS = CryptoJS || (function (Math, undefined) {
          /**
           * CryptoJS namespace.
           */
          var C = {};
      
          /**
           * Library namespace.
           */
          var C_lib = C.lib = {};
      
          /**
           * Base object for prototypal inheritance.
           */
          var Base = C_lib.Base = (function () {
              function F() {}
      
              return {
                  /**
                   * Creates a new object that inherits from this object.
                   *
                   * @param {Object} overrides Properties to copy into the new object.
                   *
                   * @return {Object} The new object.
                   *
                   * @static
                   *
                   * @example
                   *
                   *     var MyType = CryptoJS.lib.Base.extend({
                   *         field: 'value',
                   *
                   *         method: function () {
                   *         }
                   *     });
                   */
                  extend: function (overrides) {
                      // Spawn
                      F.prototype = this;
                      var subtype = new F();
      
                      // Augment
                      if (overrides) {
                          subtype.mixIn(overrides);
                      }
      
                      // Create default initializer
                      if (!subtype.hasOwnProperty('init')) {
                          subtype.init = function () {
                              subtype.$super.init.apply(this, arguments);
                          };
                      }
      
                      // Initializer's prototype is the subtype object
                      subtype.init.prototype = subtype;
      
                      // Reference supertype
                      subtype.$super = this;
      
                      return subtype;
                  },
      
                  /**
                   * Extends this object and runs the init method.
                   * Arguments to create() will be passed to init().
                   *
                   * @return {Object} The new object.
                   *
                   * @static
                   *
                   * @example
                   *
                   *     var instance = MyType.create();
                   */
                  create: function () {
                      var instance = this.extend();
                      instance.init.apply(instance, arguments);
      
                      return instance;
                  },
      
                  /**
                   * Initializes a newly created object.
                   * Override this method to add some logic when your objects are created.
                   *
                   * @example
                   *
                   *     var MyType = CryptoJS.lib.Base.extend({
                   *         init: function () {
                   *             // ...
                   *         }
                   *     });
                   */
                  init: function () {
                  },
      
                  /**
                   * Copies properties into this object.
                   *
                   * @param {Object} properties The properties to mix in.
                   *
                   * @example
                   *
                   *     MyType.mixIn({
                   *         field: 'value'
                   *     });
                   */
                  mixIn: function (properties) {
                      for (var propertyName in properties) {
                          if (properties.hasOwnProperty(propertyName)) {
                              this[propertyName] = properties[propertyName];
                          }
                      }
      
                      // IE won't copy toString using the loop above
                      if (properties.hasOwnProperty('toString')) {
                          this.toString = properties.toString;
                      }
                  },
      
                  /**
                   * Creates a copy of this object.
                   *
                   * @return {Object} The clone.
                   *
                   * @example
                   *
                   *     var clone = instance.clone();
                   */
                  clone: function () {
                      return this.init.prototype.extend(this);
                  }
              };
          }());
      
          /**
           * An array of 32-bit words.
           *
           * @property {Array} words The array of 32-bit words.
           * @property {number} sigBytes The number of significant bytes in this word array.
           */
          var WordArray = C_lib.WordArray = Base.extend({
              /**
               * Initializes a newly created word array.
               *
               * @param {Array} words (Optional) An array of 32-bit words.
               * @param {number} sigBytes (Optional) The number of significant bytes in the words.
               *
               * @example
               *
               *     var wordArray = CryptoJS.lib.WordArray.create();
               *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
               *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
               */
              init: function (words, sigBytes) {
                  words = this.words = words || [];
      
                  if (sigBytes != undefined) {
                      this.sigBytes = sigBytes;
                  } else {
                      this.sigBytes = words.length * 4;
                  }
              },
      
              /**
               * Converts this word array to a string.
               *
               * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
               *
               * @return {string} The stringified word array.
               *
               * @example
               *
               *     var string = wordArray + '';
               *     var string = wordArray.toString();
               *     var string = wordArray.toString(CryptoJS.enc.Utf8);
               */
              toString: function (encoder) {
                  return (encoder || Hex).stringify(this);
              },
      
              /**
               * Concatenates a word array to this word array.
               *
               * @param {WordArray} wordArray The word array to append.
               *
               * @return {WordArray} This word array.
               *
               * @example
               *
               *     wordArray1.concat(wordArray2);
               */
              concat: function (wordArray) {
                  // Shortcuts
                  var thisWords = this.words;
                  var thatWords = wordArray.words;
                  var thisSigBytes = this.sigBytes;
                  var thatSigBytes = wordArray.sigBytes;
      
                  // Clamp excess bits
                  this.clamp();
      
                  // Concat
                  if (thisSigBytes % 4) {
                      // Copy one byte at a time
                      for (var i = 0; i < thatSigBytes; i++) {
                          var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                          thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                      }
                  } else if (thatWords.length > 0xffff) {
                      // Copy one word at a time
                      for (var i = 0; i < thatSigBytes; i += 4) {
                          thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                      }
                  } else {
                      // Copy all words at once
                      thisWords.push.apply(thisWords, thatWords);
                  }
                  this.sigBytes += thatSigBytes;
      
                  // Chainable
                  return this;
              },
      
              /**
               * Removes insignificant bits.
               *
               * @example
               *
               *     wordArray.clamp();
               */
              clamp: function () {
                  // Shortcuts
                  var words = this.words;
                  var sigBytes = this.sigBytes;
      
                  // Clamp
                  words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
                  words.length = Math.ceil(sigBytes / 4);
              },
      
              /**
               * Creates a copy of this word array.
               *
               * @return {WordArray} The clone.
               *
               * @example
               *
               *     var clone = wordArray.clone();
               */
              clone: function () {
                  var clone = Base.clone.call(this);
                  clone.words = this.words.slice(0);
      
                  return clone;
              },
      
              /**
               * Creates a word array filled with random bytes.
               *
               * @param {number} nBytes The number of random bytes to generate.
               *
               * @return {WordArray} The random word array.
               *
               * @static
               *
               * @example
               *
               *     var wordArray = CryptoJS.lib.WordArray.random(16);
               */
              random: function (nBytes) {
                  var words = [];
                  for (var i = 0; i < nBytes; i += 4) {
                      words.push((Math.random() * 0x100000000) | 0);
                  }
      
                  return new WordArray.init(words, nBytes);
              }
          });
      
          /**
           * Encoder namespace.
           */
          var C_enc = C.enc = {};
      
          /**
           * Hex encoding strategy.
           */
          var Hex = C_enc.Hex = {
              /**
               * Converts a word array to a hex string.
               *
               * @param {WordArray} wordArray The word array.
               *
               * @return {string} The hex string.
               *
               * @static
               *
               * @example
               *
               *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
               */
              stringify: function (wordArray) {
                  // Shortcuts
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
      
                  // Convert
                  var hexChars = [];
                  for (var i = 0; i < sigBytes; i++) {
                      var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                      hexChars.push((bite >>> 4).toString(16));
                      hexChars.push((bite & 0x0f).toString(16));
                  }
      
                  return hexChars.join('');
              },
      
              /**
               * Converts a hex string to a word array.
               *
               * @param {string} hexStr The hex string.
               *
               * @return {WordArray} The word array.
               *
               * @static
               *
               * @example
               *
               *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
               */
              parse: function (hexStr) {
                  // Shortcut
                  var hexStrLength = hexStr.length;
      
                  // Convert
                  var words = [];
                  for (var i = 0; i < hexStrLength; i += 2) {
                      words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
                  }
      
                  return new WordArray.init(words, hexStrLength / 2);
              }
          };
      
          /**
           * Latin1 encoding strategy.
           */
          var Latin1 = C_enc.Latin1 = {
              /**
               * Converts a word array to a Latin1 string.
               *
               * @param {WordArray} wordArray The word array.
               *
               * @return {string} The Latin1 string.
               *
               * @static
               *
               * @example
               *
               *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
               */
              stringify: function (wordArray) {
                  // Shortcuts
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
      
                  // Convert
                  var latin1Chars = [];
                  for (var i = 0; i < sigBytes; i++) {
                      var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                      latin1Chars.push(String.fromCharCode(bite));
                  }
      
                  return latin1Chars.join('');
              },
      
              /**
               * Converts a Latin1 string to a word array.
               *
               * @param {string} latin1Str The Latin1 string.
               *
               * @return {WordArray} The word array.
               *
               * @static
               *
               * @example
               *
               *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
               */
              parse: function (latin1Str) {
                  // Shortcut
                  var latin1StrLength = latin1Str.length;
      
                  // Convert
                  var words = [];
                  for (var i = 0; i < latin1StrLength; i++) {
                      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
                  }
      
                  return new WordArray.init(words, latin1StrLength);
              }
          };
      
          /**
           * UTF-8 encoding strategy.
           */
          var Utf8 = C_enc.Utf8 = {
              /**
               * Converts a word array to a UTF-8 string.
               *
               * @param {WordArray} wordArray The word array.
               *
               * @return {string} The UTF-8 string.
               *
               * @static
               *
               * @example
               *
               *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
               */
              stringify: function (wordArray) {
                  try {
                      return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                  } catch (e) {
                      throw new Error('Malformed UTF-8 data');
                  }
              },
      
              /**
               * Converts a UTF-8 string to a word array.
               *
               * @param {string} utf8Str The UTF-8 string.
               *
               * @return {WordArray} The word array.
               *
               * @static
               *
               * @example
               *
               *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
               */
              parse: function (utf8Str) {
                  return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
              }
          };
      
          /**
           * Abstract buffered block algorithm template.
           *
           * The property blockSize must be implemented in a concrete subtype.
           *
           * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
           */
          var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
              /**
               * Resets this block algorithm's data buffer to its initial state.
               *
               * @example
               *
               *     bufferedBlockAlgorithm.reset();
               */
              reset: function () {
                  // Initial values
                  this._data = new WordArray.init();
                  this._nDataBytes = 0;
              },
      
              /**
               * Adds new data to this block algorithm's buffer.
               *
               * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
               *
               * @example
               *
               *     bufferedBlockAlgorithm._append('data');
               *     bufferedBlockAlgorithm._append(wordArray);
               */
              _append: function (data) {
                  // Convert string to WordArray, else assume WordArray already
                  if (typeof data == 'string') {
                      data = Utf8.parse(data);
                  }
      
                  // Append
                  this._data.concat(data);
                  this._nDataBytes += data.sigBytes;
              },
      
              /**
               * Processes available data blocks.
               *
               * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
               *
               * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
               *
               * @return {WordArray} The processed data.
               *
               * @example
               *
               *     var processedData = bufferedBlockAlgorithm._process();
               *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
               */
              _process: function (doFlush) {
                  // Shortcuts
                  var data = this._data;
                  var dataWords = data.words;
                  var dataSigBytes = data.sigBytes;
                  var blockSize = this.blockSize;
                  var blockSizeBytes = blockSize * 4;
      
                  // Count blocks ready
                  var nBlocksReady = dataSigBytes / blockSizeBytes;
                  if (doFlush) {
                      // Round up to include partial blocks
                      nBlocksReady = Math.ceil(nBlocksReady);
                  } else {
                      // Round down to include only full blocks,
                      // less the number of blocks that must remain in the buffer
                      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
                  }
      
                  // Count words ready
                  var nWordsReady = nBlocksReady * blockSize;
      
                  // Count bytes ready
                  var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
      
                  // Process blocks
                  if (nWordsReady) {
                      for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                          // Perform concrete-algorithm logic
                          this._doProcessBlock(dataWords, offset);
                      }
      
                      // Remove processed words
                      var processedWords = dataWords.splice(0, nWordsReady);
                      data.sigBytes -= nBytesReady;
                  }
      
                  // Return processed words
                  return new WordArray.init(processedWords, nBytesReady);
              },
      
              /**
               * Creates a copy of this object.
               *
               * @return {Object} The clone.
               *
               * @example
               *
               *     var clone = bufferedBlockAlgorithm.clone();
               */
              clone: function () {
                  var clone = Base.clone.call(this);
                  clone._data = this._data.clone();
      
                  return clone;
              },
      
              _minBufferSize: 0
          });
      
          /**
           * Abstract hasher template.
           *
           * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
           */
          var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
              /**
               * Configuration options.
               */
              cfg: Base.extend(),
      
              /**
               * Initializes a newly created hasher.
               *
               * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
               *
               * @example
               *
               *     var hasher = CryptoJS.algo.SHA256.create();
               */
              init: function (cfg) {
                  // Apply config defaults
                  this.cfg = this.cfg.extend(cfg);
      
                  // Set initial values
                  this.reset();
              },
      
              /**
               * Resets this hasher to its initial state.
               *
               * @example
               *
               *     hasher.reset();
               */
              reset: function () {
                  // Reset data buffer
                  BufferedBlockAlgorithm.reset.call(this);
      
                  // Perform concrete-hasher logic
                  this._doReset();
              },
      
              /**
               * Updates this hasher with a message.
               *
               * @param {WordArray|string} messageUpdate The message to append.
               *
               * @return {Hasher} This hasher.
               *
               * @example
               *
               *     hasher.update('message');
               *     hasher.update(wordArray);
               */
              update: function (messageUpdate) {
                  // Append
                  this._append(messageUpdate);
      
                  // Update the hash
                  this._process();
      
                  // Chainable
                  return this;
              },
      
              /**
               * Finalizes the hash computation.
               * Note that the finalize operation is effectively a destructive, read-once operation.
               *
               * @param {WordArray|string} messageUpdate (Optional) A final message update.
               *
               * @return {WordArray} The hash.
               *
               * @example
               *
               *     var hash = hasher.finalize();
               *     var hash = hasher.finalize('message');
               *     var hash = hasher.finalize(wordArray);
               */
              finalize: function (messageUpdate) {
                  // Final message update
                  if (messageUpdate) {
                      this._append(messageUpdate);
                  }
      
                  // Perform concrete-hasher logic
                  var hash = this._doFinalize();
      
                  return hash;
              },
      
              blockSize: 512/32,
      
              /**
               * Creates a shortcut function to a hasher's object interface.
               *
               * @param {Hasher} hasher The hasher to create a helper for.
               *
               * @return {Function} The shortcut function.
               *
               * @static
               *
               * @example
               *
               *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
               */
              _createHelper: function (hasher) {
                  return function (message, cfg) {
                      return new hasher.init(cfg).finalize(message);
                  };
              },
      
              /**
               * Creates a shortcut function to the HMAC's object interface.
               *
               * @param {Hasher} hasher The hasher to use in this HMAC helper.
               *
               * @return {Function} The shortcut function.
               *
               * @static
               *
               * @example
               *
               *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
               */
              _createHmacHelper: function (hasher) {
                  return function (message, key) {
                      return new C_algo.HMAC.init(hasher, key).finalize(message);
                  };
              }
          });
      
          /**
           * Algorithm namespace.
           */
          var C_algo = C.algo = {};
      
          return C;
      }(Math));
      
      /*
      CryptoJS v3.1.2
      code.google.com/p/crypto-js
      (c) 2009-2013 by Jeff Mott. All rights reserved.
      code.google.com/p/crypto-js/wiki/License
      */
      (function (undefined) {
          // Shortcuts
          var C = CryptoJS;
          var C_lib = C.lib;
          var Base = C_lib.Base;
          var X32WordArray = C_lib.WordArray;
      
          /**
           * x64 namespace.
           */
          var C_x64 = C.x64 = {};
      
          /**
           * A 64-bit word.
           */
          var X64Word = C_x64.Word = Base.extend({
              /**
               * Initializes a newly created 64-bit word.
               *
               * @param {number} high The high 32 bits.
               * @param {number} low The low 32 bits.
               *
               * @example
               *
               *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
               */
              init: function (high, low) {
                  this.high = high;
                  this.low = low;
              }
      
              /**
               * Bitwise NOTs this word.
               *
               * @return {X64Word} A new x64-Word object after negating.
               *
               * @example
               *
               *     var negated = x64Word.not();
               */
              // not: function () {
                  // var high = ~this.high;
                  // var low = ~this.low;
      
                  // return X64Word.create(high, low);
              // },
      
              /**
               * Bitwise ANDs this word with the passed word.
               *
               * @param {X64Word} word The x64-Word to AND with this word.
               *
               * @return {X64Word} A new x64-Word object after ANDing.
               *
               * @example
               *
               *     var anded = x64Word.and(anotherX64Word);
               */
              // and: function (word) {
                  // var high = this.high & word.high;
                  // var low = this.low & word.low;
      
                  // return X64Word.create(high, low);
              // },
      
              /**
               * Bitwise ORs this word with the passed word.
               *
               * @param {X64Word} word The x64-Word to OR with this word.
               *
               * @return {X64Word} A new x64-Word object after ORing.
               *
               * @example
               *
               *     var ored = x64Word.or(anotherX64Word);
               */
              // or: function (word) {
                  // var high = this.high | word.high;
                  // var low = this.low | word.low;
      
                  // return X64Word.create(high, low);
              // },
      
              /**
               * Bitwise XORs this word with the passed word.
               *
               * @param {X64Word} word The x64-Word to XOR with this word.
               *
               * @return {X64Word} A new x64-Word object after XORing.
               *
               * @example
               *
               *     var xored = x64Word.xor(anotherX64Word);
               */
              // xor: function (word) {
                  // var high = this.high ^ word.high;
                  // var low = this.low ^ word.low;
      
                  // return X64Word.create(high, low);
              // },
      
              /**
               * Shifts this word n bits to the left.
               *
               * @param {number} n The number of bits to shift.
               *
               * @return {X64Word} A new x64-Word object after shifting.
               *
               * @example
               *
               *     var shifted = x64Word.shiftL(25);
               */
              // shiftL: function (n) {
                  // if (n < 32) {
                      // var high = (this.high << n) | (this.low >>> (32 - n));
                      // var low = this.low << n;
                  // } else {
                      // var high = this.low << (n - 32);
                      // var low = 0;
                  // }
      
                  // return X64Word.create(high, low);
              // },
      
              /**
               * Shifts this word n bits to the right.
               *
               * @param {number} n The number of bits to shift.
               *
               * @return {X64Word} A new x64-Word object after shifting.
               *
               * @example
               *
               *     var shifted = x64Word.shiftR(7);
               */
              // shiftR: function (n) {
                  // if (n < 32) {
                      // var low = (this.low >>> n) | (this.high << (32 - n));
                      // var high = this.high >>> n;
                  // } else {
                      // var low = this.high >>> (n - 32);
                      // var high = 0;
                  // }
      
                  // return X64Word.create(high, low);
              // },
      
              /**
               * Rotates this word n bits to the left.
               *
               * @param {number} n The number of bits to rotate.
               *
               * @return {X64Word} A new x64-Word object after rotating.
               *
               * @example
               *
               *     var rotated = x64Word.rotL(25);
               */
              // rotL: function (n) {
                  // return this.shiftL(n).or(this.shiftR(64 - n));
              // },
      
              /**
               * Rotates this word n bits to the right.
               *
               * @param {number} n The number of bits to rotate.
               *
               * @return {X64Word} A new x64-Word object after rotating.
               *
               * @example
               *
               *     var rotated = x64Word.rotR(7);
               */
              // rotR: function (n) {
                  // return this.shiftR(n).or(this.shiftL(64 - n));
              // },
      
              /**
               * Adds this word with the passed word.
               *
               * @param {X64Word} word The x64-Word to add with this word.
               *
               * @return {X64Word} A new x64-Word object after adding.
               *
               * @example
               *
               *     var added = x64Word.add(anotherX64Word);
               */
              // add: function (word) {
                  // var low = (this.low + word.low) | 0;
                  // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
                  // var high = (this.high + word.high + carry) | 0;
      
                  // return X64Word.create(high, low);
              // }
          });
      
          /**
           * An array of 64-bit words.
           *
           * @property {Array} words The array of CryptoJS.x64.Word objects.
           * @property {number} sigBytes The number of significant bytes in this word array.
           */
          var X64WordArray = C_x64.WordArray = Base.extend({
              /**
               * Initializes a newly created word array.
               *
               * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
               * @param {number} sigBytes (Optional) The number of significant bytes in the words.
               *
               * @example
               *
               *     var wordArray = CryptoJS.x64.WordArray.create();
               *
               *     var wordArray = CryptoJS.x64.WordArray.create([
               *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
               *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
               *     ]);
               *
               *     var wordArray = CryptoJS.x64.WordArray.create([
               *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
               *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
               *     ], 10);
               */
              init: function (words, sigBytes) {
                  words = this.words = words || [];
      
                  if (sigBytes != undefined) {
                      this.sigBytes = sigBytes;
                  } else {
                      this.sigBytes = words.length * 8;
                  }
              },
      
              /**
               * Converts this 64-bit word array to a 32-bit word array.
               *
               * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
               *
               * @example
               *
               *     var x32WordArray = x64WordArray.toX32();
               */
              toX32: function () {
                  // Shortcuts
                  var x64Words = this.words;
                  var x64WordsLength = x64Words.length;
      
                  // Convert
                  var x32Words = [];
                  for (var i = 0; i < x64WordsLength; i++) {
                      var x64Word = x64Words[i];
                      x32Words.push(x64Word.high);
                      x32Words.push(x64Word.low);
                  }
      
                  return X32WordArray.create(x32Words, this.sigBytes);
              },
      
              /**
               * Creates a copy of this word array.
               *
               * @return {X64WordArray} The clone.
               *
               * @example
               *
               *     var clone = x64WordArray.clone();
               */
              clone: function () {
                  var clone = Base.clone.call(this);
      
                  // Clone "words" array
                  var words = clone.words = this.words.slice(0);
      
                  // Clone each X64Word object
                  var wordsLength = words.length;
                  for (var i = 0; i < wordsLength; i++) {
                      words[i] = words[i].clone();
                  }
      
                  return clone;
              }
          });
      }());
      
      /*
      CryptoJS v3.1.2
      code.google.com/p/crypto-js
      (c) 2009-2013 by Jeff Mott. All rights reserved.
      code.google.com/p/crypto-js/wiki/License
      */
      /**
       * Cipher core components.
       */
      CryptoJS.lib.Cipher || (function (undefined) {
          // Shortcuts
          var C = CryptoJS;
          var C_lib = C.lib;
          var Base = C_lib.Base;
          var WordArray = C_lib.WordArray;
          var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
          var C_enc = C.enc;
          var Utf8 = C_enc.Utf8;
          var Base64 = C_enc.Base64;
          var C_algo = C.algo;
          var EvpKDF = C_algo.EvpKDF;
      
          /**
           * Abstract base cipher template.
           *
           * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
           * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
           * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
           * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
           */
          var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
              /**
               * Configuration options.
               *
               * @property {WordArray} iv The IV to use for this operation.
               */
              cfg: Base.extend(),
      
              /**
               * Creates this cipher in encryption mode.
               *
               * @param {WordArray} key The key.
               * @param {Object} cfg (Optional) The configuration options to use for this operation.
               *
               * @return {Cipher} A cipher instance.
               *
               * @static
               *
               * @example
               *
               *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
               */
              createEncryptor: function (key, cfg) {
                  return this.create(this._ENC_XFORM_MODE, key, cfg);
              },
      
              /**
               * Creates this cipher in decryption mode.
               *
               * @param {WordArray} key The key.
               * @param {Object} cfg (Optional) The configuration options to use for this operation.
               *
               * @return {Cipher} A cipher instance.
               *
               * @static
               *
               * @example
               *
               *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
               */
              createDecryptor: function (key, cfg) {
                  return this.create(this._DEC_XFORM_MODE, key, cfg);
              },
      
              /**
               * Initializes a newly created cipher.
               *
               * @param {number} xformMode Either the encryption or decryption transormation mode constant.
               * @param {WordArray} key The key.
               * @param {Object} cfg (Optional) The configuration options to use for this operation.
               *
               * @example
               *
               *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
               */
              init: function (xformMode, key, cfg) {
                  // Apply config defaults
                  this.cfg = this.cfg.extend(cfg);
      
                  // Store transform mode and key
                  this._xformMode = xformMode;
                  this._key = key;
      
                  // Set initial values
                  this.reset();
              },
      
              /**
               * Resets this cipher to its initial state.
               *
               * @example
               *
               *     cipher.reset();
               */
              reset: function () {
                  // Reset data buffer
                  BufferedBlockAlgorithm.reset.call(this);
      
                  // Perform concrete-cipher logic
                  this._doReset();
              },
      
              /**
               * Adds data to be encrypted or decrypted.
               *
               * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
               *
               * @return {WordArray} The data after processing.
               *
               * @example
               *
               *     var encrypted = cipher.process('data');
               *     var encrypted = cipher.process(wordArray);
               */
              process: function (dataUpdate) {
                  // Append
                  this._append(dataUpdate);
      
                  // Process available blocks
                  return this._process();
              },
      
              /**
               * Finalizes the encryption or decryption process.
               * Note that the finalize operation is effectively a destructive, read-once operation.
               *
               * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
               *
               * @return {WordArray} The data after final processing.
               *
               * @example
               *
               *     var encrypted = cipher.finalize();
               *     var encrypted = cipher.finalize('data');
               *     var encrypted = cipher.finalize(wordArray);
               */
              finalize: function (dataUpdate) {
                  // Final data update
                  if (dataUpdate) {
                      this._append(dataUpdate);
                  }
      
                  // Perform concrete-cipher logic
                  var finalProcessedData = this._doFinalize();
      
                  return finalProcessedData;
              },
      
              keySize: 128/32,
      
              ivSize: 128/32,
      
              _ENC_XFORM_MODE: 1,
      
              _DEC_XFORM_MODE: 2,
      
              /**
               * Creates shortcut functions to a cipher's object interface.
               *
               * @param {Cipher} cipher The cipher to create a helper for.
               *
               * @return {Object} An object with encrypt and decrypt shortcut functions.
               *
               * @static
               *
               * @example
               *
               *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
               */
              _createHelper: (function () {
                  function selectCipherStrategy(key) {
                      if (typeof key == 'string') {
                          return PasswordBasedCipher;
                      } else {
                          return SerializableCipher;
                      }
                  }
      
                  return function (cipher) {
                      return {
                          encrypt: function (message, key, cfg) {
                              return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                          },
      
                          decrypt: function (ciphertext, key, cfg) {
                              return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                          }
                      };
                  };
              }())
          });
      
          /**
           * Abstract base stream cipher template.
           *
           * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
           */
          var StreamCipher = C_lib.StreamCipher = Cipher.extend({
              _doFinalize: function () {
                  // Process partial blocks
                  var finalProcessedBlocks = this._process(!!'flush');
      
                  return finalProcessedBlocks;
              },
      
              blockSize: 1
          });
      
          /**
           * Mode namespace.
           */
          var C_mode = C.mode = {};
      
          /**
           * Abstract base block cipher mode template.
           */
          var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
              /**
               * Creates this mode for encryption.
               *
               * @param {Cipher} cipher A block cipher instance.
               * @param {Array} iv The IV words.
               *
               * @static
               *
               * @example
               *
               *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
               */
              createEncryptor: function (cipher, iv) {
                  return this.Encryptor.create(cipher, iv);
              },
      
              /**
               * Creates this mode for decryption.
               *
               * @param {Cipher} cipher A block cipher instance.
               * @param {Array} iv The IV words.
               *
               * @static
               *
               * @example
               *
               *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
               */
              createDecryptor: function (cipher, iv) {
                  return this.Decryptor.create(cipher, iv);
              },
      
              /**
               * Initializes a newly created mode.
               *
               * @param {Cipher} cipher A block cipher instance.
               * @param {Array} iv The IV words.
               *
               * @example
               *
               *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
               */
              init: function (cipher, iv) {
                  this._cipher = cipher;
                  this._iv = iv;
              }
          });
      
          /**
           * Cipher Block Chaining mode.
           */
          var CBC = C_mode.CBC = (function () {
              /**
               * Abstract base CBC mode.
               */
              var CBC = BlockCipherMode.extend();
      
              /**
               * CBC encryptor.
               */
              CBC.Encryptor = CBC.extend({
                  /**
                   * Processes the data block at offset.
                   *
                   * @param {Array} words The data words to operate on.
                   * @param {number} offset The offset where the block starts.
                   *
                   * @example
                   *
                   *     mode.processBlock(data.words, offset);
                   */
                  processBlock: function (words, offset) {
                      // Shortcuts
                      var cipher = this._cipher;
                      var blockSize = cipher.blockSize;
      
                      // XOR and encrypt
                      xorBlock.call(this, words, offset, blockSize);
                      cipher.encryptBlock(words, offset);
      
                      // Remember this block to use with next block
                      this._prevBlock = words.slice(offset, offset + blockSize);
                  }
              });
      
              /**
               * CBC decryptor.
               */
              CBC.Decryptor = CBC.extend({
                  /**
                   * Processes the data block at offset.
                   *
                   * @param {Array} words The data words to operate on.
                   * @param {number} offset The offset where the block starts.
                   *
                   * @example
                   *
                   *     mode.processBlock(data.words, offset);
                   */
                  processBlock: function (words, offset) {
                      // Shortcuts
                      var cipher = this._cipher;
                      var blockSize = cipher.blockSize;
      
                      // Remember this block to use with next block
                      var thisBlock = words.slice(offset, offset + blockSize);
      
                      // Decrypt and XOR
                      cipher.decryptBlock(words, offset);
                      xorBlock.call(this, words, offset, blockSize);
      
                      // This block becomes the previous block
                      this._prevBlock = thisBlock;
                  }
              });
      
              function xorBlock(words, offset, blockSize) {
                  // Shortcut
                  var iv = this._iv;
      
                  // Choose mixing block
                  if (iv) {
                      var block = iv;
      
                      // Remove IV for subsequent blocks
                      this._iv = undefined;
                  } else {
                      var block = this._prevBlock;
                  }
      
                  // XOR blocks
                  for (var i = 0; i < blockSize; i++) {
                      words[offset + i] ^= block[i];
                  }
              }
      
              return CBC;
          }());
      
          /**
           * Padding namespace.
           */
          var C_pad = C.pad = {};
      
          /**
           * PKCS #5/7 padding strategy.
           */
          var Pkcs7 = C_pad.Pkcs7 = {
              /**
               * Pads data using the algorithm defined in PKCS #5/7.
               *
               * @param {WordArray} data The data to pad.
               * @param {number} blockSize The multiple that the data should be padded to.
               *
               * @static
               *
               * @example
               *
               *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
               */
              pad: function (data, blockSize) {
                  // Shortcut
                  var blockSizeBytes = blockSize * 4;
      
                  // Count padding bytes
                  var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
      
                  // Create padding word
                  var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;
      
                  // Create padding
                  var paddingWords = [];
                  for (var i = 0; i < nPaddingBytes; i += 4) {
                      paddingWords.push(paddingWord);
                  }
                  var padding = WordArray.create(paddingWords, nPaddingBytes);
      
                  // Add padding
                  data.concat(padding);
              },
      
              /**
               * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
               *
               * @param {WordArray} data The data to unpad.
               *
               * @static
               *
               * @example
               *
               *     CryptoJS.pad.Pkcs7.unpad(wordArray);
               */
              unpad: function (data) {
                  // Get number of padding bytes from last byte
                  var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;
      
                  // Remove padding
                  data.sigBytes -= nPaddingBytes;
              }
          };
      
          /**
           * Abstract base block cipher template.
           *
           * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
           */
          var BlockCipher = C_lib.BlockCipher = Cipher.extend({
              /**
               * Configuration options.
               *
               * @property {Mode} mode The block mode to use. Default: CBC
               * @property {Padding} padding The padding strategy to use. Default: Pkcs7
               */
              cfg: Cipher.cfg.extend({
                  mode: CBC,
                  padding: Pkcs7
              }),
      
              reset: function () {
                  // Reset cipher
                  Cipher.reset.call(this);
      
                  // Shortcuts
                  var cfg = this.cfg;
                  var iv = cfg.iv;
                  var mode = cfg.mode;
      
                  // Reset block mode
                  if (this._xformMode == this._ENC_XFORM_MODE) {
                      var modeCreator = mode.createEncryptor;
                  } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                      var modeCreator = mode.createDecryptor;
      
                      // Keep at least one block in the buffer for unpadding
                      this._minBufferSize = 1;
                  }
                  this._mode = modeCreator.call(mode, this, iv && iv.words);
              },
      
              _doProcessBlock: function (words, offset) {
                  this._mode.processBlock(words, offset);
              },
      
              _doFinalize: function () {
                  // Shortcut
                  var padding = this.cfg.padding;
      
                  // Finalize
                  if (this._xformMode == this._ENC_XFORM_MODE) {
                      // Pad data
                      padding.pad(this._data, this.blockSize);
      
                      // Process final blocks
                      var finalProcessedBlocks = this._process(!!'flush');
                  } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                      // Process final blocks
                      var finalProcessedBlocks = this._process(!!'flush');
      
                      // Unpad data
                      padding.unpad(finalProcessedBlocks);
                  }
      
                  return finalProcessedBlocks;
              },
      
              blockSize: 128/32
          });
      
          /**
           * A collection of cipher parameters.
           *
           * @property {WordArray} ciphertext The raw ciphertext.
           * @property {WordArray} key The key to this ciphertext.
           * @property {WordArray} iv The IV used in the ciphering operation.
           * @property {WordArray} salt The salt used with a key derivation function.
           * @property {Cipher} algorithm The cipher algorithm.
           * @property {Mode} mode The block mode used in the ciphering operation.
           * @property {Padding} padding The padding scheme used in the ciphering operation.
           * @property {number} blockSize The block size of the cipher.
           * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
           */
          var CipherParams = C_lib.CipherParams = Base.extend({
              /**
               * Initializes a newly created cipher params object.
               *
               * @param {Object} cipherParams An object with any of the possible cipher parameters.
               *
               * @example
               *
               *     var cipherParams = CryptoJS.lib.CipherParams.create({
               *         ciphertext: ciphertextWordArray,
               *         key: keyWordArray,
               *         iv: ivWordArray,
               *         salt: saltWordArray,
               *         algorithm: CryptoJS.algo.AES,
               *         mode: CryptoJS.mode.CBC,
               *         padding: CryptoJS.pad.PKCS7,
               *         blockSize: 4,
               *         formatter: CryptoJS.format.OpenSSL
               *     });
               */
              init: function (cipherParams) {
                  this.mixIn(cipherParams);
              },
      
              /**
               * Converts this cipher params object to a string.
               *
               * @param {Format} formatter (Optional) The formatting strategy to use.
               *
               * @return {string} The stringified cipher params.
               *
               * @throws Error If neither the formatter nor the default formatter is set.
               *
               * @example
               *
               *     var string = cipherParams + '';
               *     var string = cipherParams.toString();
               *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
               */
              toString: function (formatter) {
                  return (formatter || this.formatter).stringify(this);
              }
          });
      
          /**
           * Format namespace.
           */
          var C_format = C.format = {};
      
          /**
           * OpenSSL formatting strategy.
           */
          var OpenSSLFormatter = C_format.OpenSSL = {
              /**
               * Converts a cipher params object to an OpenSSL-compatible string.
               *
               * @param {CipherParams} cipherParams The cipher params object.
               *
               * @return {string} The OpenSSL-compatible string.
               *
               * @static
               *
               * @example
               *
               *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
               */
              stringify: function (cipherParams) {
                  // Shortcuts
                  var ciphertext = cipherParams.ciphertext;
                  var salt = cipherParams.salt;
      
                  // Format
                  if (salt) {
                      var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
                  } else {
                      var wordArray = ciphertext;
                  }
      
                  return wordArray.toString(Base64);
              },
      
              /**
               * Converts an OpenSSL-compatible string to a cipher params object.
               *
               * @param {string} openSSLStr The OpenSSL-compatible string.
               *
               * @return {CipherParams} The cipher params object.
               *
               * @static
               *
               * @example
               *
               *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
               */
              parse: function (openSSLStr) {
                  // Parse base64
                  var ciphertext = Base64.parse(openSSLStr);
      
                  // Shortcut
                  var ciphertextWords = ciphertext.words;
      
                  // Test for salt
                  if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
                      // Extract salt
                      var salt = WordArray.create(ciphertextWords.slice(2, 4));
      
                      // Remove salt from ciphertext
                      ciphertextWords.splice(0, 4);
                      ciphertext.sigBytes -= 16;
                  }
      
                  return CipherParams.create({ ciphertext: ciphertext, salt: salt });
              }
          };
      
          /**
           * A cipher wrapper that returns ciphertext as a serializable cipher params object.
           */
          var SerializableCipher = C_lib.SerializableCipher = Base.extend({
              /**
               * Configuration options.
               *
               * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
               */
              cfg: Base.extend({
                  format: OpenSSLFormatter
              }),
      
              /**
               * Encrypts a message.
               *
               * @param {Cipher} cipher The cipher algorithm to use.
               * @param {WordArray|string} message The message to encrypt.
               * @param {WordArray} key The key.
               * @param {Object} cfg (Optional) The configuration options to use for this operation.
               *
               * @return {CipherParams} A cipher params object.
               *
               * @static
               *
               * @example
               *
               *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
               *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
               *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
               */
              encrypt: function (cipher, message, key, cfg) {
                  // Apply config defaults
                  cfg = this.cfg.extend(cfg);
      
                  // Encrypt
                  var encryptor = cipher.createEncryptor(key, cfg);
                  var ciphertext = encryptor.finalize(message);
      
                  // Shortcut
                  var cipherCfg = encryptor.cfg;
      
                  // Create and return serializable cipher params
                  return CipherParams.create({
                      ciphertext: ciphertext,
                      key: key,
                      iv: cipherCfg.iv,
                      algorithm: cipher,
                      mode: cipherCfg.mode,
                      padding: cipherCfg.padding,
                      blockSize: cipher.blockSize,
                      formatter: cfg.format
                  });
              },
      
              /**
               * Decrypts serialized ciphertext.
               *
               * @param {Cipher} cipher The cipher algorithm to use.
               * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
               * @param {WordArray} key The key.
               * @param {Object} cfg (Optional) The configuration options to use for this operation.
               *
               * @return {WordArray} The plaintext.
               *
               * @static
               *
               * @example
               *
               *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
               *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
               */
              decrypt: function (cipher, ciphertext, key, cfg) {
                  // Apply config defaults
                  cfg = this.cfg.extend(cfg);
      
                  // Convert string to CipherParams
                  ciphertext = this._parse(ciphertext, cfg.format);
      
                  // Decrypt
                  var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
      
                  return plaintext;
              },
      
              /**
               * Converts serialized ciphertext to CipherParams,
               * else assumed CipherParams already and returns ciphertext unchanged.
               *
               * @param {CipherParams|string} ciphertext The ciphertext.
               * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
               *
               * @return {CipherParams} The unserialized ciphertext.
               *
               * @static
               *
               * @example
               *
               *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
               */
              _parse: function (ciphertext, format) {
                  if (typeof ciphertext == 'string') {
                      return format.parse(ciphertext, this);
                  } else {
                      return ciphertext;
                  }
              }
          });
      
          /**
           * Key derivation function namespace.
           */
          var C_kdf = C.kdf = {};
      
          /**
           * OpenSSL key derivation function.
           */
          var OpenSSLKdf = C_kdf.OpenSSL = {
              /**
               * Derives a key and IV from a password.
               *
               * @param {string} password The password to derive from.
               * @param {number} keySize The size in words of the key to generate.
               * @param {number} ivSize The size in words of the IV to generate.
               * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
               *
               * @return {CipherParams} A cipher params object with the key, IV, and salt.
               *
               * @static
               *
               * @example
               *
               *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
               *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
               */
              execute: function (password, keySize, ivSize, salt) {
                  // Generate random salt
                  if (!salt) {
                      salt = WordArray.random(64/8);
                  }
      
                  // Derive key and IV
                  var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
      
                  // Separate key and IV
                  var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
                  key.sigBytes = keySize * 4;
      
                  // Return params
                  return CipherParams.create({ key: key, iv: iv, salt: salt });
              }
          };
      
          /**
           * A serializable cipher wrapper that derives the key from a password,
           * and returns ciphertext as a serializable cipher params object.
           */
          var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
              /**
               * Configuration options.
               *
               * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
               */
              cfg: SerializableCipher.cfg.extend({
                  kdf: OpenSSLKdf
              }),
      
              /**
               * Encrypts a message using a password.
               *
               * @param {Cipher} cipher The cipher algorithm to use.
               * @param {WordArray|string} message The message to encrypt.
               * @param {string} password The password.
               * @param {Object} cfg (Optional) The configuration options to use for this operation.
               *
               * @return {CipherParams} A cipher params object.
               *
               * @static
               *
               * @example
               *
               *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
               *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
               */
              encrypt: function (cipher, message, password, cfg) {
                  // Apply config defaults
                  cfg = this.cfg.extend(cfg);
      
                  // Derive key and other params
                  var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
      
                  // Add IV to config
                  cfg.iv = derivedParams.iv;
      
                  // Encrypt
                  var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
      
                  // Mix in derived params
                  ciphertext.mixIn(derivedParams);
      
                  return ciphertext;
              },
      
              /**
               * Decrypts serialized ciphertext using a password.
               *
               * @param {Cipher} cipher The cipher algorithm to use.
               * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
               * @param {string} password The password.
               * @param {Object} cfg (Optional) The configuration options to use for this operation.
               *
               * @return {WordArray} The plaintext.
               *
               * @static
               *
               * @example
               *
               *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
               *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
               */
              decrypt: function (cipher, ciphertext, password, cfg) {
                  // Apply config defaults
                  cfg = this.cfg.extend(cfg);
      
                  // Convert string to CipherParams
                  ciphertext = this._parse(ciphertext, cfg.format);
      
                  // Derive key and other params
                  var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
      
                  // Add IV to config
                  cfg.iv = derivedParams.iv;
      
                  // Decrypt
                  var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
      
                  return plaintext;
              }
          });
      }());
      
      /*
      CryptoJS v3.1.2
      code.google.com/p/crypto-js
      (c) 2009-2013 by Jeff Mott. All rights reserved.
      code.google.com/p/crypto-js/wiki/License
      */
      (function () {
          // Shortcuts
          var C = CryptoJS;
          var C_lib = C.lib;
          var Base = C_lib.Base;
          var C_enc = C.enc;
          var Utf8 = C_enc.Utf8;
          var C_algo = C.algo;
      
          /**
           * HMAC algorithm.
           */
          var HMAC = C_algo.HMAC = Base.extend({
              /**
               * Initializes a newly created HMAC.
               *
               * @param {Hasher} hasher The hash algorithm to use.
               * @param {WordArray|string} key The secret key.
               *
               * @example
               *
               *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
               */
              init: function (hasher, key) {
                  // Init hasher
                  hasher = this._hasher = new hasher.init();
      
                  // Convert string to WordArray, else assume WordArray already
                  if (typeof key == 'string') {
                      key = Utf8.parse(key);
                  }
      
                  // Shortcuts
                  var hasherBlockSize = hasher.blockSize;
                  var hasherBlockSizeBytes = hasherBlockSize * 4;
      
                  // Allow arbitrary length keys
                  if (key.sigBytes > hasherBlockSizeBytes) {
                      key = hasher.finalize(key);
                  }
      
                  // Clamp excess bits
                  key.clamp();
      
                  // Clone key for inner and outer pads
                  var oKey = this._oKey = key.clone();
                  var iKey = this._iKey = key.clone();
      
                  // Shortcuts
                  var oKeyWords = oKey.words;
                  var iKeyWords = iKey.words;
      
                  // XOR keys with pad constants
                  for (var i = 0; i < hasherBlockSize; i++) {
                      oKeyWords[i] ^= 0x5c5c5c5c;
                      iKeyWords[i] ^= 0x36363636;
                  }
                  oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
      
                  // Set initial values
                  this.reset();
              },
      
              /**
               * Resets this HMAC to its initial state.
               *
               * @example
               *
               *     hmacHasher.reset();
               */
              reset: function () {
                  // Shortcut
                  var hasher = this._hasher;
      
                  // Reset
                  hasher.reset();
                  hasher.update(this._iKey);
              },
      
              /**
               * Updates this HMAC with a message.
               *
               * @param {WordArray|string} messageUpdate The message to append.
               *
               * @return {HMAC} This HMAC instance.
               *
               * @example
               *
               *     hmacHasher.update('message');
               *     hmacHasher.update(wordArray);
               */
              update: function (messageUpdate) {
                  this._hasher.update(messageUpdate);
      
                  // Chainable
                  return this;
              },
      
              /**
               * Finalizes the HMAC computation.
               * Note that the finalize operation is effectively a destructive, read-once operation.
               *
               * @param {WordArray|string} messageUpdate (Optional) A final message update.
               *
               * @return {WordArray} The HMAC.
               *
               * @example
               *
               *     var hmac = hmacHasher.finalize();
               *     var hmac = hmacHasher.finalize('message');
               *     var hmac = hmacHasher.finalize(wordArray);
               */
              finalize: function (messageUpdate) {
                  // Shortcut
                  var hasher = this._hasher;
      
                  // Compute HMAC
                  var innerHash = hasher.finalize(messageUpdate);
                  hasher.reset();
                  var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
      
                  return hmac;
              }
          });
      }());
      
      /*
      CryptoJS v3.1.2
      code.google.com/p/crypto-js
      (c) 2009-2013 by Jeff Mott. All rights reserved.
      code.google.com/p/crypto-js/wiki/License
      */
      (function () {
          // Shortcuts
          var C = CryptoJS;
          var C_lib = C.lib;
          var BlockCipher = C_lib.BlockCipher;
          var C_algo = C.algo;
      
          // Lookup tables
          var SBOX = [];
          var INV_SBOX = [];
          var SUB_MIX_0 = [];
          var SUB_MIX_1 = [];
          var SUB_MIX_2 = [];
          var SUB_MIX_3 = [];
          var INV_SUB_MIX_0 = [];
          var INV_SUB_MIX_1 = [];
          var INV_SUB_MIX_2 = [];
          var INV_SUB_MIX_3 = [];
      
          // Compute lookup tables
          (function () {
              // Compute double table
              var d = [];
              for (var i = 0; i < 256; i++) {
                  if (i < 128) {
                      d[i] = i << 1;
                  } else {
                      d[i] = (i << 1) ^ 0x11b;
                  }
              }
      
              // Walk GF(2^8)
              var x = 0;
              var xi = 0;
              for (var i = 0; i < 256; i++) {
                  // Compute sbox
                  var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
                  sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
                  SBOX[x] = sx;
                  INV_SBOX[sx] = x;
      
                  // Compute multiplication
                  var x2 = d[x];
                  var x4 = d[x2];
                  var x8 = d[x4];
      
                  // Compute sub bytes, mix columns tables
                  var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
                  SUB_MIX_0[x] = (t << 24) | (t >>> 8);
                  SUB_MIX_1[x] = (t << 16) | (t >>> 16);
                  SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
                  SUB_MIX_3[x] = t;
      
                  // Compute inv sub bytes, inv mix columns tables
                  var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
                  INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
                  INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
                  INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
                  INV_SUB_MIX_3[sx] = t;
      
                  // Compute next counter
                  if (!x) {
                      x = xi = 1;
                  } else {
                      x = x2 ^ d[d[d[x8 ^ x2]]];
                      xi ^= d[d[xi]];
                  }
              }
          }());
      
          // Precomputed Rcon lookup
          var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
      
          /**
           * AES block cipher algorithm.
           */
          var AES = C_algo.AES = BlockCipher.extend({
              _doReset: function () {
                  // Shortcuts
                  var key = this._key;
                  var keyWords = key.words;
                  var keySize = key.sigBytes / 4;
      
                  // Compute number of rounds
                  var nRounds = this._nRounds = keySize + 6
      
                  // Compute number of key schedule rows
                  var ksRows = (nRounds + 1) * 4;
      
                  // Compute key schedule
                  var keySchedule = this._keySchedule = [];
                  for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                      if (ksRow < keySize) {
                          keySchedule[ksRow] = keyWords[ksRow];
                      } else {
                          var t = keySchedule[ksRow - 1];
      
                          if (!(ksRow % keySize)) {
                              // Rot word
                              t = (t << 8) | (t >>> 24);
      
                              // Sub word
                              t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
      
                              // Mix Rcon
                              t ^= RCON[(ksRow / keySize) | 0] << 24;
                          } else if (keySize > 6 && ksRow % keySize == 4) {
                              // Sub word
                              t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
                          }
      
                          keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                      }
                  }
      
                  // Compute inv key schedule
                  var invKeySchedule = this._invKeySchedule = [];
                  for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                      var ksRow = ksRows - invKsRow;
      
                      if (invKsRow % 4) {
                          var t = keySchedule[ksRow];
                      } else {
                          var t = keySchedule[ksRow - 4];
                      }
      
                      if (invKsRow < 4 || ksRow <= 4) {
                          invKeySchedule[invKsRow] = t;
                      } else {
                          invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
                                                     INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
                      }
                  }
              },
      
              encryptBlock: function (M, offset) {
                  this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
              },
      
              decryptBlock: function (M, offset) {
                  // Swap 2nd and 4th rows
                  var t = M[offset + 1];
                  M[offset + 1] = M[offset + 3];
                  M[offset + 3] = t;
      
                  this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
      
                  // Inv swap 2nd and 4th rows
                  var t = M[offset + 1];
                  M[offset + 1] = M[offset + 3];
                  M[offset + 3] = t;
              },
      
              _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
                  // Shortcut
                  var nRounds = this._nRounds;
      
                  // Get input, add round key
                  var s0 = M[offset]     ^ keySchedule[0];
                  var s1 = M[offset + 1] ^ keySchedule[1];
                  var s2 = M[offset + 2] ^ keySchedule[2];
                  var s3 = M[offset + 3] ^ keySchedule[3];
      
                  // Key schedule row counter
                  var ksRow = 4;
      
                  // Rounds
                  for (var round = 1; round < nRounds; round++) {
                      // Shift rows, sub bytes, mix columns, add round key
                      var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
                      var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
                      var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
                      var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];
      
                      // Update state
                      s0 = t0;
                      s1 = t1;
                      s2 = t2;
                      s3 = t3;
                  }
      
                  // Shift rows, sub bytes, add round key
                  var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
                  var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
                  var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
                  var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
      
                  // Set output
                  M[offset]     = t0;
                  M[offset + 1] = t1;
                  M[offset + 2] = t2;
                  M[offset + 3] = t3;
              },
      
              keySize: 256/32
          });
      
          /**
           * Shortcut functions to the cipher's object interface.
           *
           * @example
           *
           *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
           *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
           */
          C.AES = BlockCipher._createHelper(AES);
      }());
      
      /*
      CryptoJS v3.1.2
      code.google.com/p/crypto-js
      (c) 2009-2013 by Jeff Mott. All rights reserved.
      code.google.com/p/crypto-js/wiki/License
      */
      /** @preserve
      (c) 2012 by Cédric Mesnil. All rights reserved.
      
      Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
      
          - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
          - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
      
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      */
      
      (function (Math) {
          // Shortcuts
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C.algo;
      
          // Constants table
          var _zl = WordArray.create([
              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
              7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
              3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
              1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
              4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
          var _zr = WordArray.create([
              5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
              6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
              15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
              8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
              12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
          var _sl = WordArray.create([
               11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
              7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
              11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
                11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
              9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
          var _sr = WordArray.create([
              8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
              9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
              9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
              15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
              8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);
      
          var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
          var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);
      
          /**
           * RIPEMD160 hash algorithm.
           */
          var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
              _doReset: function () {
                  this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
              },
      
              _doProcessBlock: function (M, offset) {
      
                  // Swap endian
                  for (var i = 0; i < 16; i++) {
                      // Shortcuts
                      var offset_i = offset + i;
                      var M_offset_i = M[offset_i];
      
                      // Swap
                      M[offset_i] = (
                          (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
                          (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
                      );
                  }
                  // Shortcut
                  var H  = this._hash.words;
                  var hl = _hl.words;
                  var hr = _hr.words;
                  var zl = _zl.words;
                  var zr = _zr.words;
                  var sl = _sl.words;
                  var sr = _sr.words;
      
                  // Working variables
                  var al, bl, cl, dl, el;
                  var ar, br, cr, dr, er;
      
                  ar = al = H[0];
                  br = bl = H[1];
                  cr = cl = H[2];
                  dr = dl = H[3];
                  er = el = H[4];
                  // Computation
                  var t;
                  for (var i = 0; i < 80; i += 1) {
                      t = (al +  M[offset+zl[i]])|0;
                      if (i<16){
      	            t +=  f1(bl,cl,dl) + hl[0];
                      } else if (i<32) {
      	            t +=  f2(bl,cl,dl) + hl[1];
                      } else if (i<48) {
      	            t +=  f3(bl,cl,dl) + hl[2];
                      } else if (i<64) {
      	            t +=  f4(bl,cl,dl) + hl[3];
                      } else {// if (i<80) {
      	            t +=  f5(bl,cl,dl) + hl[4];
                      }
                      t = t|0;
                      t =  rotl(t,sl[i]);
                      t = (t+el)|0;
                      al = el;
                      el = dl;
                      dl = rotl(cl, 10);
                      cl = bl;
                      bl = t;
      
                      t = (ar + M[offset+zr[i]])|0;
                      if (i<16){
      	            t +=  f5(br,cr,dr) + hr[0];
                      } else if (i<32) {
      	            t +=  f4(br,cr,dr) + hr[1];
                      } else if (i<48) {
      	            t +=  f3(br,cr,dr) + hr[2];
                      } else if (i<64) {
      	            t +=  f2(br,cr,dr) + hr[3];
                      } else {// if (i<80) {
      	            t +=  f1(br,cr,dr) + hr[4];
                      }
                      t = t|0;
                      t =  rotl(t,sr[i]) ;
                      t = (t+er)|0;
                      ar = er;
                      er = dr;
                      dr = rotl(cr, 10);
                      cr = br;
                      br = t;
                  }
                  // Intermediate hash value
                  t    = (H[1] + cl + dr)|0;
                  H[1] = (H[2] + dl + er)|0;
                  H[2] = (H[3] + el + ar)|0;
                  H[3] = (H[4] + al + br)|0;
                  H[4] = (H[0] + bl + cr)|0;
                  H[0] =  t;
              },
      
              _doFinalize: function () {
                  // Shortcuts
                  var data = this._data;
                  var dataWords = data.words;
      
                  var nBitsTotal = this._nDataBytes * 8;
                  var nBitsLeft = data.sigBytes * 8;
      
                  // Add padding
                  dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
                  dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
                      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
                      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
                  );
                  data.sigBytes = (dataWords.length + 1) * 4;
      
                  // Hash final blocks
                  this._process();
      
                  // Shortcuts
                  var hash = this._hash;
                  var H = hash.words;
      
                  // Swap endian
                  for (var i = 0; i < 5; i++) {
                      // Shortcut
                      var H_i = H[i];
      
                      // Swap
                      H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
                             (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
                  }
      
                  // Return final computed hash
                  return hash;
              },
      
              clone: function () {
                  var clone = Hasher.clone.call(this);
                  clone._hash = this._hash.clone();
      
                  return clone;
              }
          });
      
      
          function f1(x, y, z) {
              return ((x) ^ (y) ^ (z));
      
          }
      
          function f2(x, y, z) {
              return (((x)&(y)) | ((~x)&(z)));
          }
      
          function f3(x, y, z) {
              return (((x) | (~(y))) ^ (z));
          }
      
          function f4(x, y, z) {
              return (((x) & (z)) | ((y)&(~(z))));
          }
      
          function f5(x, y, z) {
              return ((x) ^ ((y) |(~(z))));
      
          }
      
          function rotl(x,n) {
              return (x<<n) | (x>>>(32-n));
          }
      
      
          /**
           * Shortcut function to the hasher's object interface.
           *
           * @param {WordArray|string} message The message to hash.
           *
           * @return {WordArray} The hash.
           *
           * @static
           *
           * @example
           *
           *     var hash = CryptoJS.RIPEMD160('message');
           *     var hash = CryptoJS.RIPEMD160(wordArray);
           */
          C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
      
          /**
           * Shortcut function to the HMAC's object interface.
           *
           * @param {WordArray|string} message The message to hash.
           * @param {WordArray|string} key The secret key.
           *
           * @return {WordArray} The HMAC.
           *
           * @static
           *
           * @example
           *
           *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
           */
          C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      }(Math));
      
      /*
      CryptoJS v3.1.2
      code.google.com/p/crypto-js
      (c) 2009-2013 by Jeff Mott. All rights reserved.
      code.google.com/p/crypto-js/wiki/License
      */
      (function (Math) {
          // Shortcuts
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C.algo;
      
          // Initialization and round constants tables
          var H = [];
          var K = [];
      
          // Compute constants
          (function () {
              function isPrime(n) {
                  var sqrtN = Math.sqrt(n);
                  for (var factor = 2; factor <= sqrtN; factor++) {
                      if (!(n % factor)) {
                          return false;
                      }
                  }
      
                  return true;
              }
      
              function getFractionalBits(n) {
                  return ((n - (n | 0)) * 0x100000000) | 0;
              }
      
              var n = 2;
              var nPrime = 0;
              while (nPrime < 64) {
                  if (isPrime(n)) {
                      if (nPrime < 8) {
                          H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                      }
                      K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));
      
                      nPrime++;
                  }
      
                  n++;
              }
          }());
      
          // Reusable object
          var W = [];
      
          /**
           * SHA-256 hash algorithm.
           */
          var SHA256 = C_algo.SHA256 = Hasher.extend({
              _doReset: function () {
                  this._hash = new WordArray.init(H.slice(0));
              },
      
              _doProcessBlock: function (M, offset) {
                  // Shortcut
                  var H = this._hash.words;
      
                  // Working variables
                  var a = H[0];
                  var b = H[1];
                  var c = H[2];
                  var d = H[3];
                  var e = H[4];
                  var f = H[5];
                  var g = H[6];
                  var h = H[7];
      
                  // Computation
                  for (var i = 0; i < 64; i++) {
                      if (i < 16) {
                          W[i] = M[offset + i] | 0;
                      } else {
                          var gamma0x = W[i - 15];
                          var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
                                        ((gamma0x << 14) | (gamma0x >>> 18)) ^
                                         (gamma0x >>> 3);
      
                          var gamma1x = W[i - 2];
                          var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
                                        ((gamma1x << 13) | (gamma1x >>> 19)) ^
                                         (gamma1x >>> 10);
      
                          W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                      }
      
                      var ch  = (e & f) ^ (~e & g);
                      var maj = (a & b) ^ (a & c) ^ (b & c);
      
                      var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
                      var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));
      
                      var t1 = h + sigma1 + ch + K[i] + W[i];
                      var t2 = sigma0 + maj;
      
                      h = g;
                      g = f;
                      f = e;
                      e = (d + t1) | 0;
                      d = c;
                      c = b;
                      b = a;
                      a = (t1 + t2) | 0;
                  }
      
                  // Intermediate hash value
                  H[0] = (H[0] + a) | 0;
                  H[1] = (H[1] + b) | 0;
                  H[2] = (H[2] + c) | 0;
                  H[3] = (H[3] + d) | 0;
                  H[4] = (H[4] + e) | 0;
                  H[5] = (H[5] + f) | 0;
                  H[6] = (H[6] + g) | 0;
                  H[7] = (H[7] + h) | 0;
              },
      
              _doFinalize: function () {
                  // Shortcuts
                  var data = this._data;
                  var dataWords = data.words;
      
                  var nBitsTotal = this._nDataBytes * 8;
                  var nBitsLeft = data.sigBytes * 8;
      
                  // Add padding
                  dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
                  dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
                  dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
                  data.sigBytes = dataWords.length * 4;
      
                  // Hash final blocks
                  this._process();
      
                  // Return final computed hash
                  return this._hash;
              },
      
              clone: function () {
                  var clone = Hasher.clone.call(this);
                  clone._hash = this._hash.clone();
      
                  return clone;
              }
          });
      
          /**
           * Shortcut function to the hasher's object interface.
           *
           * @param {WordArray|string} message The message to hash.
           *
           * @return {WordArray} The hash.
           *
           * @static
           *
           * @example
           *
           *     var hash = CryptoJS.SHA256('message');
           *     var hash = CryptoJS.SHA256(wordArray);
           */
          C.SHA256 = Hasher._createHelper(SHA256);
      
          /**
           * Shortcut function to the HMAC's object interface.
           *
           * @param {WordArray|string} message The message to hash.
           * @param {WordArray|string} key The secret key.
           *
           * @return {WordArray} The HMAC.
           *
           * @static
           *
           * @example
           *
           *     var hmac = CryptoJS.HmacSHA256(message, key);
           */
          C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      }(Math));
      
      /*
      CryptoJS v3.1.2
      code.google.com/p/crypto-js
      (c) 2009-2013 by Jeff Mott. All rights reserved.
      code.google.com/p/crypto-js/wiki/License
      */
      (function () {
          // Shortcuts
          var C = CryptoJS;
          var C_lib = C.lib;
          var Hasher = C_lib.Hasher;
          var C_x64 = C.x64;
          var X64Word = C_x64.Word;
          var X64WordArray = C_x64.WordArray;
          var C_algo = C.algo;
      
          function X64Word_create() {
              return X64Word.create.apply(X64Word, arguments);
          }
      
          // Constants
          var K = [
              X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
              X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
              X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
              X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
              X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
              X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
              X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
              X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
              X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
              X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
              X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
              X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
              X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
              X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
              X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
              X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
              X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
              X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
              X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
              X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
              X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
              X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
              X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
              X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
              X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
              X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
              X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
              X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
              X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
              X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
              X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
              X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
              X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
              X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
              X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
              X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
              X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
              X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
              X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
              X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
          ];
      
          // Reusable objects
          var W = [];
          (function () {
              for (var i = 0; i < 80; i++) {
                  W[i] = X64Word_create();
              }
          }());
      
          /**
           * SHA-512 hash algorithm.
           */
          var SHA512 = C_algo.SHA512 = Hasher.extend({
              _doReset: function () {
                  this._hash = new X64WordArray.init([
                      new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
                      new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
                      new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
                      new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
                  ]);
              },
      
              _doProcessBlock: function (M, offset) {
                  // Shortcuts
                  var H = this._hash.words;
      
                  var H0 = H[0];
                  var H1 = H[1];
                  var H2 = H[2];
                  var H3 = H[3];
                  var H4 = H[4];
                  var H5 = H[5];
                  var H6 = H[6];
                  var H7 = H[7];
      
                  var H0h = H0.high;
                  var H0l = H0.low;
                  var H1h = H1.high;
                  var H1l = H1.low;
                  var H2h = H2.high;
                  var H2l = H2.low;
                  var H3h = H3.high;
                  var H3l = H3.low;
                  var H4h = H4.high;
                  var H4l = H4.low;
                  var H5h = H5.high;
                  var H5l = H5.low;
                  var H6h = H6.high;
                  var H6l = H6.low;
                  var H7h = H7.high;
                  var H7l = H7.low;
      
                  // Working variables
                  var ah = H0h;
                  var al = H0l;
                  var bh = H1h;
                  var bl = H1l;
                  var ch = H2h;
                  var cl = H2l;
                  var dh = H3h;
                  var dl = H3l;
                  var eh = H4h;
                  var el = H4l;
                  var fh = H5h;
                  var fl = H5l;
                  var gh = H6h;
                  var gl = H6l;
                  var hh = H7h;
                  var hl = H7l;
      
                  // Rounds
                  for (var i = 0; i < 80; i++) {
                      // Shortcut
                      var Wi = W[i];
      
                      // Extend message
                      if (i < 16) {
                          var Wih = Wi.high = M[offset + i * 2]     | 0;
                          var Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
                      } else {
                          // Gamma0
                          var gamma0x  = W[i - 15];
                          var gamma0xh = gamma0x.high;
                          var gamma0xl = gamma0x.low;
                          var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
                          var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));
      
                          // Gamma1
                          var gamma1x  = W[i - 2];
                          var gamma1xh = gamma1x.high;
                          var gamma1xl = gamma1x.low;
                          var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
                          var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));
      
                          // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
                          var Wi7  = W[i - 7];
                          var Wi7h = Wi7.high;
                          var Wi7l = Wi7.low;
      
                          var Wi16  = W[i - 16];
                          var Wi16h = Wi16.high;
                          var Wi16l = Wi16.low;
      
                          var Wil = gamma0l + Wi7l;
                          var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
                          var Wil = Wil + gamma1l;
                          var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
                          var Wil = Wil + Wi16l;
                          var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);
      
                          Wi.high = Wih;
                          Wi.low  = Wil;
                      }
      
                      var chh  = (eh & fh) ^ (~eh & gh);
                      var chl  = (el & fl) ^ (~el & gl);
                      var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
                      var majl = (al & bl) ^ (al & cl) ^ (bl & cl);
      
                      var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
                      var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
                      var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
                      var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));
      
                      // t1 = h + sigma1 + ch + K[i] + W[i]
                      var Ki  = K[i];
                      var Kih = Ki.high;
                      var Kil = Ki.low;
      
                      var t1l = hl + sigma1l;
                      var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
                      var t1l = t1l + chl;
                      var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
                      var t1l = t1l + Kil;
                      var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
                      var t1l = t1l + Wil;
                      var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);
      
                      // t2 = sigma0 + maj
                      var t2l = sigma0l + majl;
                      var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);
      
                      // Update working variables
                      hh = gh;
                      hl = gl;
                      gh = fh;
                      gl = fl;
                      fh = eh;
                      fl = el;
                      el = (dl + t1l) | 0;
                      eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
                      dh = ch;
                      dl = cl;
                      ch = bh;
                      cl = bl;
                      bh = ah;
                      bl = al;
                      al = (t1l + t2l) | 0;
                      ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
                  }
      
                  // Intermediate hash value
                  H0l = H0.low  = (H0l + al);
                  H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
                  H1l = H1.low  = (H1l + bl);
                  H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
                  H2l = H2.low  = (H2l + cl);
                  H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
                  H3l = H3.low  = (H3l + dl);
                  H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
                  H4l = H4.low  = (H4l + el);
                  H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
                  H5l = H5.low  = (H5l + fl);
                  H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
                  H6l = H6.low  = (H6l + gl);
                  H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
                  H7l = H7.low  = (H7l + hl);
                  H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
              },
      
              _doFinalize: function () {
                  // Shortcuts
                  var data = this._data;
                  var dataWords = data.words;
      
                  var nBitsTotal = this._nDataBytes * 8;
                  var nBitsLeft = data.sigBytes * 8;
      
                  // Add padding
                  dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
                  dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
                  dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
                  data.sigBytes = dataWords.length * 4;
      
                  // Hash final blocks
                  this._process();
      
                  // Convert hash to 32-bit word array before returning
                  var hash = this._hash.toX32();
      
                  // Return final computed hash
                  return hash;
              },
      
              clone: function () {
                  var clone = Hasher.clone.call(this);
                  clone._hash = this._hash.clone();
      
                  return clone;
              },
      
              blockSize: 1024/32
          });
      
          /**
           * Shortcut function to the hasher's object interface.
           *
           * @param {WordArray|string} message The message to hash.
           *
           * @return {WordArray} The hash.
           *
           * @static
           *
           * @example
           *
           *     var hash = CryptoJS.SHA512('message');
           *     var hash = CryptoJS.SHA512(wordArray);
           */
          C.SHA512 = Hasher._createHelper(SHA512);
      
          /**
           * Shortcut function to the HMAC's object interface.
           *
           * @param {WordArray|string} message The message to hash.
           * @param {WordArray|string} key The secret key.
           *
           * @return {WordArray} The HMAC.
           *
           * @static
           *
           * @example
           *
           *     var hmac = CryptoJS.HmacSHA512(message, key);
           */
          C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      }());
      
      /*
      CryptoJS v3.1.2
      code.google.com/p/crypto-js
      (c) 2009-2013 by Jeff Mott. All rights reserved.
      code.google.com/p/crypto-js/wiki/License
      */
      (function (undefined) {
          // Shortcuts
          var C = CryptoJS;
          var C_lib = C.lib;
          var CipherParams = C_lib.CipherParams;
          var C_enc = C.enc;
          var Hex = C_enc.Hex;
          var C_format = C.format;
      
          var HexFormatter = C_format.Hex = {
              /**
               * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
               *
               * @param {CipherParams} cipherParams The cipher params object.
               *
               * @return {string} The hexadecimally encoded string.
               *
               * @static
               *
               * @example
               *
               *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
               */
              stringify: function (cipherParams) {
                  return cipherParams.ciphertext.toString(Hex);
              },
      
              /**
               * Converts a hexadecimally encoded ciphertext string to a cipher params object.
               *
               * @param {string} input The hexadecimally encoded string.
               *
               * @return {CipherParams} The cipher params object.
               *
               * @static
               *
               * @example
               *
               *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
               */
              parse: function (input) {
                  var ciphertext = Hex.parse(input);
                  return CipherParams.create({ ciphertext: ciphertext });
              }
          };
      }());
      
      /*
      CryptoJS v3.1.2
      code.google.com/p/crypto-js
      (c) 2009-2013 by Jeff Mott. All rights reserved.
      code.google.com/p/crypto-js/wiki/License
      */
      (function () {
          // Shortcuts
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var C_enc = C.enc;
      
          /**
           * Base64 encoding strategy.
           */
          var Base64 = C_enc.Base64 = {
              /**
               * Converts a word array to a Base64 string.
               *
               * @param {WordArray} wordArray The word array.
               *
               * @return {string} The Base64 string.
               *
               * @static
               *
               * @example
               *
               *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
               */
              stringify: function (wordArray) {
                  // Shortcuts
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
                  var map = this._map;
      
                  // Clamp excess bits
                  wordArray.clamp();
      
                  // Convert
                  var base64Chars = [];
                  for (var i = 0; i < sigBytes; i += 3) {
                      var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
                      var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
                      var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;
      
                      var triplet = (byte1 << 16) | (byte2 << 8) | byte3;
      
                      for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
                          base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                      }
                  }
      
                  // Add padding
                  var paddingChar = map.charAt(64);
                  if (paddingChar) {
                      while (base64Chars.length % 4) {
                          base64Chars.push(paddingChar);
                      }
                  }
      
                  return base64Chars.join('');
              },
      
              /**
               * Converts a Base64 string to a word array.
               *
               * @param {string} base64Str The Base64 string.
               *
               * @return {WordArray} The word array.
               *
               * @static
               *
               * @example
               *
               *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
               */
              parse: function (base64Str) {
                  // Shortcuts
                  var base64StrLength = base64Str.length;
                  var map = this._map;
      
                  // Ignore padding
                  var paddingChar = map.charAt(64);
                  if (paddingChar) {
                      var paddingIndex = base64Str.indexOf(paddingChar);
                      if (paddingIndex != -1) {
                          base64StrLength = paddingIndex;
                      }
                  }
      
                  // Convert
                  var words = [];
                  var nBytes = 0;
                  for (var i = 0; i < base64StrLength; i++) {
                      if (i % 4) {
                          var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);
                          var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);
                          words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
                          nBytes++;
                      }
                  }
      
                  return WordArray.create(words, nBytes);
              },
      
              _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
          };
      }());
      
      /*
      CryptoJS v3.1.2
      code.google.com/p/crypto-js
      (c) 2009-2013 by Jeff Mott. All rights reserved.
      code.google.com/p/crypto-js/wiki/License
      */
      /**
       * Counter block mode.
       */
      CryptoJS.mode.CTR = (function () {
          var CTR = CryptoJS.lib.BlockCipherMode.extend();
      
          var Encryptor = CTR.Encryptor = CTR.extend({
              processBlock: function (words, offset) {
                  // Shortcuts
                  var cipher = this._cipher
                  var blockSize = cipher.blockSize;
                  var iv = this._iv;
                  var counter = this._counter;
      
                  // Generate keystream
                  if (iv) {
                      counter = this._counter = iv.slice(0);
      
                      // Remove IV for subsequent blocks
                      this._iv = undefined;
                  }
                  var keystream = counter.slice(0);
                  cipher.encryptBlock(keystream, 0);
      
                  // Increment counter
                  counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0
      
                  // Encrypt
                  for (var i = 0; i < blockSize; i++) {
                      words[offset + i] ^= keystream[i];
                  }
              }
          });
      
          CTR.Decryptor = Encryptor;
      
          return CTR;
      }());
      
      /*
      CryptoJS v3.1.2
      code.google.com/p/crypto-js
      (c) 2009-2013 by Jeff Mott. All rights reserved.
      code.google.com/p/crypto-js/wiki/License
      */
      /**
       * A noop padding strategy.
       */
      CryptoJS.pad.NoPadding = {
          pad: function () {
          },
      
          unpad: function () {
          }
      };
      
      // Copyright (c) 2005  Tom Wu
      // All Rights Reserved.
      // See "LICENSE" for details.
      
      // Basic JavaScript BN library - subset useful for RSA encryption.
      
      // Bits per digit
      var dbits;
      
      // JavaScript engine analysis
      var canary = 0xdeadbeefcafe;
      var j_lm = ((canary&0xffffff)==0xefcafe);
      
      // (public) Constructor
      function BigInteger(a,b,c) {
        if(a != null)
          if("number" == typeof a) this.fromNumber(a,b,c);
          else if(b == null && "string" != typeof a) this.fromString(a,256);
          else this.fromString(a,b);
      }
      
      // return new, unset BigInteger
      function nbi() { return new BigInteger(null); }
      
      // am: Compute w_j += (x*this_i), propagate carries,
      // c is initial carry, returns final carry.
      // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
      // We need to select the fastest one that works in this environment.
      
      // am1: use a single mult and divide to get the high bits,
      // max digit bits should be 26 because
      // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
      function am1(i,x,w,j,c,n) {
        while(--n >= 0) {
          var v = x*this[i++]+w[j]+c;
          c = Math.floor(v/0x4000000);
          w[j++] = v&0x3ffffff;
        }
        return c;
      }
      // am2 avoids a big mult-and-extract completely.
      // Max digit bits should be <= 30 because we do bitwise ops
      // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
      function am2(i,x,w,j,c,n) {
        var xl = x&0x7fff, xh = x>>15;
        while(--n >= 0) {
          var l = this[i]&0x7fff;
          var h = this[i++]>>15;
          var m = xh*l+h*xl;
          l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
          c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
          w[j++] = l&0x3fffffff;
        }
        return c;
      }
      // Alternately, set max digit bits to 28 since some
      // browsers slow down when dealing with 32-bit numbers.
      function am3(i,x,w,j,c,n) {
        var xl = x&0x3fff, xh = x>>14;
        while(--n >= 0) {
          var l = this[i]&0x3fff;
          var h = this[i++]>>14;
          var m = xh*l+h*xl;
          l = xl*l+((m&0x3fff)<<14)+w[j]+c;
          c = (l>>28)+(m>>14)+xh*h;
          w[j++] = l&0xfffffff;
        }
        return c;
      }
      if(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
        BigInteger.prototype.am = am2;
        dbits = 30;
      }
      else if(j_lm && (navigator.appName != "Netscape")) {
        BigInteger.prototype.am = am1;
        dbits = 26;
      }
      else { // Mozilla/Netscape seems to prefer am3
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = ((1<<dbits)-1);
      BigInteger.prototype.DV = (1<<dbits);
      
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2,BI_FP);
      BigInteger.prototype.F1 = BI_FP-dbits;
      BigInteger.prototype.F2 = 2*dbits-BI_FP;
      
      // Digit conversions
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr,vv;
      rr = "0".charCodeAt(0);
      for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
      rr = "a".charCodeAt(0);
      for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
      rr = "A".charCodeAt(0);
      for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
      
      function int2char(n) { return BI_RM.charAt(n); }
      function intAt(s,i) {
        var c = BI_RC[s.charCodeAt(i)];
        return (c==null)?-1:c;
      }
      
      // (protected) copy this to r
      function bnpCopyTo(r) {
        for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
        r.t = this.t;
        r.s = this.s;
      }
      
      // (protected) set from integer value x, -DV <= x < DV
      function bnpFromInt(x) {
        this.t = 1;
        this.s = (x<0)?-1:0;
        if(x > 0) this[0] = x;
        else if(x < -1) this[0] = x+this.DV;
        else this.t = 0;
      }
      
      // return bigint initialized to value
      function nbv(i) { var r = nbi(); r.fromInt(i); return r; }
      
      // (protected) set from string and radix
      function bnpFromString(s,b) {
        var k;
        if(b == 16) k = 4;
        else if(b == 8) k = 3;
        else if(b == 256) k = 8; // byte array
        else if(b == 2) k = 1;
        else if(b == 32) k = 5;
        else if(b == 4) k = 2;
        else { this.fromRadix(s,b); return; }
        this.t = 0;
        this.s = 0;
        var i = s.length, mi = false, sh = 0;
        while(--i >= 0) {
          var x = (k==8)?s[i]&0xff:intAt(s,i);
          if(x < 0) {
            if(s.charAt(i) == "-") mi = true;
            continue;
          }
          mi = false;
          if(sh == 0)
            this[this.t++] = x;
          else if(sh+k > this.DB) {
            this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
            this[this.t++] = (x>>(this.DB-sh));
          }
          else
            this[this.t-1] |= x<<sh;
          sh += k;
          if(sh >= this.DB) sh -= this.DB;
        }
        if(k == 8 && (s[0]&0x80) != 0) {
          this.s = -1;
          if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
        }
        this.clamp();
        if(mi) BigInteger.ZERO.subTo(this,this);
      }
      
      // (protected) clamp off excess high words
      function bnpClamp() {
        var c = this.s&this.DM;
        while(this.t > 0 && this[this.t-1] == c) --this.t;
      }
      
      // (public) return string representation in given radix
      function bnToString(b) {
        if(this.s < 0) return "-"+this.negate().toString(b);
        var k;
        if(b == 16) k = 4;
        else if(b == 8) k = 3;
        else if(b == 2) k = 1;
        else if(b == 32) k = 5;
        else if(b == 4) k = 2;
        else return this.toRadix(b);
        var km = (1<<k)-1, d, m = false, r = "", i = this.t;
        var p = this.DB-(i*this.DB)%k;
        if(i-- > 0) {
          if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
          while(i >= 0) {
            if(p < k) {
              d = (this[i]&((1<<p)-1))<<(k-p);
              d |= this[--i]>>(p+=this.DB-k);
            }
            else {
              d = (this[i]>>(p-=k))&km;
              if(p <= 0) { p += this.DB; --i; }
            }
            if(d > 0) m = true;
            if(m) r += int2char(d);
          }
        }
        return m?r:"0";
      }
      
      // (public) -this
      function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }
      
      // (public) |this|
      function bnAbs() { return (this.s<0)?this.negate():this; }
      
      // (public) return + if this > a, - if this < a, 0 if equal
      function bnCompareTo(a) {
        var r = this.s-a.s;
        if(r != 0) return r;
        var i = this.t;
        r = i-a.t;
        if(r != 0) return (this.s<0)?-r:r;
        while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
        return 0;
      }
      
      // returns bit length of the integer x
      function nbits(x) {
        var r = 1, t;
        if((t=x>>>16) != 0) { x = t; r += 16; }
        if((t=x>>8) != 0) { x = t; r += 8; }
        if((t=x>>4) != 0) { x = t; r += 4; }
        if((t=x>>2) != 0) { x = t; r += 2; }
        if((t=x>>1) != 0) { x = t; r += 1; }
        return r;
      }
      
      // (public) return the number of bits in "this"
      function bnBitLength() {
        if(this.t <= 0) return 0;
        return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
      }
      
      // (protected) r = this << n*DB
      function bnpDLShiftTo(n,r) {
        var i;
        for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
        for(i = n-1; i >= 0; --i) r[i] = 0;
        r.t = this.t+n;
        r.s = this.s;
      }
      
      // (protected) r = this >> n*DB
      function bnpDRShiftTo(n,r) {
        for(var i = n; i < this.t; ++i) r[i-n] = this[i];
        r.t = Math.max(this.t-n,0);
        r.s = this.s;
      }
      
      // (protected) r = this << n
      function bnpLShiftTo(n,r) {
        var bs = n%this.DB;
        var cbs = this.DB-bs;
        var bm = (1<<cbs)-1;
        var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
        for(i = this.t-1; i >= 0; --i) {
          r[i+ds+1] = (this[i]>>cbs)|c;
          c = (this[i]&bm)<<bs;
        }
        for(i = ds-1; i >= 0; --i) r[i] = 0;
        r[ds] = c;
        r.t = this.t+ds+1;
        r.s = this.s;
        r.clamp();
      }
      
      // (protected) r = this >> n
      function bnpRShiftTo(n,r) {
        r.s = this.s;
        var ds = Math.floor(n/this.DB);
        if(ds >= this.t) { r.t = 0; return; }
        var bs = n%this.DB;
        var cbs = this.DB-bs;
        var bm = (1<<bs)-1;
        r[0] = this[ds]>>bs;
        for(var i = ds+1; i < this.t; ++i) {
          r[i-ds-1] |= (this[i]&bm)<<cbs;
          r[i-ds] = this[i]>>bs;
        }
        if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
        r.t = this.t-ds;
        r.clamp();
      }
      
      // (protected) r = this - a
      function bnpSubTo(a,r) {
        var i = 0, c = 0, m = Math.min(a.t,this.t);
        while(i < m) {
          c += this[i]-a[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        if(a.t < this.t) {
          c -= a.s;
          while(i < this.t) {
            c += this[i];
            r[i++] = c&this.DM;
            c >>= this.DB;
          }
          c += this.s;
        }
        else {
          c += this.s;
          while(i < a.t) {
            c -= a[i];
            r[i++] = c&this.DM;
            c >>= this.DB;
          }
          c -= a.s;
        }
        r.s = (c<0)?-1:0;
        if(c < -1) r[i++] = this.DV+c;
        else if(c > 0) r[i++] = c;
        r.t = i;
        r.clamp();
      }
      
      // (protected) r = this * a, r != this,a (HAC 14.12)
      // "this" should be the larger one if appropriate.
      function bnpMultiplyTo(a,r) {
        var x = this.abs(), y = a.abs();
        var i = x.t;
        r.t = i+y.t;
        while(--i >= 0) r[i] = 0;
        for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
        r.s = 0;
        r.clamp();
        if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
      }
      
      // (protected) r = this^2, r != this (HAC 14.16)
      function bnpSquareTo(r) {
        var x = this.abs();
        var i = r.t = 2*x.t;
        while(--i >= 0) r[i] = 0;
        for(i = 0; i < x.t-1; ++i) {
          var c = x.am(i,x[i],r,2*i,0,1);
          if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
            r[i+x.t] -= x.DV;
            r[i+x.t+1] = 1;
          }
        }
        if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
        r.s = 0;
        r.clamp();
      }
      
      // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
      // r != q, this != m.  q or r may be null.
      function bnpDivRemTo(m,q,r) {
        var pm = m.abs();
        if(pm.t <= 0) return;
        var pt = this.abs();
        if(pt.t < pm.t) {
          if(q != null) q.fromInt(0);
          if(r != null) this.copyTo(r);
          return;
        }
        if(r == null) r = nbi();
        var y = nbi(), ts = this.s, ms = m.s;
        var nsh = this.DB-nbits(pm[pm.t-1]);	// normalize modulus
        if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
        else { pm.copyTo(y); pt.copyTo(r); }
        var ys = y.t;
        var y0 = y[ys-1];
        if(y0 == 0) return;
        var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
        var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
        var i = r.t, j = i-ys, t = (q==null)?nbi():q;
        y.dlShiftTo(j,t);
        if(r.compareTo(t) >= 0) {
          r[r.t++] = 1;
          r.subTo(t,r);
        }
        BigInteger.ONE.dlShiftTo(ys,t);
        t.subTo(y,y);	// "negative" y so we can replace sub with am later
        while(y.t < ys) y[y.t++] = 0;
        while(--j >= 0) {
          // Estimate quotient digit
          var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
          if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {	// Try it out
            y.dlShiftTo(j,t);
            r.subTo(t,r);
            while(r[i] < --qd) r.subTo(t,r);
          }
        }
        if(q != null) {
          r.drShiftTo(ys,q);
          if(ts != ms) BigInteger.ZERO.subTo(q,q);
        }
        r.t = ys;
        r.clamp();
        if(nsh > 0) r.rShiftTo(nsh,r);	// Denormalize remainder
        if(ts < 0) BigInteger.ZERO.subTo(r,r);
      }
      
      // (public) this mod a
      function bnMod(a) {
        var r = nbi();
        this.abs().divRemTo(a,null,r);
        if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
        return r;
      }
      
      // Modular reduction using "classic" algorithm
      function Classic(m) { this.m = m; }
      function cConvert(x) {
        if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
        else return x;
      }
      function cRevert(x) { return x; }
      function cReduce(x) { x.divRemTo(this.m,null,x); }
      function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
      function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }
      
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      
      // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
      // justification:
      //         xy == 1 (mod m)
      //         xy =  1+km
      //   xy(2-xy) = (1+km)(1-km)
      // x[y(2-xy)] = 1-k^2m^2
      // x[y(2-xy)] == 1 (mod m^2)
      // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
      // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
      // JS multiply "overflows" differently from C/C++, so care is needed here.
      function bnpInvDigit() {
        if(this.t < 1) return 0;
        var x = this[0];
        if((x&1) == 0) return 0;
        var y = x&3;		// y == 1/x mod 2^2
        y = (y*(2-(x&0xf)*y))&0xf;	// y == 1/x mod 2^4
        y = (y*(2-(x&0xff)*y))&0xff;	// y == 1/x mod 2^8
        y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;	// y == 1/x mod 2^16
        // last step - calculate inverse mod DV directly;
        // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
        y = (y*(2-x*y%this.DV))%this.DV;		// y == 1/x mod 2^dbits
        // we really want the negative inverse, and -DV < y < DV
        return (y>0)?this.DV-y:-y;
      }
      
      // Montgomery reduction
      function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp&0x7fff;
        this.mph = this.mp>>15;
        this.um = (1<<(m.DB-15))-1;
        this.mt2 = 2*m.t;
      }
      
      // xR mod m
      function montConvert(x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t,r);
        r.divRemTo(this.m,null,r);
        if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
        return r;
      }
      
      // x/R mod m
      function montRevert(x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
      
      // x = x/R mod m (HAC 14.32)
      function montReduce(x) {
        while(x.t <= this.mt2)	// pad x so am has enough room later
          x[x.t++] = 0;
        for(var i = 0; i < this.m.t; ++i) {
          // faster way of calculating u0 = x[i]*mp mod DV
          var j = x[i]&0x7fff;
          var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
          // use am to combine the multiply-shift-add into one call
          j = i+this.m.t;
          x[j] += this.m.am(0,u0,x,i,0,this.m.t);
          // propagate carry
          while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
        }
        x.clamp();
        x.drShiftTo(this.m.t,x);
        if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
      }
      
      // r = "x^2/R mod m"; x != r
      function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }
      
      // r = "xy/R mod m"; x,y != r
      function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
      
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      
      // (protected) true iff this is even
      function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }
      
      // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
      function bnpExp(e,z) {
        if(e > 0xffffffff || e < 1) return BigInteger.ONE;
        var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
        g.copyTo(r);
        while(--i >= 0) {
          z.sqrTo(r,r2);
          if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
          else { var t = r; r = r2; r2 = t; }
        }
        return z.revert(r);
      }
      
      // (public) this^e % m, 0 <= e < 2^32
      function bnModPowInt(e,m) {
        var z;
        if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
        return this.exp(e,z);
      }
      
      // protected
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      
      // public
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      
      // "constants"
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      
      // Copyright (c) 2005-2009  Tom Wu
      // All Rights Reserved.
      // See "LICENSE" for details.
      
      // Extended JavaScript BN functions, required for RSA private ops.
      
      // Version 1.1: new BigInteger("0", 10) returns "proper" zero
      // Version 1.2: square() API, isProbablePrime fix
      
      // (public)
      function bnClone() { var r = nbi(); this.copyTo(r); return r; }
      
      // (public) return value as integer
      function bnIntValue() {
        if(this.s < 0) {
          if(this.t == 1) return this[0]-this.DV;
          else if(this.t == 0) return -1;
        }
        else if(this.t == 1) return this[0];
        else if(this.t == 0) return 0;
        // assumes 16 < DB < 32
        return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
      }
      
      // (public) return value as byte
      function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }
      
      // (public) return value as short (assumes DB>=16)
      function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }
      
      // (protected) return x s.t. r^x < DV
      function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }
      
      // (public) 0 if this == 0, 1 if this > 0
      function bnSigNum() {
        if(this.s < 0) return -1;
        else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
        else return 1;
      }
      
      // (protected) convert to radix string
      function bnpToRadix(b) {
        if(b == null) b = 10;
        if(this.signum() == 0 || b < 2 || b > 36) return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b,cs);
        var d = nbv(a), y = nbi(), z = nbi(), r = "";
        this.divRemTo(d,y,z);
        while(y.signum() > 0) {
          r = (a+z.intValue()).toString(b).substr(1) + r;
          y.divRemTo(d,y,z);
        }
        return z.intValue().toString(b) + r;
      }
      
      // (protected) convert from radix string
      function bnpFromRadix(s,b) {
        this.fromInt(0);
        if(b == null) b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
        for(var i = 0; i < s.length; ++i) {
          var x = intAt(s,i);
          if(x < 0) {
            if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
            continue;
          }
          w = b*w+x;
          if(++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w,0);
            j = 0;
            w = 0;
          }
        }
        if(j > 0) {
          this.dMultiply(Math.pow(b,j));
          this.dAddOffset(w,0);
        }
        if(mi) BigInteger.ZERO.subTo(this,this);
      }
      
      // (protected) alternate constructor
      function bnpFromNumber(a,b,c) {
        if("number" == typeof b) {
          // new BigInteger(int,int,RNG)
          if(a < 2) this.fromInt(1);
          else {
            this.fromNumber(a,c);
            if(!this.testBit(a-1))	// force MSB set
              this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
            if(this.isEven()) this.dAddOffset(1,0); // force odd
            while(!this.isProbablePrime(b)) {
              this.dAddOffset(2,0);
              if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
            }
          }
        }
        else {
          // new BigInteger(int,RNG)
          var x = new Array(), t = a&7;
          x.length = (a>>3)+1;
          b.nextBytes(x);
          if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
          this.fromString(x,256);
        }
      }
      
      // (public) convert to bigendian byte array
      function bnToByteArray() {
        var i = this.t, r = new Array();
        r[0] = this.s;
        var p = this.DB-(i*this.DB)%8, d, k = 0;
        if(i-- > 0) {
          if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)
            r[k++] = d|(this.s<<(this.DB-p));
          while(i >= 0) {
            if(p < 8) {
              d = (this[i]&((1<<p)-1))<<(8-p);
              d |= this[--i]>>(p+=this.DB-8);
            }
            else {
              d = (this[i]>>(p-=8))&0xff;
              if(p <= 0) { p += this.DB; --i; }
            }
            if((d&0x80) != 0) d |= -256;
            if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
            if(k > 0 || d != this.s) r[k++] = d;
          }
        }
        return r;
      }
      
      function bnEquals(a) { return(this.compareTo(a)==0); }
      function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
      function bnMax(a) { return(this.compareTo(a)>0)?this:a; }
      
      // (protected) r = this op a (bitwise)
      function bnpBitwiseTo(a,op,r) {
        var i, f, m = Math.min(a.t,this.t);
        for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);
        if(a.t < this.t) {
          f = a.s&this.DM;
          for(i = m; i < this.t; ++i) r[i] = op(this[i],f);
          r.t = this.t;
        }
        else {
          f = this.s&this.DM;
          for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);
          r.t = a.t;
        }
        r.s = op(this.s,a.s);
        r.clamp();
      }
      
      // (public) this & a
      function op_and(x,y) { return x&y; }
      function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }
      
      // (public) this | a
      function op_or(x,y) { return x|y; }
      function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }
      
      // (public) this ^ a
      function op_xor(x,y) { return x^y; }
      function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }
      
      // (public) this & ~a
      function op_andnot(x,y) { return x&~y; }
      function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }
      
      // (public) ~this
      function bnNot() {
        var r = nbi();
        for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];
        r.t = this.t;
        r.s = ~this.s;
        return r;
      }
      
      // (public) this << n
      function bnShiftLeft(n) {
        var r = nbi();
        if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
        return r;
      }
      
      // (public) this >> n
      function bnShiftRight(n) {
        var r = nbi();
        if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
        return r;
      }
      
      // return index of lowest 1-bit in x, x < 2^31
      function lbit(x) {
        if(x == 0) return -1;
        var r = 0;
        if((x&0xffff) == 0) { x >>= 16; r += 16; }
        if((x&0xff) == 0) { x >>= 8; r += 8; }
        if((x&0xf) == 0) { x >>= 4; r += 4; }
        if((x&3) == 0) { x >>= 2; r += 2; }
        if((x&1) == 0) ++r;
        return r;
      }
      
      // (public) returns index of lowest 1-bit (or -1 if none)
      function bnGetLowestSetBit() {
        for(var i = 0; i < this.t; ++i)
          if(this[i] != 0) return i*this.DB+lbit(this[i]);
        if(this.s < 0) return this.t*this.DB;
        return -1;
      }
      
      // return number of 1 bits in x
      function cbit(x) {
        var r = 0;
        while(x != 0) { x &= x-1; ++r; }
        return r;
      }
      
      // (public) return number of set bits
      function bnBitCount() {
        var r = 0, x = this.s&this.DM;
        for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);
        return r;
      }
      
      // (public) true iff nth bit is set
      function bnTestBit(n) {
        var j = Math.floor(n/this.DB);
        if(j >= this.t) return(this.s!=0);
        return((this[j]&(1<<(n%this.DB)))!=0);
      }
      
      // (protected) this op (1<<n)
      function bnpChangeBit(n,op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r,op,r);
        return r;
      }
      
      // (public) this | (1<<n)
      function bnSetBit(n) { return this.changeBit(n,op_or); }
      
      // (public) this & ~(1<<n)
      function bnClearBit(n) { return this.changeBit(n,op_andnot); }
      
      // (public) this ^ (1<<n)
      function bnFlipBit(n) { return this.changeBit(n,op_xor); }
      
      // (protected) r = this + a
      function bnpAddTo(a,r) {
        var i = 0, c = 0, m = Math.min(a.t,this.t);
        while(i < m) {
          c += this[i]+a[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        if(a.t < this.t) {
          c += a.s;
          while(i < this.t) {
            c += this[i];
            r[i++] = c&this.DM;
            c >>= this.DB;
          }
          c += this.s;
        }
        else {
          c += this.s;
          while(i < a.t) {
            c += a[i];
            r[i++] = c&this.DM;
            c >>= this.DB;
          }
          c += a.s;
        }
        r.s = (c<0)?-1:0;
        if(c > 0) r[i++] = c;
        else if(c < -1) r[i++] = this.DV+c;
        r.t = i;
        r.clamp();
      }
      
      // (public) this + a
      function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }
      
      // (public) this - a
      function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }
      
      // (public) this * a
      function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }
      
      // (public) this^2
      function bnSquare() { var r = nbi(); this.squareTo(r); return r; }
      
      // (public) this / a
      function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }
      
      // (public) this % a
      function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }
      
      // (public) [this/a,this%a]
      function bnDivideAndRemainder(a) {
        var q = nbi(), r = nbi();
        this.divRemTo(a,q,r);
        return new Array(q,r);
      }
      
      // (protected) this *= n, this >= 0, 1 < n < DV
      function bnpDMultiply(n) {
        this[this.t] = this.am(0,n-1,this,0,0,this.t);
        ++this.t;
        this.clamp();
      }
      
      // (protected) this += n << w words, this >= 0
      function bnpDAddOffset(n,w) {
        if(n == 0) return;
        while(this.t <= w) this[this.t++] = 0;
        this[w] += n;
        while(this[w] >= this.DV) {
          this[w] -= this.DV;
          if(++w >= this.t) this[this.t++] = 0;
          ++this[w];
        }
      }
      
      // A "null" reducer
      function NullExp() {}
      function nNop(x) { return x; }
      function nMulTo(x,y,r) { x.multiplyTo(y,r); }
      function nSqrTo(x,r) { x.squareTo(r); }
      
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      
      // (public) this^e
      function bnPow(e) { return this.exp(e,new NullExp()); }
      
      // (protected) r = lower n words of "this * a", a.t <= n
      // "this" should be the larger one if appropriate.
      function bnpMultiplyLowerTo(a,n,r) {
        var i = Math.min(this.t+a.t,n);
        r.s = 0; // assumes a,this >= 0
        r.t = i;
        while(i > 0) r[--i] = 0;
        var j;
        for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
        for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);
        r.clamp();
      }
      
      // (protected) r = "this * a" without lower n words, n > 0
      // "this" should be the larger one if appropriate.
      function bnpMultiplyUpperTo(a,n,r) {
        --n;
        var i = r.t = this.t+a.t-n;
        r.s = 0; // assumes a,this >= 0
        while(--i >= 0) r[i] = 0;
        for(i = Math.max(n-this.t,0); i < a.t; ++i)
          r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
        r.clamp();
        r.drShiftTo(1,r);
      }
      
      // Barrett modular reduction
      function Barrett(m) {
        // setup Barrett
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
        this.mu = this.r2.divide(m);
        this.m = m;
      }
      
      function barrettConvert(x) {
        if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
        else if(x.compareTo(this.m) < 0) return x;
        else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
      }
      
      function barrettRevert(x) { return x; }
      
      // x = x mod m (HAC 14.42)
      function barrettReduce(x) {
        x.drShiftTo(this.m.t-1,this.r2);
        if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
        this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
        this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
        while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
        x.subTo(this.r2,x);
        while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
      }
      
      // r = x^2 mod m; x != r
      function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }
      
      // r = x*y mod m; x,y != r
      function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
      
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      
      // (public) this^e % m (HAC 14.85)
      function bnModPow(e,m) {
        var i = e.bitLength(), k, r = nbv(1), z;
        if(i <= 0) return r;
        else if(i < 18) k = 1;
        else if(i < 48) k = 3;
        else if(i < 144) k = 4;
        else if(i < 768) k = 5;
        else k = 6;
        if(i < 8)
          z = new Classic(m);
        else if(m.isEven())
          z = new Barrett(m);
        else
          z = new Montgomery(m);
      
        // precomputation
        var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
        g[1] = z.convert(this);
        if(k > 1) {
          var g2 = nbi();
          z.sqrTo(g[1],g2);
          while(n <= km) {
            g[n] = nbi();
            z.mulTo(g2,g[n-2],g[n]);
            n += 2;
          }
        }
      
        var j = e.t-1, w, is1 = true, r2 = nbi(), t;
        i = nbits(e[j])-1;
        while(j >= 0) {
          if(i >= k1) w = (e[j]>>(i-k1))&km;
          else {
            w = (e[j]&((1<<(i+1))-1))<<(k1-i);
            if(j > 0) w |= e[j-1]>>(this.DB+i-k1);
          }
      
          n = k;
          while((w&1) == 0) { w >>= 1; --n; }
          if((i -= n) < 0) { i += this.DB; --j; }
          if(is1) {	// ret == 1, don't bother squaring or multiplying it
            g[w].copyTo(r);
            is1 = false;
          }
          else {
            while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
            if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
            z.mulTo(r2,g[w],r);
          }
      
          while(j >= 0 && (e[j]&(1<<i)) == 0) {
            z.sqrTo(r,r2); t = r; r = r2; r2 = t;
            if(--i < 0) { i = this.DB-1; --j; }
          }
        }
        return z.revert(r);
      }
      
      // (public) gcd(this,a) (HAC 14.54)
      function bnGCD(a) {
        var x = (this.s<0)?this.negate():this.clone();
        var y = (a.s<0)?a.negate():a.clone();
        if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
        var i = x.getLowestSetBit(), g = y.getLowestSetBit();
        if(g < 0) return x;
        if(i < g) g = i;
        if(g > 0) {
          x.rShiftTo(g,x);
          y.rShiftTo(g,y);
        }
        while(x.signum() > 0) {
          if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
          if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
          if(x.compareTo(y) >= 0) {
            x.subTo(y,x);
            x.rShiftTo(1,x);
          }
          else {
            y.subTo(x,y);
            y.rShiftTo(1,y);
          }
        }
        if(g > 0) y.lShiftTo(g,y);
        return y;
      }
      
      // (protected) this % n, n < 2^26
      function bnpModInt(n) {
        if(n <= 0) return 0;
        var d = this.DV%n, r = (this.s<0)?n-1:0;
        if(this.t > 0)
          if(d == 0) r = this[0]%n;
          else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;
        return r;
      }
      
      // (public) 1/this % m (HAC 14.61)
      function bnModInverse(m) {
        var ac = m.isEven();
        if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
        var u = m.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while(u.signum() != 0) {
          while(u.isEven()) {
            u.rShiftTo(1,u);
            if(ac) {
              if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
              a.rShiftTo(1,a);
            }
            else if(!b.isEven()) b.subTo(m,b);
            b.rShiftTo(1,b);
          }
          while(v.isEven()) {
            v.rShiftTo(1,v);
            if(ac) {
              if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
              c.rShiftTo(1,c);
            }
            else if(!d.isEven()) d.subTo(m,d);
            d.rShiftTo(1,d);
          }
          if(u.compareTo(v) >= 0) {
            u.subTo(v,u);
            if(ac) a.subTo(c,a);
            b.subTo(d,b);
          }
          else {
            v.subTo(u,v);
            if(ac) c.subTo(a,c);
            d.subTo(b,d);
          }
        }
        if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
        if(d.compareTo(m) >= 0) return d.subtract(m);
        if(d.signum() < 0) d.addTo(m,d); else return d;
        if(d.signum() < 0) return d.add(m); else return d;
      }
      
      var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
      var lplim = (1<<26)/lowprimes[lowprimes.length-1];
      
      // (public) test primality with certainty >= 1-.5^t
      function bnIsProbablePrime(t) {
        var i, x = this.abs();
        if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {
          for(i = 0; i < lowprimes.length; ++i)
            if(x[0] == lowprimes[i]) return true;
          return false;
        }
        if(x.isEven()) return false;
        i = 1;
        while(i < lowprimes.length) {
          var m = lowprimes[i], j = i+1;
          while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
          m = x.modInt(m);
          while(i < j) if(m%lowprimes[i++] == 0) return false;
        }
        return x.millerRabin(t);
      }
      
      // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
      function bnpMillerRabin(t) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if(k <= 0) return false;
        var r = n1.shiftRight(k);
        t = (t+1)>>1;
        if(t > lowprimes.length) t = lowprimes.length;
        var a = nbi();
        for(var i = 0; i < t; ++i) {
          //Pick bases at random, instead of starting at 2
          a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
          var y = a.modPow(r,this);
          if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while(j++ < k && y.compareTo(n1) != 0) {
              y = y.modPowInt(2,this);
              if(y.compareTo(BigInteger.ONE) == 0) return false;
            }
            if(y.compareTo(n1) != 0) return false;
          }
        }
        return true;
      }
      
      // protected
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      
      // public
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
      
      // JSBN-specific extension
      BigInteger.prototype.square = bnSquare;
      
      // BigInteger interfaces not implemented in jsbn:
      
      // BigInteger(int signum, byte[] magnitude)
      // double doubleValue()
      // float floatValue()
      // int hashCode()
      // long longValue()
      // static BigInteger valueOf(long val)
      
      // prng4.js - uses Arcfour as a PRNG
      
      function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = new Array();
      }
      
      // Initialize arcfour context from key, an array of ints, each from [0..255]
      function ARC4init(key) {
        var i, j, t;
        for(i = 0; i < 256; ++i)
          this.S[i] = i;
        j = 0;
        for(i = 0; i < 256; ++i) {
          j = (j + this.S[i] + key[i % key.length]) & 255;
          t = this.S[i];
          this.S[i] = this.S[j];
          this.S[j] = t;
        }
        this.i = 0;
        this.j = 0;
      }
      
      function ARC4next() {
        var t;
        this.i = (this.i + 1) & 255;
        this.j = (this.j + this.S[this.i]) & 255;
        t = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t;
        return this.S[(t + this.S[this.i]) & 255];
      }
      
      Arcfour.prototype.init = ARC4init;
      Arcfour.prototype.next = ARC4next;
      
      // Plug in your RNG constructor here
      function prng_newstate() {
        return new Arcfour();
      }
      
      // Pool size must be a multiple of 4 and greater than 32.
      // An array of bytes the size of the pool will be passed to init()
      var rng_psize = 256;
      
      // Random number generator - requires a PRNG backend, e.g. prng4.js
      
      // For best results, put code like
      // <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>
      // in your main HTML document.
      
      var rng_state;
      var rng_pool;
      var rng_pptr;
      
      // Mix in a 32-bit integer into the pool
      function rng_seed_int(x) {
        rng_pool[rng_pptr++] ^= x & 255;
        rng_pool[rng_pptr++] ^= (x >> 8) & 255;
        rng_pool[rng_pptr++] ^= (x >> 16) & 255;
        rng_pool[rng_pptr++] ^= (x >> 24) & 255;
        if(rng_pptr >= rng_psize) rng_pptr -= rng_psize;
      }
      
      // Mix in the current time (w/milliseconds) into the pool
      function rng_seed_time() {
        rng_seed_int(new Date().getTime());
      }
      
      // Initialize the pool with junk if needed.
      if(rng_pool == null) {
        rng_pool = new Array();
        rng_pptr = 0;
        var t;
        if(window.crypto && window.crypto.getRandomValues) {
          // Use webcrypto if available
          var ua = new Uint8Array(32);
          window.crypto.getRandomValues(ua);
          for(t = 0; t < 32; ++t)
            rng_pool[rng_pptr++] = ua[t];
        }
        if(navigator.appName == "Netscape" && navigator.appVersion < "5" && window.crypto) {
          // Extract entropy (256 bits) from NS4 RNG if available
          var z = window.crypto.random(32);
          for(t = 0; t < z.length; ++t)
            rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
        }  
        while(rng_pptr < rng_psize) {  // extract some randomness from Math.random()
          t = Math.floor(65536 * Math.random());
          rng_pool[rng_pptr++] = t >>> 8;
          rng_pool[rng_pptr++] = t & 255;
        }
        rng_pptr = 0;
        rng_seed_time();
        //rng_seed_int(window.screenX);
        //rng_seed_int(window.screenY);
      }
      
      function rng_get_byte() {
        if(rng_state == null) {
          rng_seed_time();
          rng_state = prng_newstate();
          rng_state.init(rng_pool);
          for(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
            rng_pool[rng_pptr] = 0;
          rng_pptr = 0;
          //rng_pool = null;
        }
        // TODO: allow reseeding after first request
        return rng_state.next();
      }
      
      function rng_get_bytes(ba) {
        var i;
        for(i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
      }
      
      function SecureRandom() {}
      
      SecureRandom.prototype.nextBytes = rng_get_bytes;
      
      // Depends on jsbn.js and rng.js
      
      // Version 1.1: support utf-8 encoding in pkcs1pad2
      
      // convert a (hex) string to a bignum object
      function parseBigInt(str,r) {
        return new BigInteger(str,r);
      }
      
      function linebrk(s,n) {
        var ret = "";
        var i = 0;
        while(i + n < s.length) {
          ret += s.substring(i,i+n) + "\n";
          i += n;
        }
        return ret + s.substring(i,s.length);
      }
      
      function byte2Hex(b) {
        if(b < 0x10)
          return "0" + b.toString(16);
        else
          return b.toString(16);
      }
      
      // PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint
      // function pkcs1pad2(s,n) {
      //   if(n < s.length + 11) { // TODO: fix for utf-8
      //     alert("Message too long for RSA");
      //     return null;
      //   }
      //   var ba = new Array();
      //   var i = s.length - 1;
      //   while(i >= 0 && n > 0) {
      //     var c = s.charCodeAt(i--);
      //     if(c < 128) { // encode using utf-8
      //       ba[--n] = c;
      //     }
      //     else if((c > 127) && (c < 2048)) {
      //       ba[--n] = (c & 63) | 128;
      //       ba[--n] = (c >> 6) | 192;
      //     }
      //     else {
      //       ba[--n] = (c & 63) | 128;
      //       ba[--n] = ((c >> 6) & 63) | 128;
      //       ba[--n] = (c >> 12) | 224;
      //     }
      //   }
      //   ba[--n] = 0;
      //   var rng = new SecureRandom();
      //   var x = new Array();
      //   while(n > 2) { // random non-zero pad
      //     x[0] = 0;
      //     while(x[0] == 0) rng.nextBytes(x);
      //     ba[--n] = x[0];
      //   }
      //   ba[--n] = 2;
      //   ba[--n] = 0;
      //   return new BigInteger(ba);
      // }
      function pkcs1pad2(bytes,n) { // updated 
        if(bytes.length > n - 11) {
          alert("Message too long for RSA");
          return null;
        }
        var ba = new Array();
        var i = bytes.length-1;
        while(i >= 0 && n > 0) {
          ba[--n] = bytes[i--];
        }
        ba[--n] = 0;
        var rng = new SecureRandom();
        var x = new Array();
        while(n > 2) { // random non-zero pad
          x[0] = 0;
          while(x[0] == 0) rng.nextBytes(x);
          ba[--n] = x[0];
        }
        ba[--n] = 2;
        ba[--n] = 0;
        return new BigInteger(ba);
      }
      
      // "empty" RSA key constructor
      function RSAKey() {
        this.n = null;
        this.e = 0;
        this.d = null;
        this.p = null;
        this.q = null;
        this.dmp1 = null;
        this.dmq1 = null;
        this.coeff = null;
      }
      
      // Set the public key fields N and e from hex strings
      function RSASetPublic(N,E) {
        if(N != null && E != null && N.length > 0 && E.length > 0) {
          this.n = parseBigInt(N,16);
          this.e = parseInt(E,16);
        }
        else
          alert("Invalid RSA public key");
      }
      
      // Perform raw public operation on "x": return x^e (mod n)
      function RSADoPublic(x) {
        return x.modPowInt(this.e, this.n);
      }
      
      // Return the PKCS#1 RSA encryption of "text" as an even-length hex string
      function RSAEncrypt(bytes) {
        var m = pkcs1pad2(bytes,(this.n.bitLength()+7)>>3);
        if(m == null) return null;
        var c = this.doPublic(m);
        if(c == null) return null;
        var h = c.toString(16);
        if((h.length & 1) == 0) return h; else return "0" + h;
      }
      
      // Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
      //function RSAEncryptB64(text) {
      //  var h = this.encrypt(text);
      //  if(h) return hex2b64(h); else return null;
      //}
      
      // protected
      RSAKey.prototype.doPublic = RSADoPublic;
      
      // public
      RSAKey.prototype.setPublic = RSASetPublic;
      RSAKey.prototype.encrypt = RSAEncrypt;
      //RSAKey.prototype.encrypt_b64 = RSAEncryptB64;
      
      // Basic Javascript Elliptic Curve implementation
      // Ported loosely from BouncyCastle's Java EC code
      // Only Fp curves implemented for now
      
      // Requires jsbn.js and jsbn2.js
      
      // ----------------
      // ECFieldElementFp
      
      // constructor
      function ECFieldElementFp(q,x) {
          this.x = x;
          // TODO if(x.compareTo(q) >= 0) error
          this.q = q;
      }
      
      function feFpEquals(other) {
          if(other == this) return true;
          return (this.q.equals(other.q) && this.x.equals(other.x));
      }
      
      function feFpToBigInteger() {
          return this.x;
      }
      
      function feFpNegate() {
          return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
      }
      
      function feFpAdd(b) {
          return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
      }
      
      function feFpSubtract(b) {
          return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
      }
      
      function feFpMultiply(b) {
          return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
      }
      
      function feFpSquare() {
          return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
      }
      
      function feFpDivide(b) {
          return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
      }
      
      ECFieldElementFp.prototype.equals = feFpEquals;
      ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
      ECFieldElementFp.prototype.negate = feFpNegate;
      ECFieldElementFp.prototype.add = feFpAdd;
      ECFieldElementFp.prototype.subtract = feFpSubtract;
      ECFieldElementFp.prototype.multiply = feFpMultiply;
      ECFieldElementFp.prototype.square = feFpSquare;
      ECFieldElementFp.prototype.divide = feFpDivide;
      
      // ----------------
      // ECPointFp
      
      // constructor
      function ECPointFp(curve,x,y,z) {
          this.curve = curve;
          this.x = x;
          this.y = y;
          // Projective coordinates: either zinv == null or z * zinv == 1
          // z and zinv are just BigIntegers, not fieldElements
          if(z == null) {
            this.z = BigInteger.ONE;
          }
          else {
            this.z = z;
          }
          this.zinv = null;
          //TODO: compression flag
      }
      
      function pointFpGetX() {
          if(this.zinv == null) {
            this.zinv = this.z.modInverse(this.curve.q);
          }
          var r = this.x.toBigInteger().multiply(this.zinv);
          this.curve.reduce(r);
          return this.curve.fromBigInteger(r);
      }
      
      function pointFpGetY() {
          if(this.zinv == null) {
            this.zinv = this.z.modInverse(this.curve.q);
          }
          var r = this.y.toBigInteger().multiply(this.zinv);
          this.curve.reduce(r);
          return this.curve.fromBigInteger(r);
      }
      
      function pointFpEquals(other) {
          if(other == this) return true;
          if(this.isInfinity()) return other.isInfinity();
          if(other.isInfinity()) return this.isInfinity();
          var u, v;
          // u = Y2 * Z1 - Y1 * Z2
          u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
          if(!u.equals(BigInteger.ZERO)) return false;
          // v = X2 * Z1 - X1 * Z2
          v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
          return v.equals(BigInteger.ZERO);
      }
      
      function pointFpIsInfinity() {
          if((this.x == null) && (this.y == null)) return true;
          return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
      }
      
      function pointFpNegate() {
          return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
      }
      
      function pointFpAdd(b) {
          if(this.isInfinity()) return b;
          if(b.isInfinity()) return this;
      
          // u = Y2 * Z1 - Y1 * Z2
          var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
          // v = X2 * Z1 - X1 * Z2
          var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);
      
          if(BigInteger.ZERO.equals(v)) {
              if(BigInteger.ZERO.equals(u)) {
                  return this.twice(); // this == b, so double
              }
      	return this.curve.getInfinity(); // this = -b, so infinity
          }
      
          var THREE = new BigInteger("3");
          var x1 = this.x.toBigInteger();
          var y1 = this.y.toBigInteger();
          var x2 = b.x.toBigInteger();
          var y2 = b.y.toBigInteger();
      
          var v2 = v.square();
          var v3 = v2.multiply(v);
          var x1v2 = x1.multiply(v2);
          var zu2 = u.square().multiply(this.z);
      
          // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)
          var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
          // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3
          var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
          // z3 = v^3 * z1 * z2
          var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);
      
          return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
      }
      
      function pointFpTwice() {
          if(this.isInfinity()) return this;
          if(this.y.toBigInteger().signum() == 0) return this.curve.getInfinity();
      
          // TODO: optimized handling of constants
          var THREE = new BigInteger("3");
          var x1 = this.x.toBigInteger();
          var y1 = this.y.toBigInteger();
      
          var y1z1 = y1.multiply(this.z);
          var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
          var a = this.curve.a.toBigInteger();
      
          // w = 3 * x1^2 + a * z1^2
          var w = x1.square().multiply(THREE);
          if(!BigInteger.ZERO.equals(a)) {
            w = w.add(this.z.square().multiply(a));
          }
          w = w.mod(this.curve.q);
          //this.curve.reduce(w);
          // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)
          var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
          // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3
          var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
          // z3 = 8 * (y1 * z1)^3
          var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);
      
          return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
      }
      
      // Simple NAF (Non-Adjacent Form) multiplication algorithm
      // TODO: modularize the multiplication algorithm
      function pointFpMultiply(k) {
          if(this.isInfinity()) return this;
          if(k.signum() == 0) return this.curve.getInfinity();
      
          var e = k;
          var h = e.multiply(new BigInteger("3"));
      
          var neg = this.negate();
          var R = this;
      
          var i;
          for(i = h.bitLength() - 2; i > 0; --i) {
      	R = R.twice();
      
      	var hBit = h.testBit(i);
      	var eBit = e.testBit(i);
      
      	if (hBit != eBit) {
      	    R = R.add(hBit ? this : neg);
      	}
          }
      
          return R;
      }
      
      // Compute this*j + x*k (simultaneous multiplication)
      function pointFpMultiplyTwo(j,x,k) {
        var i;
        if(j.bitLength() > k.bitLength())
          i = j.bitLength() - 1;
        else
          i = k.bitLength() - 1;
      
        var R = this.curve.getInfinity();
        var both = this.add(x);
        while(i >= 0) {
          R = R.twice();
          if(j.testBit(i)) {
            if(k.testBit(i)) {
              R = R.add(both);
            }
            else {
              R = R.add(this);
            }
          }
          else {
            if(k.testBit(i)) {
              R = R.add(x);
            }
          }
          --i;
        }
      
        return R;
      }
      
      ECPointFp.prototype.getX = pointFpGetX;
      ECPointFp.prototype.getY = pointFpGetY;
      ECPointFp.prototype.equals = pointFpEquals;
      ECPointFp.prototype.isInfinity = pointFpIsInfinity;
      ECPointFp.prototype.negate = pointFpNegate;
      ECPointFp.prototype.add = pointFpAdd;
      ECPointFp.prototype.twice = pointFpTwice;
      ECPointFp.prototype.multiply = pointFpMultiply;
      ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;
      
      // ----------------
      // ECCurveFp
      
      // constructor
      function ECCurveFp(q,a,b) {
          this.q = q;
          this.a = this.fromBigInteger(a);
          this.b = this.fromBigInteger(b);
          this.infinity = new ECPointFp(this, null, null);
          this.reducer = new Barrett(this.q);
      }
      
      function curveFpGetQ() {
          return this.q;
      }
      
      function curveFpGetA() {
          return this.a;
      }
      
      function curveFpGetB() {
          return this.b;
      }
      
      function curveFpEquals(other) {
          if(other == this) return true;
          return(this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b));
      }
      
      function curveFpGetInfinity() {
          return this.infinity;
      }
      
      function curveFpFromBigInteger(x) {
          return new ECFieldElementFp(this.q, x);
      }
      
      function curveReduce(x) {
          this.reducer.reduce(x);
      }
      
      // for now, work with hex strings because they're easier in JS
      function curveFpDecodePointHex(s) {
          switch(parseInt(s.substr(0,2), 16)) { // first byte
          case 0:
      	return this.infinity;
          case 2:
          case 3:
      	// point compression not supported yet
      	return null;
          case 4:
          case 6:
          case 7:
      	var len = (s.length - 2) / 2;
      	var xHex = s.substr(2, len);
      	var yHex = s.substr(len+2, len);
      
      	return new ECPointFp(this,
      			     this.fromBigInteger(new BigInteger(xHex, 16)),
      			     this.fromBigInteger(new BigInteger(yHex, 16)));
      
          default: // unsupported
      	return null;
          }
      }
      
      function curveFpEncodePointHex(p) {
      	if (p.isInfinity()) return "00";
      	var xHex = p.getX().toBigInteger().toString(16);
      	var yHex = p.getY().toBigInteger().toString(16);
      	var oLen = this.getQ().toString(16).length;
      	if ((oLen % 2) != 0) oLen++;
      	while (xHex.length < oLen) {
      		xHex = "0" + xHex;
      	}
      	while (yHex.length < oLen) {
      		yHex = "0" + yHex;
      	}
      	return "04" + xHex + yHex;
      }
      
      ECCurveFp.prototype.getQ = curveFpGetQ;
      ECCurveFp.prototype.getA = curveFpGetA;
      ECCurveFp.prototype.getB = curveFpGetB;
      ECCurveFp.prototype.equals = curveFpEquals;
      ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
      ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
      ECCurveFp.prototype.reduce = curveReduce;
      ECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;
      ECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;
      
      // Named EC curves
      
      // Requires ec.js, jsbn.js, and jsbn2.js
      
      // ----------------
      // X9ECParameters
      
      // constructor
      function X9ECParameters(curve,g,n,h) {
          this.curve = curve;
          this.g = g;
          this.n = n;
          this.h = h;
      }
      
      function x9getCurve() {
          return this.curve;
      }
      
      function x9getG() {
          return this.g;
      }
      
      function x9getN() {
          return this.n;
      }
      
      function x9getH() {
          return this.h;
      }
      
      X9ECParameters.prototype.getCurve = x9getCurve;
      X9ECParameters.prototype.getG = x9getG;
      X9ECParameters.prototype.getN = x9getN;
      X9ECParameters.prototype.getH = x9getH;
      
      // ----------------
      // SECNamedCurves
      
      function fromHex(s) { return new BigInteger(s, 16); }
      
      function secp128r1() {
          // p = 2^128 - 2^97 - 1
          var p = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");
          var a = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");
          var b = fromHex("E87579C11079F43DD824993C2CEE5ED3");
          //byte[] S = Hex.decode("000E0D4D696E6768756151750CC03A4473D03679");
          var n = fromHex("FFFFFFFE0000000075A30D1B9038A115");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04"
                      + "161FF7528B899B2D0C28607CA52C5B86"
      		+ "CF5AC8395BAFEB13C02DA292DDED7A83");
          return new X9ECParameters(curve, G, n, h);
      }
      
      function secp160k1() {
          // p = 2^160 - 2^32 - 2^14 - 2^12 - 2^9 - 2^8 - 2^7 - 2^3 - 2^2 - 1
          var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");
          var a = BigInteger.ZERO;
          var b = fromHex("7");
          //byte[] S = null;
          var n = fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04"
                      + "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB"
                      + "938CF935318FDCED6BC28286531733C3F03C4FEE");
          return new X9ECParameters(curve, G, n, h);
      }
      
      function secp160r1() {
          // p = 2^160 - 2^31 - 1
          var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");
          var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");
          var b = fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");
          //byte[] S = Hex.decode("1053CDE42C14D696E67687561517533BF3F83345");
          var n = fromHex("0100000000000000000001F4C8F927AED3CA752257");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04"
      		+ "4A96B5688EF573284664698968C38BB913CBFC82"
      		+ "23A628553168947D59DCC912042351377AC5FB32");
          return new X9ECParameters(curve, G, n, h);
      }
      
      function secp192k1() {
          // p = 2^192 - 2^32 - 2^12 - 2^8 - 2^7 - 2^6 - 2^3 - 1
          var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");
          var a = BigInteger.ZERO;
          var b = fromHex("3");
          //byte[] S = null;
          var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04"
                      + "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D"
                      + "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");
          return new X9ECParameters(curve, G, n, h);
      }
      
      function secp192r1() {
          // p = 2^192 - 2^64 - 1
          var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");
          var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");
          var b = fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");
          //byte[] S = Hex.decode("3045AE6FC8422F64ED579528D38120EAE12196D5");
          var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04"
                      + "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012"
                      + "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811");
          return new X9ECParameters(curve, G, n, h);
      }
      
      function secp224r1() {
          // p = 2^224 - 2^96 + 1
          var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");
          var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");
          var b = fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");
          //byte[] S = Hex.decode("BD71344799D5C7FCDC45B59FA3B9AB8F6A948BC5");
          var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04"
                      + "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21"
                      + "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");
          return new X9ECParameters(curve, G, n, h);
      }
      
      function secp256k1() {
          // p = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1
          var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F");
          var a = BigInteger.ZERO;
          var b = fromHex("7");
          //byte[] S = null;
          var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04"
                      + "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798"
                      + "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8");
          return new X9ECParameters(curve, G, n, h);
      }
      
      function secp256r1() {
          // p = 2^224 (2^32 - 1) + 2^192 + 2^96 - 1
          var p = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");
          var a = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");
          var b = fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");
          //byte[] S = Hex.decode("C49D360886E704936A6678E1139D26B7819F7E90");
          var n = fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");
          var h = BigInteger.ONE;
          var curve = new ECCurveFp(p, a, b);
          var G = curve.decodePointHex("04"
                      + "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296"
      		+ "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");
          return new X9ECParameters(curve, G, n, h);
      }
      
      // TODO: make this into a proper hashtable
      function getSECCurveByName(name) {
          if(name == "secp128r1") return secp128r1();
          if(name == "secp160k1") return secp160k1();
          if(name == "secp160r1") return secp160r1();
          if(name == "secp192k1") return secp192k1();
          if(name == "secp192r1") return secp192r1();
          if(name == "secp224r1") return secp224r1();
          if(name == "secp256k1") return secp256k1();
          if(name == "secp256r1") return secp256r1();
          return null;
      }
      
      /*
      CryptoJS v3.1.2
      code.google.com/p/crypto-js
      (c) 2009-2013 by Jeff Mott. All rights reserved.
      code.google.com/p/crypto-js/wiki/License
      */
      /**
       * CryptoJS core components.
       */
      var CryptoJS = CryptoJS || (function (Math, undefined) {
          /**
           * CryptoJS namespace.
           */
          var C = {};
      
          /**
           * Library namespace.
           */
          var C_lib = C.lib = {};
      
          /**
           * Base object for prototypal inheritance.
           */
          var Base = C_lib.Base = (function () {
              function F() {}
      
              return {
                  /**
                   * Creates a new object that inherits from this object.
                   *
                   * @param {Object} overrides Properties to copy into the new object.
                   *
                   * @return {Object} The new object.
                   *
                   * @static
                   *
                   * @example
                   *
                   *     var MyType = CryptoJS.lib.Base.extend({
                   *         field: 'value',
                   *
                   *         method: function () {
                   *         }
                   *     });
                   */
                  extend: function (overrides) {
                      // Spawn
                      F.prototype = this;
                      var subtype = new F();
      
                      // Augment
                      if (overrides) {
                          subtype.mixIn(overrides);
                      }
      
                      // Create default initializer
                      if (!subtype.hasOwnProperty('init')) {
                          subtype.init = function () {
                              subtype.$super.init.apply(this, arguments);
                          };
                      }
      
                      // Initializer's prototype is the subtype object
                      subtype.init.prototype = subtype;
      
                      // Reference supertype
                      subtype.$super = this;
      
                      return subtype;
                  },
      
                  /**
                   * Extends this object and runs the init method.
                   * Arguments to create() will be passed to init().
                   *
                   * @return {Object} The new object.
                   *
                   * @static
                   *
                   * @example
                   *
                   *     var instance = MyType.create();
                   */
                  create: function () {
                      var instance = this.extend();
                      instance.init.apply(instance, arguments);
      
                      return instance;
                  },
      
                  /**
                   * Initializes a newly created object.
                   * Override this method to add some logic when your objects are created.
                   *
                   * @example
                   *
                   *     var MyType = CryptoJS.lib.Base.extend({
                   *         init: function () {
                   *             // ...
                   *         }
                   *     });
                   */
                  init: function () {
                  },
      
                  /**
                   * Copies properties into this object.
                   *
                   * @param {Object} properties The properties to mix in.
                   *
                   * @example
                   *
                   *     MyType.mixIn({
                   *         field: 'value'
                   *     });
                   */
                  mixIn: function (properties) {
                      for (var propertyName in properties) {
                          if (properties.hasOwnProperty(propertyName)) {
                              this[propertyName] = properties[propertyName];
                          }
                      }
      
                      // IE won't copy toString using the loop above
                      if (properties.hasOwnProperty('toString')) {
                          this.toString = properties.toString;
                      }
                  },
      
                  /**
                   * Creates a copy of this object.
                   *
                   * @return {Object} The clone.
                   *
                   * @example
                   *
                   *     var clone = instance.clone();
                   */
                  clone: function () {
                      return this.init.prototype.extend(this);
                  }
              };
          }());
      
          /**
           * An array of 32-bit words.
           *
           * @property {Array} words The array of 32-bit words.
           * @property {number} sigBytes The number of significant bytes in this word array.
           */
          var WordArray = C_lib.WordArray = Base.extend({
              /**
               * Initializes a newly created word array.
               *
               * @param {Array} words (Optional) An array of 32-bit words.
               * @param {number} sigBytes (Optional) The number of significant bytes in the words.
               *
               * @example
               *
               *     var wordArray = CryptoJS.lib.WordArray.create();
               *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
               *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
               */
              init: function (words, sigBytes) {
                  words = this.words = words || [];
      
                  if (sigBytes != undefined) {
                      this.sigBytes = sigBytes;
                  } else {
                      this.sigBytes = words.length * 4;
                  }
              },
      
              /**
               * Converts this word array to a string.
               *
               * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
               *
               * @return {string} The stringified word array.
               *
               * @example
               *
               *     var string = wordArray + '';
               *     var string = wordArray.toString();
               *     var string = wordArray.toString(CryptoJS.enc.Utf8);
               */
              toString: function (encoder) {
                  return (encoder || Hex).stringify(this);
              },
      
              /**
               * Concatenates a word array to this word array.
               *
               * @param {WordArray} wordArray The word array to append.
               *
               * @return {WordArray} This word array.
               *
               * @example
               *
               *     wordArray1.concat(wordArray2);
               */
              concat: function (wordArray) {
                  // Shortcuts
                  var thisWords = this.words;
                  var thatWords = wordArray.words;
                  var thisSigBytes = this.sigBytes;
                  var thatSigBytes = wordArray.sigBytes;
      
                  // Clamp excess bits
                  this.clamp();
      
                  // Concat
                  if (thisSigBytes % 4) {
                      // Copy one byte at a time
                      for (var i = 0; i < thatSigBytes; i++) {
                          var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                          thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                      }
                  } else if (thatWords.length > 0xffff) {
                      // Copy one word at a time
                      for (var i = 0; i < thatSigBytes; i += 4) {
                          thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                      }
                  } else {
                      // Copy all words at once
                      thisWords.push.apply(thisWords, thatWords);
                  }
                  this.sigBytes += thatSigBytes;
      
                  // Chainable
                  return this;
              },
      
              /**
               * Removes insignificant bits.
               *
               * @example
               *
               *     wordArray.clamp();
               */
              clamp: function () {
                  // Shortcuts
                  var words = this.words;
                  var sigBytes = this.sigBytes;
      
                  // Clamp
                  words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
                  words.length = Math.ceil(sigBytes / 4);
              },
      
              /**
               * Creates a copy of this word array.
               *
               * @return {WordArray} The clone.
               *
               * @example
               *
               *     var clone = wordArray.clone();
               */
              clone: function () {
                  var clone = Base.clone.call(this);
                  clone.words = this.words.slice(0);
      
                  return clone;
              },
      
              /**
               * Creates a word array filled with random bytes.
               *
               * @param {number} nBytes The number of random bytes to generate.
               *
               * @return {WordArray} The random word array.
               *
               * @static
               *
               * @example
               *
               *     var wordArray = CryptoJS.lib.WordArray.random(16);
               */
              random: function (nBytes) {
                  var words = [];
                  for (var i = 0; i < nBytes; i += 4) {
                      words.push((Math.random() * 0x100000000) | 0);
                  }
      
                  return new WordArray.init(words, nBytes);
              }
          });
      
          /**
           * Encoder namespace.
           */
          var C_enc = C.enc = {};
      
          /**
           * Hex encoding strategy.
           */
          var Hex = C_enc.Hex = {
              /**
               * Converts a word array to a hex string.
               *
               * @param {WordArray} wordArray The word array.
               *
               * @return {string} The hex string.
               *
               * @static
               *
               * @example
               *
               *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
               */
              stringify: function (wordArray) {
                  // Shortcuts
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
      
                  // Convert
                  var hexChars = [];
                  for (var i = 0; i < sigBytes; i++) {
                      var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                      hexChars.push((bite >>> 4).toString(16));
                      hexChars.push((bite & 0x0f).toString(16));
                  }
      
                  return hexChars.join('');
              },
      
              /**
               * Converts a hex string to a word array.
               *
               * @param {string} hexStr The hex string.
               *
               * @return {WordArray} The word array.
               *
               * @static
               *
               * @example
               *
               *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
               */
              parse: function (hexStr) {
                  // Shortcut
                  var hexStrLength = hexStr.length;
      
                  // Convert
                  var words = [];
                  for (var i = 0; i < hexStrLength; i += 2) {
                      words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
                  }
      
                  return new WordArray.init(words, hexStrLength / 2);
              }
          };
      
          /**
           * Latin1 encoding strategy.
           */
          var Latin1 = C_enc.Latin1 = {
              /**
               * Converts a word array to a Latin1 string.
               *
               * @param {WordArray} wordArray The word array.
               *
               * @return {string} The Latin1 string.
               *
               * @static
               *
               * @example
               *
               *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
               */
              stringify: function (wordArray) {
                  // Shortcuts
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
      
                  // Convert
                  var latin1Chars = [];
                  for (var i = 0; i < sigBytes; i++) {
                      var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                      latin1Chars.push(String.fromCharCode(bite));
                  }
      
                  return latin1Chars.join('');
              },
      
              /**
               * Converts a Latin1 string to a word array.
               *
               * @param {string} latin1Str The Latin1 string.
               *
               * @return {WordArray} The word array.
               *
               * @static
               *
               * @example
               *
               *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
               */
              parse: function (latin1Str) {
                  // Shortcut
                  var latin1StrLength = latin1Str.length;
      
                  // Convert
                  var words = [];
                  for (var i = 0; i < latin1StrLength; i++) {
                      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
                  }
      
                  return new WordArray.init(words, latin1StrLength);
              }
          };
      
          /**
           * UTF-8 encoding strategy.
           */
          var Utf8 = C_enc.Utf8 = {
              /**
               * Converts a word array to a UTF-8 string.
               *
               * @param {WordArray} wordArray The word array.
               *
               * @return {string} The UTF-8 string.
               *
               * @static
               *
               * @example
               *
               *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
               */
              stringify: function (wordArray) {
                  try {
                      return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                  } catch (e) {
                      throw new Error('Malformed UTF-8 data');
                  }
              },
      
              /**
               * Converts a UTF-8 string to a word array.
               *
               * @param {string} utf8Str The UTF-8 string.
               *
               * @return {WordArray} The word array.
               *
               * @static
               *
               * @example
               *
               *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
               */
              parse: function (utf8Str) {
                  return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
              }
          };
      
          /**
           * Abstract buffered block algorithm template.
           *
           * The property blockSize must be implemented in a concrete subtype.
           *
           * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
           */
          var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
              /**
               * Resets this block algorithm's data buffer to its initial state.
               *
               * @example
               *
               *     bufferedBlockAlgorithm.reset();
               */
              reset: function () {
                  // Initial values
                  this._data = new WordArray.init();
                  this._nDataBytes = 0;
              },
      
              /**
               * Adds new data to this block algorithm's buffer.
               *
               * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
               *
               * @example
               *
               *     bufferedBlockAlgorithm._append('data');
               *     bufferedBlockAlgorithm._append(wordArray);
               */
              _append: function (data) {
                  // Convert string to WordArray, else assume WordArray already
                  if (typeof data == 'string') {
                      data = Utf8.parse(data);
                  }
      
                  // Append
                  this._data.concat(data);
                  this._nDataBytes += data.sigBytes;
              },
      
              /**
               * Processes available data blocks.
               *
               * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
               *
               * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
               *
               * @return {WordArray} The processed data.
               *
               * @example
               *
               *     var processedData = bufferedBlockAlgorithm._process();
               *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
               */
              _process: function (doFlush) {
                  // Shortcuts
                  var data = this._data;
                  var dataWords = data.words;
                  var dataSigBytes = data.sigBytes;
                  var blockSize = this.blockSize;
                  var blockSizeBytes = blockSize * 4;
      
                  // Count blocks ready
                  var nBlocksReady = dataSigBytes / blockSizeBytes;
                  if (doFlush) {
                      // Round up to include partial blocks
                      nBlocksReady = Math.ceil(nBlocksReady);
                  } else {
                      // Round down to include only full blocks,
                      // less the number of blocks that must remain in the buffer
                      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
                  }
      
                  // Count words ready
                  var nWordsReady = nBlocksReady * blockSize;
      
                  // Count bytes ready
                  var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
      
                  // Process blocks
                  if (nWordsReady) {
                      for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                          // Perform concrete-algorithm logic
                          this._doProcessBlock(dataWords, offset);
                      }
      
                      // Remove processed words
                      var processedWords = dataWords.splice(0, nWordsReady);
                      data.sigBytes -= nBytesReady;
                  }
      
                  // Return processed words
                  return new WordArray.init(processedWords, nBytesReady);
              },
      
              /**
               * Creates a copy of this object.
               *
               * @return {Object} The clone.
               *
               * @example
               *
               *     var clone = bufferedBlockAlgorithm.clone();
               */
              clone: function () {
                  var clone = Base.clone.call(this);
                  clone._data = this._data.clone();
      
                  return clone;
              },
      
              _minBufferSize: 0
          });
      
          /**
           * Abstract hasher template.
           *
           * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
           */
          var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
              /**
               * Configuration options.
               */
              cfg: Base.extend(),
      
              /**
               * Initializes a newly created hasher.
               *
               * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
               *
               * @example
               *
               *     var hasher = CryptoJS.algo.SHA256.create();
               */
              init: function (cfg) {
                  // Apply config defaults
                  this.cfg = this.cfg.extend(cfg);
      
                  // Set initial values
                  this.reset();
              },
      
              /**
               * Resets this hasher to its initial state.
               *
               * @example
               *
               *     hasher.reset();
               */
              reset: function () {
                  // Reset data buffer
                  BufferedBlockAlgorithm.reset.call(this);
      
                  // Perform concrete-hasher logic
                  this._doReset();
              },
      
              /**
               * Updates this hasher with a message.
               *
               * @param {WordArray|string} messageUpdate The message to append.
               *
               * @return {Hasher} This hasher.
               *
               * @example
               *
               *     hasher.update('message');
               *     hasher.update(wordArray);
               */
              update: function (messageUpdate) {
                  // Append
                  this._append(messageUpdate);
      
                  // Update the hash
                  this._process();
      
                  // Chainable
                  return this;
              },
      
              /**
               * Finalizes the hash computation.
               * Note that the finalize operation is effectively a destructive, read-once operation.
               *
               * @param {WordArray|string} messageUpdate (Optional) A final message update.
               *
               * @return {WordArray} The hash.
               *
               * @example
               *
               *     var hash = hasher.finalize();
               *     var hash = hasher.finalize('message');
               *     var hash = hasher.finalize(wordArray);
               */
              finalize: function (messageUpdate) {
                  // Final message update
                  if (messageUpdate) {
                      this._append(messageUpdate);
                  }
      
                  // Perform concrete-hasher logic
                  var hash = this._doFinalize();
      
                  return hash;
              },
      
              blockSize: 512/32,
      
              /**
               * Creates a shortcut function to a hasher's object interface.
               *
               * @param {Hasher} hasher The hasher to create a helper for.
               *
               * @return {Function} The shortcut function.
               *
               * @static
               *
               * @example
               *
               *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
               */
              _createHelper: function (hasher) {
                  return function (message, cfg) {
                      return new hasher.init(cfg).finalize(message);
                  };
              },
      
              /**
               * Creates a shortcut function to the HMAC's object interface.
               *
               * @param {Hasher} hasher The hasher to use in this HMAC helper.
               *
               * @return {Function} The shortcut function.
               *
               * @static
               *
               * @example
               *
               *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
               */
              _createHmacHelper: function (hasher) {
                  return function (message, key) {
                      return new C_algo.HMAC.init(hasher, key).finalize(message);
                  };
              }
          });
      
          /**
           * Algorithm namespace.
           */
          var C_algo = C.algo = {};
      
          return C;
      }(Math));
      
      "use strict";var n=void 0,r=!1;var sjcl={cipher:{},hash:{},keyexchange:{},mode:{},misc:{},codec:{},exception:{corrupt:function(a){this.toString=function(){return"CORRUPT: "+this.message};this.message=a},invalid:function(a){this.toString=function(){return"INVALID: "+this.message};this.message=a},bug:function(a){this.toString=function(){return"BUG: "+this.message};this.message=a},notReady:function(a){this.toString=function(){return"NOT READY: "+this.message};this.message=a}}};
      "undefined"!=typeof module&&module.exports&&(module.exports=sjcl);
      sjcl.cipher.aes=function(a){this.o[0][0][0]||this.L();var b,c,d,e,f=this.o[0][4],g=this.o[1];b=a.length;var h=1;if(4!==b&&6!==b&&8!==b)throw new sjcl.exception.invalid("invalid aes key size");this.c=[d=a.slice(0),e=[]];for(a=b;a<4*b+28;a++){c=d[a-1];if(0===a%b||8===b&&4===a%b)c=f[c>>>24]<<24^f[c>>16&255]<<16^f[c>>8&255]<<8^f[c&255],0===a%b&&(c=c<<8^c>>>24^h<<24,h=h<<1^283*(h>>7));d[a]=d[a-b]^c}for(b=0;a;b++,a--)c=d[b&3?a:a-4],e[b]=4>=a||4>b?c:g[0][f[c>>>24]]^g[1][f[c>>16&255]]^g[2][f[c>>8&255]]^g[3][f[c&
      255]]};
      sjcl.cipher.aes.prototype={encrypt:function(a){return s(this,a,0)},decrypt:function(a){return s(this,a,1)},o:[[[],[],[],[],[]],[[],[],[],[],[]]],L:function(){var a=this.o[0],b=this.o[1],c=a[4],d=b[4],e,f,g,h=[],k=[],p,m,l,q;for(e=0;0x100>e;e++)k[(h[e]=e<<1^283*(e>>7))^e]=e;for(f=g=0;!c[f];f^=p||1,g=k[g]||1){l=g^g<<1^g<<2^g<<3^g<<4;l=l>>8^l&255^99;c[f]=l;d[l]=f;m=h[e=h[p=h[f]]];q=0x1010101*m^0x10001*e^0x101*p^0x1010100*f;m=0x101*h[l]^0x1010100*l;for(e=0;4>e;e++)a[e][f]=m=m<<24^m>>>8,b[e][l]=q=q<<24^q>>>8}for(e=
      0;5>e;e++)a[e]=a[e].slice(0),b[e]=b[e].slice(0)}};
      function s(a,b,c){if(4!==b.length)throw new sjcl.exception.invalid("invalid aes block size");var d=a.c[c],e=b[0]^d[0],f=b[c?3:1]^d[1],g=b[2]^d[2];b=b[c?1:3]^d[3];var h,k,p,m=d.length/4-2,l,q=4,t=[0,0,0,0];h=a.o[c];a=h[0];var u=h[1],v=h[2],w=h[3],x=h[4];for(l=0;l<m;l++)h=a[e>>>24]^u[f>>16&255]^v[g>>8&255]^w[b&255]^d[q],k=a[f>>>24]^u[g>>16&255]^v[b>>8&255]^w[e&255]^d[q+1],p=a[g>>>24]^u[b>>16&255]^v[e>>8&255]^w[f&255]^d[q+2],b=a[b>>>24]^u[e>>16&255]^v[f>>8&255]^w[g&255]^d[q+3],q+=4,e=h,f=k,g=p;for(l=
      0;4>l;l++)t[c?3&-l:l]=x[e>>>24]<<24^x[f>>16&255]<<16^x[g>>8&255]<<8^x[b&255]^d[q++],h=e,e=f,f=g,g=b,b=h;return t}
      sjcl.bitArray={bitSlice:function(a,b,c){a=sjcl.bitArray.T(a.slice(b/32),32-(b&31)).slice(1);return c===n?a:sjcl.bitArray.clamp(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&31);return((b+c-1^b)&-32?a[b/32|0]<<32-d^a[b/32+1|0]>>>d:a[b/32|0]>>>d)&(1<<c)-1},concat:function(a,b){if(0===a.length||0===b.length)return a.concat(b);var c=a[a.length-1],d=sjcl.bitArray.getPartial(c);return 32===d?a.concat(b):sjcl.bitArray.T(b,d,c|0,a.slice(0,a.length-1))},bitLength:function(a){var b=a.length;return 0===
      b?0:32*(b-1)+sjcl.bitArray.getPartial(a[b-1])},clamp:function(a,b){if(32*a.length<b)return a;a=a.slice(0,Math.ceil(b/32));var c=a.length;b&=31;0<c&&b&&(a[c-1]=sjcl.bitArray.partial(b,a[c-1]&2147483648>>b-1,1));return a},partial:function(a,b,c){return 32===a?b:(c?b|0:b<<32-a)+0x10000000000*a},getPartial:function(a){return Math.round(a/0x10000000000)||32},equal:function(a,b){if(sjcl.bitArray.bitLength(a)!==sjcl.bitArray.bitLength(b))return r;var c=0,d;for(d=0;d<a.length;d++)c|=a[d]^b[d];return 0===
      c},T:function(a,b,c,d){var e;e=0;for(d===n&&(d=[]);32<=b;b-=32)d.push(c),c=0;if(0===b)return d.concat(a);for(e=0;e<a.length;e++)d.push(c|a[e]>>>b),c=a[e]<<32-b;e=a.length?a[a.length-1]:0;a=sjcl.bitArray.getPartial(e);d.push(sjcl.bitArray.partial(b+a&31,32<b+a?c:d.pop(),1));return d},$:function(a,b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[3]]}};
      sjcl.codec.utf8String={fromBits:function(a){var b="",c=sjcl.bitArray.bitLength(a),d,e;for(d=0;d<c/8;d++)0===(d&3)&&(e=a[d/4]),b+=String.fromCharCode(e>>>24),e<<=8;return decodeURIComponent(escape(b))},toBits:function(a){a=unescape(encodeURIComponent(a));var b=[],c,d=0;for(c=0;c<a.length;c++)d=d<<8|a.charCodeAt(c),3===(c&3)&&(b.push(d),d=0);c&3&&b.push(sjcl.bitArray.partial(8*(c&3),d));return b}};
      sjcl.codec.bytes={fromBits:function(a){var b=[],c=sjcl.bitArray.bitLength(a),d,e;for(d=0;d<c/8;d++)0===(d&3)&&(e=a[d/4]),b.push(e>>>24),e<<=8;return b},toBits:function(a){var b=[],c,d=0;for(c=0;c<a.length;c++)d=d<<8|a[c],3===(c&3)&&(b.push(d),d=0);c&3&&b.push(sjcl.bitArray.partial(8*(c&3),d));return b}};sjcl.hash.sha256=function(a){this.c[0]||this.L();a?(this.g=a.g.slice(0),this.e=a.e.slice(0),this.d=a.d):this.reset()};sjcl.hash.sha256.hash=function(a){return(new sjcl.hash.sha256).update(a).finalize()};
      sjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.g=this.v.slice(0);this.e=[];this.d=0;return this},update:function(a){"string"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));var b,c=this.e=sjcl.bitArray.concat(this.e,a);b=this.d;a=this.d=b+sjcl.bitArray.bitLength(a);for(b=512+b&-512;b<=a;b+=512)this.q(c.splice(0,16));return this},finalize:function(){var a,b=this.e,c=this.g,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&15;a++)b.push(0);b.push(Math.floor(this.d/
      4294967296));for(b.push(this.d|0);b.length;)this.q(b.splice(0,16));this.reset();return c},v:[],c:[],L:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}var b=0,c=2,d;a:for(;64>b;c++){for(d=2;d*d<=c;d++)if(0===c%d)continue a;8>b&&(this.v[b]=a(Math.pow(c,0.5)));this.c[b]=a(Math.pow(c,1/3));b++}},q:function(a){var b,c,d=a.slice(0),e=this.g,f=this.c,g=e[0],h=e[1],k=e[2],p=e[3],m=e[4],l=e[5],q=e[6],t=e[7];for(a=0;64>a;a++)16>a?b=d[a]:(b=d[a+1&15],c=d[a+14&15],b=d[a&15]=(b>>>7^b>>>18^b>>>3^
      b<<25^b<<14)+(c>>>17^c>>>19^c>>>10^c<<15^c<<13)+d[a&15]+d[a+9&15]|0),b=b+t+(m>>>6^m>>>11^m>>>25^m<<26^m<<21^m<<7)+(q^m&(l^q))+f[a],t=q,q=l,l=m,m=p+b|0,p=k,k=h,h=g,g=b+(h&k^p&(h^k))+(h>>>2^h>>>13^h>>>22^h<<30^h<<19^h<<10)|0;e[0]=e[0]+g|0;e[1]=e[1]+h|0;e[2]=e[2]+k|0;e[3]=e[3]+p|0;e[4]=e[4]+m|0;e[5]=e[5]+l|0;e[6]=e[6]+q|0;e[7]=e[7]+t|0}};sjcl.hash.sha1=function(a){a?(this.g=a.g.slice(0),this.e=a.e.slice(0),this.d=a.d):this.reset()};sjcl.hash.sha1.hash=function(a){return(new sjcl.hash.sha1).update(a).finalize()};
      sjcl.hash.sha1.prototype={blockSize:512,reset:function(){this.g=this.v.slice(0);this.e=[];this.d=0;return this},update:function(a){"string"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));var b,c=this.e=sjcl.bitArray.concat(this.e,a);b=this.d;a=this.d=b+sjcl.bitArray.bitLength(a);for(b=this.blockSize+b&-this.blockSize;b<=a;b+=this.blockSize)this.q(c.splice(0,16));return this},finalize:function(){var a,b=this.e,c=this.g,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&15;a++)b.push(0);
      b.push(Math.floor(this.d/0x100000000));for(b.push(this.d|0);b.length;)this.q(b.splice(0,16));this.reset();return c},v:[1732584193,4023233417,2562383102,271733878,3285377520],c:[1518500249,1859775393,2400959708,3395469782],q:function(a){var b,c,d,e,f,g,h=a.slice(0),k=this.g;c=k[0];d=k[1];e=k[2];f=k[3];g=k[4];for(a=0;79>=a;a++)16<=a&&(h[a]=(h[a-3]^h[a-8]^h[a-14]^h[a-16])<<1|(h[a-3]^h[a-8]^h[a-14]^h[a-16])>>>31),b=19>=a?d&e|~d&f:39>=a?d^e^f:59>=a?d&e|d&f|e&f:79>=a?d^e^f:n,b=(c<<5|c>>>27)+b+g+h[a]+this.c[Math.floor(a/
      20)]|0,g=f,f=e,e=d<<30|d>>>2,d=c,c=b;k[0]=k[0]+c|0;k[1]=k[1]+d|0;k[2]=k[2]+e|0;k[3]=k[3]+f|0;k[4]=k[4]+g|0}};sjcl.misc.hmac=function(a,b){this.Q=b=b||sjcl.hash.sha256;var c=[[],[]],d,e=b.prototype.blockSize/32;this.s=[new b,new b];a.length>e&&(a=b.hash(a));for(d=0;d<e;d++)c[0][d]=a[d]^909522486,c[1][d]=a[d]^1549556828;this.s[0].update(c[0]);this.s[1].update(c[1])};sjcl.misc.hmac.prototype.encrypt=sjcl.misc.hmac.prototype.mac=function(a){a=(new this.Q(this.s[0])).update(a).finalize();return(new this.Q(this.s[1])).update(a).finalize()};
      sjcl.misc.pbkdf2=function(a,b,c,d,e){c=c||1E3;if(0>d||0>c)throw sjcl.exception.invalid("invalid params to pbkdf2");"string"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));"string"===typeof b&&(b=sjcl.codec.utf8String.toBits(b));e=e||sjcl.misc.hmac;a=new e(a);var f,g,h,k,p=[],m=sjcl.bitArray;for(k=1;32*p.length<(d||1);k++){e=f=a.encrypt(m.concat(b,[k]));for(g=1;g<c;g++){f=a.encrypt(f);for(h=0;h<f.length;h++)e[h]^=f[h]}p=p.concat(e)}d&&(p=m.clamp(p,d));return p};
      sjcl.prng=function(a){this.h=[new sjcl.hash.sha256];this.m=[0];this.M=0;this.C={};this.K=0;this.O={};this.S=this.j=this.n=this.Z=0;this.c=[0,0,0,0,0,0,0,0];this.k=[0,0,0,0];this.I=n;this.J=a;this.t=r;this.H={progress:{},seeded:{}};this.p=this.Y=0;this.D=1;this.F=2;this.W=0x10000;this.N=[0,48,64,96,128,192,0x100,384,512,768,1024];this.X=3E4;this.V=80};
      sjcl.prng.prototype={randomWords:function(a,b){var c=[],d;d=this.isReady(b);var e;if(d===this.p)throw new sjcl.exception.notReady("generator isn't seeded");if(d&this.F){d=!(d&this.D);e=[];var f=0,g;this.S=e[0]=(new Date).valueOf()+this.X;for(g=0;16>g;g++)e.push(0x100000000*Math.random()|0);for(g=0;g<this.h.length&&!(e=e.concat(this.h[g].finalize()),f+=this.m[g],this.m[g]=0,!d&&this.M&1<<g);g++);this.M>=1<<this.h.length&&(this.h.push(new sjcl.hash.sha256),this.m.push(0));this.j-=f;f>this.n&&(this.n=
      f);this.M++;this.c=sjcl.hash.sha256.hash(this.c.concat(e));this.I=new sjcl.cipher.aes(this.c);for(d=0;4>d&&!(this.k[d]=this.k[d]+1|0,this.k[d]);d++);}for(d=0;d<a;d+=4)0===(d+1)%this.W&&y(this),e=z(this),c.push(e[0],e[1],e[2],e[3]);y(this);return c.slice(0,a)},setDefaultParanoia:function(a){this.J=a},addEntropy:function(a,b,c){c=c||"user";var d,e,f=(new Date).valueOf(),g=this.C[c],h=this.isReady(),k=0;d=this.O[c];d===n&&(d=this.O[c]=this.Z++);g===n&&(g=this.C[c]=0);this.C[c]=(this.C[c]+1)%this.h.length;
      switch(typeof a){case "number":b===n&&(b=1);this.h[g].update([d,this.K++,1,b,f,1,a|0]);break;case "object":c=Object.prototype.toString.call(a);if("[object Uint32Array]"===c){e=[];for(c=0;c<a.length;c++)e.push(a[c]);a=e}else{"[object Array]"!==c&&(k=1);for(c=0;c<a.length&&!k;c++)"number"!=typeof a[c]&&(k=1)}if(!k){if(b===n)for(c=b=0;c<a.length;c++)for(e=a[c];0<e;)b++,e>>>=1;this.h[g].update([d,this.K++,2,b,f,a.length].concat(a))}break;case "string":b===n&&(b=a.length);this.h[g].update([d,this.K++,
      3,b,f,a.length]);this.h[g].update(a);break;default:k=1}if(k)throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");this.m[g]+=b;this.j+=b;h===this.p&&(this.isReady()!==this.p&&A("seeded",Math.max(this.n,this.j)),A("progress",this.getProgress()))},isReady:function(a){a=this.N[a!==n?a:this.J];return this.n&&this.n>=a?this.m[0]>this.V&&(new Date).valueOf()>this.S?this.F|this.D:this.D:this.j>=a?this.F|this.p:this.p},getProgress:function(a){a=this.N[a?a:this.J];
      return this.n>=a?1:this.j>a?1:this.j/a},startCollectors:function(){if(!this.t){if(window.addEventListener)window.addEventListener("load",this.w,r),window.addEventListener("mousemove",this.A,r);else if(document.attachEvent)document.attachEvent("onload",this.w),document.attachEvent("onmousemove",this.A);else throw new sjcl.exception.bug("can't attach event");this.t=!0}},stopCollectors:function(){this.t&&(window.removeEventListener?(window.removeEventListener("load",this.w,r),window.removeEventListener("mousemove",
      this.A,r)):window.detachEvent&&(window.detachEvent("onload",this.w),window.detachEvent("onmousemove",this.A)),this.t=r)},addEventListener:function(a,b){this.H[a][this.Y++]=b},removeEventListener:function(a,b){var c,d,e=this.H[a],f=[];for(d in e)e.hasOwnProperty(d)&&e[d]===b&&f.push(d);for(c=0;c<f.length;c++)d=f[c],delete e[d]},A:function(a){sjcl.random.addEntropy([a.x||a.clientX||a.offsetX||0,a.y||a.clientY||a.offsetY||0],2,"mouse")},w:function(){sjcl.random.addEntropy((new Date).valueOf(),2,"loadtime")}};
      function A(a,b){var c,d=sjcl.random.H[a],e=[];for(c in d)d.hasOwnProperty(c)&&e.push(d[c]);for(c=0;c<e.length;c++)e[c](b)}function y(a){a.c=z(a).concat(z(a));a.I=new sjcl.cipher.aes(a.c)}function z(a){for(var b=0;4>b&&!(a.k[b]=a.k[b]+1|0,a.k[b]);b++);return a.I.encrypt(a.k)}sjcl.random=new sjcl.prng(6);
      try{if("undefined"!==typeof module&&module.exports){var B=require("crypto").randomBytes(128);sjcl.random.addEntropy(B,1024,"crypto['randomBytes']")}else if(window&&window.crypto&&window.crypto.getRandomValues){var C=new Uint32Array(32);window.crypto.getRandomValues(C);sjcl.random.addEntropy(C,1024,"crypto['getRandomValues']")}}catch(D){}sjcl.bn=function(a){this.initWith(a)};
      sjcl.bn.prototype={radix:24,maxMul:8,f:sjcl.bn,copy:function(){return new this.f(this)},initWith:function(a){var b=0,c;switch(typeof a){case "object":this.limbs=a.limbs.slice(0);break;case "number":this.limbs=[a];this.normalize();break;case "string":a=a.replace(/^0x/,"");this.limbs=[];c=this.radix/4;for(b=0;b<a.length;b+=c)this.limbs.push(parseInt(a.substring(Math.max(a.length-b-c,0),a.length-b),16));break;default:this.limbs=[0]}return this},equals:function(a){"number"===typeof a&&(a=new this.f(a));
      var b=0,c;this.fullReduce();a.fullReduce();for(c=0;c<this.limbs.length||c<a.limbs.length;c++)b|=this.getLimb(c)^a.getLimb(c);return 0===b},getLimb:function(a){return a>=this.limbs.length?0:this.limbs[a]},greaterEquals:function(a){"number"===typeof a&&(a=new this.f(a));var b=0,c=0,d,e,f;for(d=Math.max(this.limbs.length,a.limbs.length)-1;0<=d;d--)e=this.getLimb(d),f=a.getLimb(d),c|=f-e&~b,b|=e-f&~c;return(c|~b)>>>31},toString:function(){this.fullReduce();var a="",b,c,d=this.limbs;for(b=0;b<this.limbs.length;b++){for(c=
      d[b].toString(16);b<this.limbs.length-1&&6>c.length;)c="0"+c;a=c+a}return"0x"+a},addM:function(a){"object"!==typeof a&&(a=new this.f(a));var b=this.limbs,c=a.limbs;for(a=b.length;a<c.length;a++)b[a]=0;for(a=0;a<c.length;a++)b[a]+=c[a];return this},doubleM:function(){var a,b=0,c,d=this.radix,e=this.radixMask,f=this.limbs;for(a=0;a<f.length;a++)c=f[a],c=c+c+b,f[a]=c&e,b=c>>d;b&&f.push(b);return this},halveM:function(){var a,b=0,c,d=this.radix,e=this.limbs;for(a=e.length-1;0<=a;a--)c=e[a],e[a]=c+b>>
      1,b=(c&1)<<d;e[e.length-1]||e.pop();return this},subM:function(a){"object"!==typeof a&&(a=new this.f(a));var b=this.limbs,c=a.limbs;for(a=b.length;a<c.length;a++)b[a]=0;for(a=0;a<c.length;a++)b[a]-=c[a];return this},mod:function(a){var b=!this.greaterEquals(new sjcl.bn(0));a=(new sjcl.bn(a)).normalize();var c=(new sjcl.bn(this)).normalize(),d=0;for(b&&(c=(new sjcl.bn(0)).subM(c).normalize());c.greaterEquals(a);d++)a.doubleM();for(b&&(c=a.sub(c).normalize());0<d;d--)a.halveM(),c.greaterEquals(a)&&
      c.subM(a).normalize();return c.trim()},inverseMod:function(a){var b=new sjcl.bn(1),c=new sjcl.bn(0),d=new sjcl.bn(this),e=new sjcl.bn(a),f,g=1;if(!(a.limbs[0]&1))throw new sjcl.exception.invalid("inverseMod: p must be odd");do{d.limbs[0]&1&&(d.greaterEquals(e)||(f=d,d=e,e=f,f=b,b=c,c=f),d.subM(e),d.normalize(),b.greaterEquals(c)||b.addM(a),b.subM(c));d.halveM();b.limbs[0]&1&&b.addM(a);b.normalize();b.halveM();for(f=g=0;f<d.limbs.length;f++)g|=d.limbs[f]}while(g);if(!e.equals(1))throw new sjcl.exception.invalid("inverseMod: p and x must be relatively prime");
      return c},add:function(a){return this.copy().addM(a)},sub:function(a){return this.copy().subM(a)},mul:function(a){"number"===typeof a&&(a=new this.f(a));var b,c=this.limbs,d=a.limbs,e=c.length,f=d.length,g=new this.f,h=g.limbs,k,p=this.maxMul;for(b=0;b<this.limbs.length+a.limbs.length+1;b++)h[b]=0;for(b=0;b<e;b++){k=c[b];for(a=0;a<f;a++)h[b+a]+=k*d[a];--p||(p=this.maxMul,g.cnormalize())}return g.cnormalize().reduce()},square:function(){return this.mul(this)},power:function(a){"number"===typeof a?
      a=[a]:a.limbs!==n&&(a=a.normalize().limbs);var b,c,d=new this.f(1),e=this;for(b=0;b<a.length;b++)for(c=0;c<this.radix;c++)a[b]&1<<c&&(d=d.mul(e)),e=e.square();return d},mulmod:function(a,b){return this.mod(b).mul(a.mod(b)).mod(b)},powermod:function(a,b){for(var c=new sjcl.bn(1),d=new sjcl.bn(this),e=new sjcl.bn(a);;){e.limbs[0]&1&&(c=c.mulmod(d,b));e.halveM();if(e.equals(0))break;d=d.mulmod(d,b)}return c.normalize().reduce()},trim:function(){var a=this.limbs,b;do b=a.pop();while(a.length&&0===b);
      a.push(b);return this},reduce:function(){return this},fullReduce:function(){return this.normalize()},normalize:function(){var a=0,b,c=this.ipv,d,e=this.limbs,f=e.length,g=this.radixMask;for(b=0;b<f||0!==a&&-1!==a;b++)a=(e[b]||0)+a,d=e[b]=a&g,a=(a-d)*c;-1===a&&(e[b-1]-=this.placeVal);return this},cnormalize:function(){var a=0,b,c=this.ipv,d,e=this.limbs,f=e.length,g=this.radixMask;for(b=0;b<f-1;b++)a=e[b]+a,d=e[b]=a&g,a=(a-d)*c;e[b]+=a;return this},toBits:function(a){this.fullReduce();a=a||this.exponent||
      this.bitLength();var b=Math.floor((a-1)/24),c=sjcl.bitArray,d=[c.partial((a+7&-8)%this.radix||this.radix,this.getLimb(b))];for(b--;0<=b;b--)d=c.concat(d,[c.partial(Math.min(this.radix,a),this.getLimb(b))]),a-=this.radix;return d},bitLength:function(){this.fullReduce();for(var a=this.radix*(this.limbs.length-1),b=this.limbs[this.limbs.length-1];b;b>>>=1)a++;return a+7&-8}};
      sjcl.bn.fromBits=function(a){var b=new this,c=[],d=sjcl.bitArray,e=this.prototype,f=Math.min(this.bitLength||0x100000000,d.bitLength(a)),g=f%e.radix||e.radix;for(c[0]=d.extract(a,0,g);g<f;g+=e.radix)c.unshift(d.extract(a,g,e.radix));b.limbs=c;return b};sjcl.bn.prototype.ipv=1/(sjcl.bn.prototype.placeVal=Math.pow(2,sjcl.bn.prototype.radix));sjcl.bn.prototype.radixMask=(1<<sjcl.bn.prototype.radix)-1;
      sjcl.bn.pseudoMersennePrime=function(a,b){function c(a){this.initWith(a)}var d=c.prototype=new sjcl.bn,e,f;e=d.modOffset=Math.ceil(f=a/d.radix);d.exponent=a;d.offset=[];d.factor=[];d.minOffset=e;d.fullMask=0;d.fullOffset=[];d.fullFactor=[];d.modulus=c.modulus=new sjcl.bn(Math.pow(2,a));d.fullMask=0|-Math.pow(2,a%d.radix);for(e=0;e<b.length;e++)d.offset[e]=Math.floor(b[e][0]/d.radix-f),d.fullOffset[e]=Math.ceil(b[e][0]/d.radix-f),d.factor[e]=b[e][1]*Math.pow(0.5,a-b[e][0]+d.offset[e]*d.radix),d.fullFactor[e]=
      b[e][1]*Math.pow(0.5,a-b[e][0]+d.fullOffset[e]*d.radix),d.modulus.addM(new sjcl.bn(Math.pow(2,b[e][0])*b[e][1])),d.minOffset=Math.min(d.minOffset,-d.offset[e]);d.f=c;d.modulus.cnormalize();d.reduce=function(){var a,b,c,d=this.modOffset,e=this.limbs,f=this.offset,q=this.offset.length,t=this.factor,u;for(a=this.minOffset;e.length>d;){c=e.pop();u=e.length;for(b=0;b<q;b++)e[u+f[b]]-=t[b]*c;a--;a||(e.push(0),this.cnormalize(),a=this.minOffset)}this.cnormalize();return this};d.U=-1===d.fullMask?d.reduce:
      function(){var a=this.limbs,b=a.length-1,c,d;this.reduce();if(b===this.modOffset-1){d=a[b]&this.fullMask;a[b]-=d;for(c=0;c<this.fullOffset.length;c++)a[b+this.fullOffset[c]]-=this.fullFactor[c]*d;this.normalize()}};d.fullReduce=function(){var a,b;this.U();this.addM(this.modulus);this.addM(this.modulus);this.normalize();this.U();for(b=this.limbs.length;b<this.modOffset;b++)this.limbs[b]=0;a=this.greaterEquals(this.modulus);for(b=0;b<this.limbs.length;b++)this.limbs[b]-=this.modulus.limbs[b]*a;this.cnormalize();
      return this};d.inverse=function(){return this.power(this.modulus.sub(2))};c.fromBits=sjcl.bn.fromBits;return c};var E=sjcl.bn.pseudoMersennePrime;
      sjcl.bn.prime={p127:E(127,[[0,-1]]),p25519:E(255,[[0,-19]]),p192k:E(192,[[32,-1],[12,-1],[8,-1],[7,-1],[6,-1],[3,-1],[0,-1]]),p224k:E(224,[[32,-1],[12,-1],[11,-1],[9,-1],[7,-1],[4,-1],[1,-1],[0,-1]]),p256k:E(0x100,[[32,-1],[9,-1],[8,-1],[7,-1],[6,-1],[4,-1],[0,-1]]),p192:E(192,[[0,-1],[64,-1]]),p224:E(224,[[0,1],[96,-1]]),p256:E(0x100,[[0,-1],[96,1],[192,1],[224,-1]]),p384:E(384,[[0,-1],[32,1],[96,-1],[128,-1]]),p521:E(521,[[0,-1]])};
      sjcl.bn.random=function(a,b){"object"!==typeof a&&(a=new sjcl.bn(a));for(var c,d,e=a.limbs.length,f=a.limbs[e-1]+1,g=new sjcl.bn;;){do c=sjcl.random.randomWords(e,b),0>c[e-1]&&(c[e-1]+=0x100000000);while(Math.floor(c[e-1]/f)===Math.floor(0x100000000/f));c[e-1]%=f;for(d=0;d<e-1;d++)c[d]&=a.radixMask;g.limbs=c;if(!g.greaterEquals(a))return g}};sjcl.ecc={};sjcl.ecc.point=function(a,b,c){b===n?this.isIdentity=!0:(this.x=b,this.y=c,this.isIdentity=r);this.curve=a};
      sjcl.ecc.point.prototype={toJac:function(){return new sjcl.ecc.pointJac(this.curve,this.x,this.y,new this.curve.field(1))},mult:function(a){return this.toJac().mult(a,this).toAffine()},mult2:function(a,b,c){return this.toJac().mult2(a,this,b,c).toAffine()},multiples:function(){var a,b,c;if(this.R===n){c=this.toJac().doubl();a=this.R=[new sjcl.ecc.point(this.curve),this,c.toAffine()];for(b=3;16>b;b++)c=c.add(this),a.push(c.toAffine())}return this.R},isValid:function(){return this.y.square().equals(this.curve.b.add(this.x.mul(this.curve.a.add(this.x.square()))))},
      toBits:function(){return sjcl.bitArray.concat(this.x.toBits(),this.y.toBits())}};sjcl.ecc.pointJac=function(a,b,c,d){b===n?this.isIdentity=!0:(this.x=b,this.y=c,this.z=d,this.isIdentity=r);this.curve=a};
      sjcl.ecc.pointJac.prototype={add:function(a){var b,c,d,e;if(this.curve!==a.curve)throw"sjcl['ecc']['add'](): Points must be on the same curve to add them!";if(this.isIdentity)return a.toJac();if(a.isIdentity)return this;b=this.z.square();c=a.x.mul(b).subM(this.x);if(c.equals(0))return this.y.equals(a.y.mul(b.mul(this.z)))?this.doubl():new sjcl.ecc.pointJac(this.curve);b=a.y.mul(b.mul(this.z)).subM(this.y);d=c.square();a=b.square();e=c.square().mul(c).addM(this.x.add(this.x).mul(d));a=a.subM(e);b=
      this.x.mul(d).subM(a).mul(b);d=this.y.mul(c.square().mul(c));b=b.subM(d);c=this.z.mul(c);return new sjcl.ecc.pointJac(this.curve,a,b,c)},doubl:function(){if(this.isIdentity)return this;var a=this.y.square(),b=a.mul(this.x.mul(4)),c=a.square().mul(8),a=this.z.square(),d=this.curve.a.toString()==(new sjcl.bn(-3)).toString()?this.x.sub(a).mul(3).mul(this.x.add(a)):this.x.square().mul(3).add(a.square().mul(this.curve.a)),a=d.square().subM(b).subM(b),b=b.sub(a).mul(d).subM(c),c=this.y.add(this.y).mul(this.z);
      return new sjcl.ecc.pointJac(this.curve,a,b,c)},toAffine:function(){if(this.isIdentity||this.z.equals(0))return new sjcl.ecc.point(this.curve);var a=this.z.inverse(),b=a.square();return new sjcl.ecc.point(this.curve,this.x.mul(b).fullReduce(),this.y.mul(b.mul(a)).fullReduce())},mult:function(a,b){"number"===typeof a?a=[a]:a.limbs!==n&&(a=a.normalize().limbs);var c,d,e=(new sjcl.ecc.point(this.curve)).toJac(),f=b.multiples();for(c=a.length-1;0<=c;c--)for(d=sjcl.bn.prototype.radix-4;0<=d;d-=4)e=e.doubl().doubl().doubl().doubl().add(f[a[c]>>
      d&15]);return e},mult2:function(a,b,c,d){"number"===typeof a?a=[a]:a.limbs!==n&&(a=a.normalize().limbs);"number"===typeof c?c=[c]:c.limbs!==n&&(c=c.normalize().limbs);var e,f=(new sjcl.ecc.point(this.curve)).toJac();b=b.multiples();var g=d.multiples(),h,k;for(d=Math.max(a.length,c.length)-1;0<=d;d--){h=a[d]|0;k=c[d]|0;for(e=sjcl.bn.prototype.radix-4;0<=e;e-=4)f=f.doubl().doubl().doubl().doubl().add(b[h>>e&15]).add(g[k>>e&15])}return f},isValid:function(){var a=this.z.square(),b=a.square(),a=b.mul(a);
      return this.y.square().equals(this.curve.b.mul(a).add(this.x.mul(this.curve.a.mul(b).add(this.x.square()))))}};sjcl.ecc.curve=function(a,b,c,d,e,f){this.field=a;this.r=new sjcl.bn(b);this.a=new a(c);this.b=new a(d);this.G=new sjcl.ecc.point(this,new a(e),new a(f))};
      sjcl.ecc.curve.prototype.fromBits=function(a){var b=sjcl.bitArray,c=this.field.prototype.exponent+7&-8;a=new sjcl.ecc.point(this,this.field.fromBits(b.bitSlice(a,0,c)),this.field.fromBits(b.bitSlice(a,c,2*c)));if(!a.isValid())throw new sjcl.exception.corrupt("not on the curve!");return a};
      sjcl.ecc.curves={c192:new sjcl.ecc.curve(sjcl.bn.prime.p192,"0xffffffffffffffffffffffff99def836146bc9b1b4d22831",-3,"0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1","0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012","0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811"),c224:new sjcl.ecc.curve(sjcl.bn.prime.p224,"0xffffffffffffffffffffffffffff16a2e0b8f03e13dd29455c5c2a3d",-3,"0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4","0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21",
      "0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34"),c256:new sjcl.ecc.curve(sjcl.bn.prime.p256,"0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551",-3,"0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b","0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296","0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),c384:new sjcl.ecc.curve(sjcl.bn.prime.p384,"0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973",
      -3,"0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef","0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7","0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),k192:new sjcl.ecc.curve(sjcl.bn.prime.p192k,"0xfffffffffffffffffffffffe26f2fc170f69466a74defd8d",0,3,"0xdb4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d","0x9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d"),
      k224:new sjcl.ecc.curve(sjcl.bn.prime.p224k,"0x010000000000000000000000000001dce8d2ec6184caf0a971769fb1f7",0,5,"0xa1455b334df099df30fc28a169a467e9e47075a90f7e650eb6b7a45c","0x7e089fed7fba344282cafbd6f7e319f7c0b0bd59e2ca4bdb556d61a5"),k256:new sjcl.ecc.curve(sjcl.bn.prime.p256k,"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",0,7,"0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")};
      sjcl.ecc.P=function(a){sjcl.ecc[a]={publicKey:function(a,c){this.i=a;this.l=a.r.bitLength();this.B=c instanceof Array?a.fromBits(c):c;this.get=function(){var a=this.B.toBits(),b=sjcl.bitArray.bitLength(a),c=sjcl.bitArray.bitSlice(a,0,b/2),a=sjcl.bitArray.bitSlice(a,b/2);return{x:c,y:a}}},secretKey:function(a,c){this.i=a;this.l=a.r.bitLength();this.u=c;this.get=function(){return this.u.toBits()}},generateKeys:function(b,c,d){b===n&&(b=0x100);if("number"===typeof b&&(b=sjcl.ecc.curves["c"+b],b===n))throw new sjcl.exception.invalid("no such curve");
      d===n&&(d=sjcl.bn.random(b.r,c));c=b.G.mult(d);return{pub:new sjcl.ecc[a].publicKey(b,c),sec:new sjcl.ecc[a].secretKey(b,d)}}}};sjcl.ecc.P("elGamal");sjcl.ecc.elGamal.publicKey.prototype={kem:function(a){a=sjcl.bn.random(this.i.r,a);var b=this.i.G.mult(a).toBits();return{key:sjcl.hash.sha256.hash(this.B.mult(a).toBits()),tag:b}}};sjcl.ecc.elGamal.secretKey.prototype={unkem:function(a){return sjcl.hash.sha256.hash(this.i.fromBits(a).mult(this.u).toBits())},dh:function(a){return sjcl.hash.sha256.hash(a.B.mult(this.u).toBits())}};
      sjcl.ecc.P("ecdsa");sjcl.ecc.ecdsa.secretKey.prototype={sign:function(a,b,c,d){sjcl.bitArray.bitLength(a)>this.l&&(a=sjcl.bitArray.clamp(a,this.l));var e=this.i.r,f=e.bitLength();d=d||sjcl.bn.random(e.sub(1),b).add(1);b=this.i.G.mult(d).x.mod(e);a=sjcl.bn.fromBits(a).add(b.mul(this.u));c=c?a.inverseMod(e).mul(d).mod(e):a.mul(d.inverseMod(e)).mod(e);return sjcl.bitArray.concat(b.toBits(f),c.toBits(f))}};
      sjcl.ecc.ecdsa.publicKey.prototype={verify:function(a,b,c){sjcl.bitArray.bitLength(a)>this.l&&(a=sjcl.bitArray.clamp(a,this.l));var d=sjcl.bitArray,e=this.i.r,f=this.l,g=sjcl.bn.fromBits(d.bitSlice(b,0,f)),d=sjcl.bn.fromBits(d.bitSlice(b,f,2*f)),h=c?d:d.inverseMod(e),f=sjcl.bn.fromBits(a).mul(h).mod(e),h=g.mul(h).mod(e),f=this.i.G.mult2(f,h,this.B).x;if(g.equals(0)||d.equals(0)||g.greaterEquals(e)||d.greaterEquals(e)||!f.equals(g)){if(c===n)return this.verify(a,b,!0);throw new sjcl.exception.corrupt("signature didn't check out");
      }return!0}};
      
      // secrets.js - by Alexander Stetsyuk - released under MIT License
      (function(exports, global){
      function c(a){throw a;}var l=null,m="undefined"!==typeof module&&module.exports?module.exports:window.secrets={},n="undefined"!==typeof GLOBAL?GLOBAL:window;function q(a){a&&("number"!==typeof a||0!==a%1||a<r.g||a>r.e)&&c(Error("Number of bits must be an integer between "+r.g+" and "+r.e+", inclusive."));s.b=r.b;s.a=a||r.a;s.size=Math.pow(2,s.a);s.max=s.size-1;a=[];for(var b=[],d=1,e=r.l[s.a],f=0;f<s.size;f++)b[f]=d,a[d]=f,d<<=1,d>=s.size&&(d^=e,d&=s.max);s.c=a;s.d=b}
      function u(){return!s.a||!s.size||!s.max||!s.c||!s.d||s.c.length!==s.size||s.d.length!==s.size?!1:!0}
      function v(){function a(a,b,d,e){for(var j="",t=0,p=b.length-1;t<p||j.length<a;)j+=w(parseInt(b[t],d).toString(2),e),t++;j=j.substr(-a);return(j.match(/0/g)||[]).length===j.length?l:j}var b,d;if("function"===typeof require&&(d=require("crypto"))&&(b=d.randomBytes))return function(d){for(var e=Math.ceil(d/8),h=l;h===l;)h=a(d,b(e).toString("hex"),16,4);return h};if(n.crypto&&"function"===typeof n.crypto.getRandomValues&&"function"===typeof n.Uint32Array)return d=n.crypto,function(b){for(var e=l,h=new n.Uint32Array(Math.ceil(b/
      32));e===l;)d.getRandomValues(h),e=a(b,h,10,32);return e};s.i=!0;x();var e=Math.pow(2,32)-1;return function(b){for(var d=Math.ceil(b/32),h=[],k=l;k===l;){for(k=0;k<d;k++)h[k]=Math.floor(Math.random()*e+1);k=a(b,h,10,32)}return k}}function x(){n.console.warn(r.k);"function"===typeof n.alert&&s.alert&&n.alert(r.k)}
      function y(a){var b=parseInt(a[0],36);b&&("number"!==typeof b||0!==b%1||b<r.g||b>r.e)&&c(Error("Number of bits must be an integer between "+r.g+" and "+r.e+", inclusive."));var d=Math.pow(2,b)-1,e=d.toString(s.b).length,f=parseInt(a.substr(1,e),s.b);("number"!==typeof f||0!==f%1||1>f||f>d)&&c(Error("Share id must be an integer between 1 and "+s.max+", inclusive."));a=a.substr(e+1);a.length||c(Error("Invalid share: zero-length share."));return{bits:b,id:f,value:a}}
      function z(a,b){for(var d,e,f=[],g=[],h="",k,j=0,t=b.length;j<t;j++){e=y(b[j]);"undefined"===typeof d?d=e.bits:e.bits!==d&&c(Error("Mismatched shares: Different bit settings."));s.a!==d&&q(d);a:{k=0;for(var p=f.length;k<p;k++)if(f[k]===e.id){k=!0;break a}k=!1}if(!k){k=f.push(e.id)-1;e=A(B(e.value));for(var p=0,E=e.length;p<E;p++)g[p]=g[p]||[],g[p][k]=e[p]}}j=0;for(t=g.length;j<t;j++)h=w(C(a,f,g[j]).toString(2))+h;return 0===a?(k=h.indexOf("1"),D(h.slice(k+1))):D(h)}
      function C(a,b,d){var e=0,f,g,h;g=0;for(var k=b.length;g<k;g++)if(d[g]){f=s.c[d[g]];for(h=0;h<k;h++)if(g!==h){if(a===b[h]){f=-1;break}f=(f+s.c[a^b[h]]-s.c[b[g]^b[h]]+s.max)%s.max}e=-1===f?e:e^s.d[f]}return e}function A(a,b){b&&(a=w(a,b));for(var d=[],e=a.length;e>s.a;e-=s.a)d.push(parseInt(a.slice(e-s.a,e),2));d.push(parseInt(a.slice(0,e),2));return d}function w(a,b){b=b||s.a;var d=a.length%b;return(d?Array(b-d+1).join("0"):"")+a}
      function B(a){for(var b="",d,e=a.length-1;0<=e;e--)d=parseInt(a[e],16),isNaN(d)&&c(Error("Invalid hex character.")),b=w(d.toString(2),4)+b;return b}function D(a){var b="",d;a=w(a,4);for(var e=a.length;4<=e;e-=4)d=parseInt(a.slice(e-4,e),2),isNaN(d)&&c(Error("Invalid binary character.")),b=d.toString(16)+b;return b}
      var r={a:8,b:16,g:3,e:20,j:2,f:6,l:[l,l,1,3,3,5,3,3,29,17,9,5,83,27,43,3,45,9,39,39,9,5,3,33,27,9,71,39,9,5,83],k:"WARNING:\nA secure random number generator was not found.\nUsing Math.random(), which is NOT cryptographically strong!"},s={};m.getConfig=function(){return{bits:s.a,unsafePRNG:s.i}};m.init=q;
      m.setRNG=function(a,b){u()||this.init();s.i=!1;a=a||v();("function"!==typeof a||"string"!==typeof a(s.a)||!parseInt(a(s.a),2)||a(s.a).length>s.a||a(s.a).length<s.a)&&c(Error("Random number generator is invalid. Supply an RNG of the form function(bits){} that returns a string containing 'bits' number of random 1's and 0's."));s.h=a;s.alert=!!b;return!!s.m};
      m.random=function(a){"function"!==typeof s.h&&this.setRNG();("number"!==typeof a||0!==a%1||2>a)&&c(Error("Number of bits must be an integer greater than 1."));s.i&&x();return D(s.h(a))};
      m.share=function(a,b,d,e){u()||this.init();"function"!==typeof s.h&&this.setRNG();e=e||0;"string"!==typeof a&&c(Error("Secret must be a string."));("number"!==typeof b||0!==b%1||2>b)&&c(Error("Number of shares must be an integer between 2 and 2^bits-1 ("+s.max+"), inclusive."));if(b>s.max){var f=Math.ceil(Math.log(b+1)/Math.LN2);c(Error("Number of shares must be an integer between 2 and 2^bits-1 ("+s.max+"), inclusive. To create "+b+" shares, use at least "+f+" bits."))}("number"!==typeof d||0!==
      d%1||2>d)&&c(Error("Threshold number of shares must be an integer between 2 and 2^bits-1 ("+s.max+"), inclusive."));d>s.max&&(f=Math.ceil(Math.log(d+1)/Math.LN2),c(Error("Threshold number of shares must be an integer between 2 and 2^bits-1 ("+s.max+"), inclusive.  To use a threshold of "+d+", use at least "+f+" bits.")));("number"!==typeof e||0!==e%1)&&c(Error("Zero-pad length must be an integer greater than 1."));s.i&&x();a="1"+B(a);a=A(a,e);e=Array(b);for(var f=Array(b),g=0,h=a.length;g<h;g++)for(var k=
      this._getShares(a[g],b,d),j=0;j<b;j++)e[j]=e[j]||k[j].x.toString(s.b),f[j]=w(k[j].y.toString(2))+(f[j]?f[j]:"");a=s.max.toString(s.b).length;for(g=0;g<b;g++)e[g]=s.a.toString(36)+w(e[g],a)+D(f[g]);return e};m._getShares=function(a,b,d){var e=[];a=[a];for(var f=1;f<d;f++)a[f]=parseInt(s.h(s.a),2);f=1;for(b+=1;f<b;f++){d=s.c[f];for(var g=0,h=a.length-1;0<=h;h--)g=0===g?a[h]:s.d[(d+s.c[g])%s.max]^a[h];e[f-1]={x:f,y:g}}return e};secrets._processShare=y;m.combine=function(a){return z(0,a)};
      m.newShare=function(a,b){"string"===typeof a&&(a=parseInt(a,s.b));var d=y(b[0]),d=Math.pow(2,d.bits)-1;("number"!==typeof a||0!==a%1||1>a||a>d)&&c(Error("Share id must be an integer between 1 and "+s.max+", inclusive."));return s.a.toString(36)+w(a.toString(s.b),d.toString(s.b).length)+z(a,b)};m._lagrange=C;
      m.str2hex=function(a,b){"string"!==typeof a&&c(Error("Input must be a character string."));b=b||r.j;("number"!==typeof b||0!==b%1||1>b||b>r.f)&&c(Error("Bytes per character must be an integer between 1 and "+r.f+", inclusive."));for(var d=2*b,e=Math.pow(16,d)-1,f="",g,h=0,k=a.length;h<k;h++){g=a[h].charCodeAt();isNaN(g)&&c(Error("Invalid character: "+a[h]));if(g>e){var j=Math.ceil(Math.log(g+1)/Math.log(256));c(Error("Invalid character code ("+g+"). Maximum allowable is 256^bytes-1 ("+e+"). To convert this character, use at least "+
      j+" bytes."))}f=w(g.toString(16),d)+f}return f};m.hex2str=function(a,b){"string"!==typeof a&&c(Error("Input must be a hexadecimal string."));b=b||r.j;("number"!==typeof b||0!==b%1||1>b||b>r.f)&&c(Error("Bytes per character must be an integer between 1 and "+r.f+", inclusive."));var d=2*b,e="";a=w(a,d);for(var f=0,g=a.length;f<g;f+=d)e=String.fromCharCode(parseInt(a.slice(f,f+d),16))+e;return e};m.init();
      })(typeof module !== 'undefined' && module['exports'] ? module['exports'] : (window['secrets'] = {}), typeof GLOBAL !== 'undefined' ? GLOBAL : window );
      /*! jQuery v1.10.2 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
      //@ sourceMappingURL=jquery-1.10.2.min.map
      */
      (function(e,t){var n,r,i=typeof t,o=e.location,a=e.document,s=a.documentElement,l=e.jQuery,u=e.$,c={},p=[],f="1.10.2",d=p.concat,h=p.push,g=p.slice,m=p.indexOf,y=c.toString,v=c.hasOwnProperty,b=f.trim,x=function(e,t){return new x.fn.init(e,t,r)},w=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=/\S+/g,C=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,N=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,k=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,E=/^[\],:{}\s]*$/,S=/(?:^|:|,)(?:\s*\[)+/g,A=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,j=/"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,D=/^-ms-/,L=/-([\da-z])/gi,H=function(e,t){return t.toUpperCase()},q=function(e){(a.addEventListener||"load"===e.type||"complete"===a.readyState)&&(_(),x.ready())},_=function(){a.addEventListener?(a.removeEventListener("DOMContentLoaded",q,!1),e.removeEventListener("load",q,!1)):(a.detachEvent("onreadystatechange",q),e.detachEvent("onload",q))};x.fn=x.prototype={jquery:f,constructor:x,init:function(e,n,r){var i,o;if(!e)return this;if("string"==typeof e){if(i="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof x?n[0]:n,x.merge(this,x.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:a,!0)),k.test(i[1])&&x.isPlainObject(n))for(i in n)x.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(o=a.getElementById(i[2]),o&&o.parentNode){if(o.id!==i[2])return r.find(e);this.length=1,this[0]=o}return this.context=a,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):x.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),x.makeArray(e,this))},selector:"",length:0,toArray:function(){return g.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=x.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return x.each(this,e,t)},ready:function(e){return x.ready.promise().done(e),this},slice:function(){return this.pushStack(g.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(x.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:h,sort:[].sort,splice:[].splice},x.fn.init.prototype=x.fn,x.extend=x.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[1]||{},l=2),"object"==typeof s||x.isFunction(s)||(s={}),u===l&&(s=this,--l);u>l;l++)if(null!=(o=arguments[l]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(x.isPlainObject(r)||(n=x.isArray(r)))?(n?(n=!1,a=e&&x.isArray(e)?e:[]):a=e&&x.isPlainObject(e)?e:{},s[i]=x.extend(c,a,r)):r!==t&&(s[i]=r));return s},x.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),noConflict:function(t){return e.$===x&&(e.$=u),t&&e.jQuery===x&&(e.jQuery=l),x},isReady:!1,readyWait:1,holdReady:function(e){e?x.readyWait++:x.ready(!0)},ready:function(e){if(e===!0?!--x.readyWait:!x.isReady){if(!a.body)return setTimeout(x.ready);x.isReady=!0,e!==!0&&--x.readyWait>0||(n.resolveWith(a,[x]),x.fn.trigger&&x(a).trigger("ready").off("ready"))}},isFunction:function(e){return"function"===x.type(e)},isArray:Array.isArray||function(e){return"array"===x.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?c[y.call(e)]||"object":typeof e},isPlainObject:function(e){var n;if(!e||"object"!==x.type(e)||e.nodeType||x.isWindow(e))return!1;try{if(e.constructor&&!v.call(e,"constructor")&&!v.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(r){return!1}if(x.support.ownLast)for(n in e)return v.call(e,n);for(n in e);return n===t||v.call(e,n)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||a;var r=k.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=x.buildFragment([e],t,i),i&&x(i).remove(),x.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:"string"==typeof n&&(n=x.trim(n),n&&E.test(n.replace(A,"@").replace(j,"]").replace(S,"")))?Function("return "+n)():(x.error("Invalid JSON: "+n),t)},parseXML:function(n){var r,i;if(!n||"string"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName("parsererror").length||x.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&x.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(D,"ms-").replace(L,H)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:b&&!b.call("\ufeff\u00a0")?function(e){return null==e?"":b.call(e)}:function(e){return null==e?"":(e+"").replace(C,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?x.merge(n,"string"==typeof e?[e]:e):h.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(m)return m.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if("number"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return d.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return"string"==typeof n&&(o=e[n],n=e,e=o),x.isFunction(e)?(r=g.call(arguments,2),i=function(){return e.apply(n||this,r.concat(g.call(arguments)))},i.guid=e.guid=e.guid||x.guid++,i):t},access:function(e,n,r,i,o,a,s){var l=0,u=e.length,c=null==r;if("object"===x.type(r)){o=!0;for(l in r)x.access(e,n,l,r[l],!0,a,s)}else if(i!==t&&(o=!0,x.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(x(e),n)})),n))for(;u>l;l++)n(e[l],r,s?i:i.call(e[l],l,n(e[l],r)));return o?e:c?n.call(e):u?n(e[0],r):a},now:function(){return(new Date).getTime()},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),x.ready.promise=function(t){if(!n)if(n=x.Deferred(),"complete"===a.readyState)setTimeout(x.ready);else if(a.addEventListener)a.addEventListener("DOMContentLoaded",q,!1),e.addEventListener("load",q,!1);else{a.attachEvent("onreadystatechange",q),e.attachEvent("onload",q);var r=!1;try{r=null==e.frameElement&&a.documentElement}catch(i){}r&&r.doScroll&&function o(){if(!x.isReady){try{r.doScroll("left")}catch(e){return setTimeout(o,50)}_(),x.ready()}}()}return n.promise(t)},x.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){c["[object "+t+"]"]=t.toLowerCase()});function M(e){var t=e.length,n=x.type(e);return x.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}r=x(a),function(e,t){var n,r,i,o,a,s,l,u,c,p,f,d,h,g,m,y,v,b="sizzle"+-new Date,w=e.document,T=0,C=0,N=st(),k=st(),E=st(),S=!1,A=function(e,t){return e===t?(S=!0,0):0},j=typeof t,D=1<<31,L={}.hasOwnProperty,H=[],q=H.pop,_=H.push,M=H.push,O=H.slice,F=H.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},B="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",P="[\\x20\\t\\r\\n\\f]",R="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",W=R.replace("w","w#"),$="\\["+P+"*("+R+")"+P+"*(?:([*^$|!~]?=)"+P+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+W+")|)|)"+P+"*\\]",I=":("+R+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+$.replace(3,8)+")*)|.*)\\)|)",z=RegExp("^"+P+"+|((?:^|[^\\\\])(?:\\\\.)*)"+P+"+$","g"),X=RegExp("^"+P+"*,"+P+"*"),U=RegExp("^"+P+"*([>+~]|"+P+")"+P+"*"),V=RegExp(P+"*[+~]"),Y=RegExp("="+P+"*([^\\]'\"]*)"+P+"*\\]","g"),J=RegExp(I),G=RegExp("^"+W+"$"),Q={ID:RegExp("^#("+R+")"),CLASS:RegExp("^\\.("+R+")"),TAG:RegExp("^("+R.replace("w","w*")+")"),ATTR:RegExp("^"+$),PSEUDO:RegExp("^"+I),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+P+"*(even|odd|(([+-]|)(\\d*)n|)"+P+"*(?:([+-]|)"+P+"*(\\d+)|))"+P+"*\\)|)","i"),bool:RegExp("^(?:"+B+")$","i"),needsContext:RegExp("^"+P+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+P+"*((?:-\\d)?\\d*)"+P+"*\\)|)(?=[^-]|$)","i")},K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,et=/^(?:input|select|textarea|button)$/i,tt=/^h\d$/i,nt=/'|\\/g,rt=RegExp("\\\\([\\da-f]{1,6}"+P+"?|("+P+")|.)","ig"),it=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:0>r?String.fromCharCode(r+65536):String.fromCharCode(55296|r>>10,56320|1023&r)};try{M.apply(H=O.call(w.childNodes),w.childNodes),H[w.childNodes.length].nodeType}catch(ot){M={apply:H.length?function(e,t){_.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function at(e,t,n,i){var o,a,s,l,u,c,d,m,y,x;if((t?t.ownerDocument||t:w)!==f&&p(t),t=t||f,n=n||[],!e||"string"!=typeof e)return n;if(1!==(l=t.nodeType)&&9!==l)return[];if(h&&!i){if(o=Z.exec(e))if(s=o[1]){if(9===l){if(a=t.getElementById(s),!a||!a.parentNode)return n;if(a.id===s)return n.push(a),n}else if(t.ownerDocument&&(a=t.ownerDocument.getElementById(s))&&v(t,a)&&a.id===s)return n.push(a),n}else{if(o[2])return M.apply(n,t.getElementsByTagName(e)),n;if((s=o[3])&&r.getElementsByClassName&&t.getElementsByClassName)return M.apply(n,t.getElementsByClassName(s)),n}if(r.qsa&&(!g||!g.test(e))){if(m=d=b,y=t,x=9===l&&e,1===l&&"object"!==t.nodeName.toLowerCase()){c=mt(e),(d=t.getAttribute("id"))?m=d.replace(nt,"\\$&"):t.setAttribute("id",m),m="[id='"+m+"'] ",u=c.length;while(u--)c[u]=m+yt(c[u]);y=V.test(e)&&t.parentNode||t,x=c.join(",")}if(x)try{return M.apply(n,y.querySelectorAll(x)),n}catch(T){}finally{d||t.removeAttribute("id")}}}return kt(e.replace(z,"$1"),t,n,i)}function st(){var e=[];function t(n,r){return e.push(n+=" ")>o.cacheLength&&delete t[e.shift()],t[n]=r}return t}function lt(e){return e[b]=!0,e}function ut(e){var t=f.createElement("div");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function ct(e,t){var n=e.split("|"),r=e.length;while(r--)o.attrHandle[n[r]]=t}function pt(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&(~t.sourceIndex||D)-(~e.sourceIndex||D);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function ft(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function dt(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function ht(e){return lt(function(t){return t=+t,lt(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}s=at.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},r=at.support={},p=at.setDocument=function(e){var n=e?e.ownerDocument||e:w,i=n.defaultView;return n!==f&&9===n.nodeType&&n.documentElement?(f=n,d=n.documentElement,h=!s(n),i&&i.attachEvent&&i!==i.top&&i.attachEvent("onbeforeunload",function(){p()}),r.attributes=ut(function(e){return e.className="i",!e.getAttribute("className")}),r.getElementsByTagName=ut(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),r.getElementsByClassName=ut(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",2===e.getElementsByClassName("i").length}),r.getById=ut(function(e){return d.appendChild(e).id=b,!n.getElementsByName||!n.getElementsByName(b).length}),r.getById?(o.find.ID=function(e,t){if(typeof t.getElementById!==j&&h){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){return e.getAttribute("id")===t}}):(delete o.find.ID,o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){var n=typeof e.getAttributeNode!==j&&e.getAttributeNode("id");return n&&n.value===t}}),o.find.TAG=r.getElementsByTagName?function(e,n){return typeof n.getElementsByTagName!==j?n.getElementsByTagName(e):t}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},o.find.CLASS=r.getElementsByClassName&&function(e,n){return typeof n.getElementsByClassName!==j&&h?n.getElementsByClassName(e):t},m=[],g=[],(r.qsa=K.test(n.querySelectorAll))&&(ut(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||g.push("\\["+P+"*(?:value|"+B+")"),e.querySelectorAll(":checked").length||g.push(":checked")}),ut(function(e){var t=n.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("t",""),e.querySelectorAll("[t^='']").length&&g.push("[*^$]="+P+"*(?:''|\"\")"),e.querySelectorAll(":enabled").length||g.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),g.push(",.*:")})),(r.matchesSelector=K.test(y=d.webkitMatchesSelector||d.mozMatchesSelector||d.oMatchesSelector||d.msMatchesSelector))&&ut(function(e){r.disconnectedMatch=y.call(e,"div"),y.call(e,"[s!='']:x"),m.push("!=",I)}),g=g.length&&RegExp(g.join("|")),m=m.length&&RegExp(m.join("|")),v=K.test(d.contains)||d.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},A=d.compareDocumentPosition?function(e,t){if(e===t)return S=!0,0;var i=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t);return i?1&i||!r.sortDetached&&t.compareDocumentPosition(e)===i?e===n||v(w,e)?-1:t===n||v(w,t)?1:c?F.call(c,e)-F.call(c,t):0:4&i?-1:1:e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,o=e.parentNode,a=t.parentNode,s=[e],l=[t];if(e===t)return S=!0,0;if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:c?F.call(c,e)-F.call(c,t):0;if(o===a)return pt(e,t);r=e;while(r=r.parentNode)s.unshift(r);r=t;while(r=r.parentNode)l.unshift(r);while(s[i]===l[i])i++;return i?pt(s[i],l[i]):s[i]===w?-1:l[i]===w?1:0},n):f},at.matches=function(e,t){return at(e,null,null,t)},at.matchesSelector=function(e,t){if((e.ownerDocument||e)!==f&&p(e),t=t.replace(Y,"='$1']"),!(!r.matchesSelector||!h||m&&m.test(t)||g&&g.test(t)))try{var n=y.call(e,t);if(n||r.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(i){}return at(t,f,null,[e]).length>0},at.contains=function(e,t){return(e.ownerDocument||e)!==f&&p(e),v(e,t)},at.attr=function(e,n){(e.ownerDocument||e)!==f&&p(e);var i=o.attrHandle[n.toLowerCase()],a=i&&L.call(o.attrHandle,n.toLowerCase())?i(e,n,!h):t;return a===t?r.attributes||!h?e.getAttribute(n):(a=e.getAttributeNode(n))&&a.specified?a.value:null:a},at.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},at.uniqueSort=function(e){var t,n=[],i=0,o=0;if(S=!r.detectDuplicates,c=!r.sortStable&&e.slice(0),e.sort(A),S){while(t=e[o++])t===e[o]&&(i=n.push(o));while(i--)e.splice(n[i],1)}return e},a=at.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=a(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=a(t);return n},o=at.selectors={cacheLength:50,createPseudo:lt,match:Q,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(rt,it),e[3]=(e[4]||e[5]||"").replace(rt,it),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||at.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&at.error(e[0]),e},PSEUDO:function(e){var n,r=!e[5]&&e[2];return Q.CHILD.test(e[0])?null:(e[3]&&e[4]!==t?e[2]=e[4]:r&&J.test(r)&&(n=mt(r,!0))&&(n=r.indexOf(")",r.length-n)-r.length)&&(e[0]=e[0].slice(0,n),e[2]=r.slice(0,n)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(rt,it).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=N[e+" "];return t||(t=RegExp("(^|"+P+")"+e+"("+P+"|$)"))&&N(e,function(e){return t.test("string"==typeof e.className&&e.className||typeof e.getAttribute!==j&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=at.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,l){var u,c,p,f,d,h,g=o!==a?"nextSibling":"previousSibling",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),v=!l&&!s;if(m){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&v){c=m[b]||(m[b]={}),u=c[e]||[],d=u[0]===T&&u[1],f=u[0]===T&&u[2],p=d&&m.childNodes[d];while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[T,d,f];break}}else if(v&&(u=(t[b]||(t[b]={}))[e])&&u[0]===T)f=u[1];else while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(v&&((p[b]||(p[b]={}))[e]=[T,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=o.pseudos[e]||o.setFilters[e.toLowerCase()]||at.error("unsupported pseudo: "+e);return r[b]?r(t):r.length>1?(n=[e,e,"",t],o.setFilters.hasOwnProperty(e.toLowerCase())?lt(function(e,n){var i,o=r(e,t),a=o.length;while(a--)i=F.call(e,o[a]),e[i]=!(n[i]=o[a])}):function(e){return r(e,0,n)}):r}},pseudos:{not:lt(function(e){var t=[],n=[],r=l(e.replace(z,"$1"));return r[b]?lt(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:lt(function(e){return function(t){return at(e,t).length>0}}),contains:lt(function(e){return function(t){return(t.textContent||t.innerText||a(t)).indexOf(e)>-1}}),lang:lt(function(e){return G.test(e||"")||at.error("unsupported lang: "+e),e=e.replace(rt,it).toLowerCase(),function(t){var n;do if(n=h?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===d},focus:function(e){return e===f.activeElement&&(!f.hasFocus||f.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!o.pseudos.empty(e)},header:function(e){return tt.test(e.nodeName)},input:function(e){return et.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:ht(function(){return[0]}),last:ht(function(e,t){return[t-1]}),eq:ht(function(e,t,n){return[0>n?n+t:n]}),even:ht(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:ht(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:ht(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:ht(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}},o.pseudos.nth=o.pseudos.eq;for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})o.pseudos[n]=ft(n);for(n in{submit:!0,reset:!0})o.pseudos[n]=dt(n);function gt(){}gt.prototype=o.filters=o.pseudos,o.setFilters=new gt;function mt(e,t){var n,r,i,a,s,l,u,c=k[e+" "];if(c)return t?0:c.slice(0);s=e,l=[],u=o.preFilter;while(s){(!n||(r=X.exec(s)))&&(r&&(s=s.slice(r[0].length)||s),l.push(i=[])),n=!1,(r=U.exec(s))&&(n=r.shift(),i.push({value:n,type:r[0].replace(z," ")}),s=s.slice(n.length));for(a in o.filter)!(r=Q[a].exec(s))||u[a]&&!(r=u[a](r))||(n=r.shift(),i.push({value:n,type:a,matches:r}),s=s.slice(n.length));if(!n)break}return t?s.length:s?at.error(e):k(e,l).slice(0)}function yt(e){var t=0,n=e.length,r="";for(;n>t;t++)r+=e[t].value;return r}function vt(e,t,n){var r=t.dir,o=n&&"parentNode"===r,a=C++;return t.first?function(t,n,i){while(t=t[r])if(1===t.nodeType||o)return e(t,n,i)}:function(t,n,s){var l,u,c,p=T+" "+a;if(s){while(t=t[r])if((1===t.nodeType||o)&&e(t,n,s))return!0}else while(t=t[r])if(1===t.nodeType||o)if(c=t[b]||(t[b]={}),(u=c[r])&&u[0]===p){if((l=u[1])===!0||l===i)return l===!0}else if(u=c[r]=[p],u[1]=e(t,n,s)||i,u[1]===!0)return!0}}function bt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function xt(e,t,n,r,i){var o,a=[],s=0,l=e.length,u=null!=t;for(;l>s;s++)(o=e[s])&&(!n||n(o,r,i))&&(a.push(o),u&&t.push(s));return a}function wt(e,t,n,r,i,o){return r&&!r[b]&&(r=wt(r)),i&&!i[b]&&(i=wt(i,o)),lt(function(o,a,s,l){var u,c,p,f=[],d=[],h=a.length,g=o||Nt(t||"*",s.nodeType?[s]:s,[]),m=!e||!o&&t?g:xt(g,f,e,s,l),y=n?i||(o?e:h||r)?[]:a:m;if(n&&n(m,y,s,l),r){u=xt(y,d),r(u,[],s,l),c=u.length;while(c--)(p=u[c])&&(y[d[c]]=!(m[d[c]]=p))}if(o){if(i||e){if(i){u=[],c=y.length;while(c--)(p=y[c])&&u.push(m[c]=p);i(null,y=[],u,l)}c=y.length;while(c--)(p=y[c])&&(u=i?F.call(o,p):f[c])>-1&&(o[u]=!(a[u]=p))}}else y=xt(y===a?y.splice(h,y.length):y),i?i(null,a,y,l):M.apply(a,y)})}function Tt(e){var t,n,r,i=e.length,a=o.relative[e[0].type],s=a||o.relative[" "],l=a?1:0,c=vt(function(e){return e===t},s,!0),p=vt(function(e){return F.call(t,e)>-1},s,!0),f=[function(e,n,r){return!a&&(r||n!==u)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;i>l;l++)if(n=o.relative[e[l].type])f=[vt(bt(f),n)];else{if(n=o.filter[e[l].type].apply(null,e[l].matches),n[b]){for(r=++l;i>r;r++)if(o.relative[e[r].type])break;return wt(l>1&&bt(f),l>1&&yt(e.slice(0,l-1).concat({value:" "===e[l-2].type?"*":""})).replace(z,"$1"),n,r>l&&Tt(e.slice(l,r)),i>r&&Tt(e=e.slice(r)),i>r&&yt(e))}f.push(n)}return bt(f)}function Ct(e,t){var n=0,r=t.length>0,a=e.length>0,s=function(s,l,c,p,d){var h,g,m,y=[],v=0,b="0",x=s&&[],w=null!=d,C=u,N=s||a&&o.find.TAG("*",d&&l.parentNode||l),k=T+=null==C?1:Math.random()||.1;for(w&&(u=l!==f&&l,i=n);null!=(h=N[b]);b++){if(a&&h){g=0;while(m=e[g++])if(m(h,l,c)){p.push(h);break}w&&(T=k,i=++n)}r&&((h=!m&&h)&&v--,s&&x.push(h))}if(v+=b,r&&b!==v){g=0;while(m=t[g++])m(x,y,l,c);if(s){if(v>0)while(b--)x[b]||y[b]||(y[b]=q.call(p));y=xt(y)}M.apply(p,y),w&&!s&&y.length>0&&v+t.length>1&&at.uniqueSort(p)}return w&&(T=k,u=C),x};return r?lt(s):s}l=at.compile=function(e,t){var n,r=[],i=[],o=E[e+" "];if(!o){t||(t=mt(e)),n=t.length;while(n--)o=Tt(t[n]),o[b]?r.push(o):i.push(o);o=E(e,Ct(i,r))}return o};function Nt(e,t,n){var r=0,i=t.length;for(;i>r;r++)at(e,t[r],n);return n}function kt(e,t,n,i){var a,s,u,c,p,f=mt(e);if(!i&&1===f.length){if(s=f[0]=f[0].slice(0),s.length>2&&"ID"===(u=s[0]).type&&r.getById&&9===t.nodeType&&h&&o.relative[s[1].type]){if(t=(o.find.ID(u.matches[0].replace(rt,it),t)||[])[0],!t)return n;e=e.slice(s.shift().value.length)}a=Q.needsContext.test(e)?0:s.length;while(a--){if(u=s[a],o.relative[c=u.type])break;if((p=o.find[c])&&(i=p(u.matches[0].replace(rt,it),V.test(s[0].type)&&t.parentNode||t))){if(s.splice(a,1),e=i.length&&yt(s),!e)return M.apply(n,i),n;break}}}return l(e,f)(i,t,!h,n,V.test(e)),n}r.sortStable=b.split("").sort(A).join("")===b,r.detectDuplicates=S,p(),r.sortDetached=ut(function(e){return 1&e.compareDocumentPosition(f.createElement("div"))}),ut(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||ct("type|href|height|width",function(e,n,r){return r?t:e.getAttribute(n,"type"===n.toLowerCase()?1:2)}),r.attributes&&ut(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||ct("value",function(e,n,r){return r||"input"!==e.nodeName.toLowerCase()?t:e.defaultValue}),ut(function(e){return null==e.getAttribute("disabled")})||ct(B,function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&i.specified?i.value:e[n]===!0?n.toLowerCase():null}),x.find=at,x.expr=at.selectors,x.expr[":"]=x.expr.pseudos,x.unique=at.uniqueSort,x.text=at.getText,x.isXMLDoc=at.isXML,x.contains=at.contains}(e);var O={};function F(e){var t=O[e]={};return x.each(e.match(T)||[],function(e,n){t[n]=!0}),t}x.Callbacks=function(e){e="string"==typeof e?O[e]||F(e):x.extend({},e);var n,r,i,o,a,s,l=[],u=!e.once&&[],c=function(t){for(r=e.memory&&t,i=!0,a=s||0,s=0,o=l.length,n=!0;l&&o>a;a++)if(l[a].apply(t[0],t[1])===!1&&e.stopOnFalse){r=!1;break}n=!1,l&&(u?u.length&&c(u.shift()):r?l=[]:p.disable())},p={add:function(){if(l){var t=l.length;(function i(t){x.each(t,function(t,n){var r=x.type(n);"function"===r?e.unique&&p.has(n)||l.push(n):n&&n.length&&"string"!==r&&i(n)})})(arguments),n?o=l.length:r&&(s=t,c(r))}return this},remove:function(){return l&&x.each(arguments,function(e,t){var r;while((r=x.inArray(t,l,r))>-1)l.splice(r,1),n&&(o>=r&&o--,a>=r&&a--)}),this},has:function(e){return e?x.inArray(e,l)>-1:!(!l||!l.length)},empty:function(){return l=[],o=0,this},disable:function(){return l=u=r=t,this},disabled:function(){return!l},lock:function(){return u=t,r||p.disable(),this},locked:function(){return!u},fireWith:function(e,t){return!l||i&&!u||(t=t||[],t=[e,t.slice?t.slice():t],n?u.push(t):c(t)),this},fire:function(){return p.fireWith(this,arguments),this},fired:function(){return!!i}};return p},x.extend({Deferred:function(e){var t=[["resolve","done",x.Callbacks("once memory"),"resolved"],["reject","fail",x.Callbacks("once memory"),"rejected"],["notify","progress",x.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return x.Deferred(function(n){x.each(t,function(t,o){var a=o[0],s=x.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&x.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[a+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?x.extend(e,r):r}},i={};return r.pipe=r.then,x.each(t,function(e,o){var a=o[2],s=o[3];r[o[1]]=a.add,s&&a.add(function(){n=s},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=g.call(arguments),r=n.length,i=1!==r||e&&x.isFunction(e.promise)?r:0,o=1===i?e:x.Deferred(),a=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?g.call(arguments):r,n===s?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},s,l,u;if(r>1)for(s=Array(r),l=Array(r),u=Array(r);r>t;t++)n[t]&&x.isFunction(n[t].promise)?n[t].promise().done(a(t,u,n)).fail(o.reject).progress(a(t,l,s)):--i;return i||o.resolveWith(u,n),o.promise()}}),x.support=function(t){var n,r,o,s,l,u,c,p,f,d=a.createElement("div");if(d.setAttribute("className","t"),d.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=d.getElementsByTagName("*")||[],r=d.getElementsByTagName("a")[0],!r||!r.style||!n.length)return t;s=a.createElement("select"),u=s.appendChild(a.createElement("option")),o=d.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t.getSetAttribute="t"!==d.className,t.leadingWhitespace=3===d.firstChild.nodeType,t.tbody=!d.getElementsByTagName("tbody").length,t.htmlSerialize=!!d.getElementsByTagName("link").length,t.style=/top/.test(r.getAttribute("style")),t.hrefNormalized="/a"===r.getAttribute("href"),t.opacity=/^0.5/.test(r.style.opacity),t.cssFloat=!!r.style.cssFloat,t.checkOn=!!o.value,t.optSelected=u.selected,t.enctype=!!a.createElement("form").enctype,t.html5Clone="<:nav></:nav>"!==a.createElement("nav").cloneNode(!0).outerHTML,t.inlineBlockNeedsLayout=!1,t.shrinkWrapBlocks=!1,t.pixelPosition=!1,t.deleteExpando=!0,t.noCloneEvent=!0,t.reliableMarginRight=!0,t.boxSizingReliable=!0,o.checked=!0,t.noCloneChecked=o.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!u.disabled;try{delete d.test}catch(h){t.deleteExpando=!1}o=a.createElement("input"),o.setAttribute("value",""),t.input=""===o.getAttribute("value"),o.value="t",o.setAttribute("type","radio"),t.radioValue="t"===o.value,o.setAttribute("checked","t"),o.setAttribute("name","t"),l=a.createDocumentFragment(),l.appendChild(o),t.appendChecked=o.checked,t.checkClone=l.cloneNode(!0).cloneNode(!0).lastChild.checked,d.attachEvent&&(d.attachEvent("onclick",function(){t.noCloneEvent=!1}),d.cloneNode(!0).click());for(f in{submit:!0,change:!0,focusin:!0})d.setAttribute(c="on"+f,"t"),t[f+"Bubbles"]=c in e||d.attributes[c].expando===!1;d.style.backgroundClip="content-box",d.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle="content-box"===d.style.backgroundClip;for(f in x(t))break;return t.ownLast="0"!==f,x(function(){var n,r,o,s="padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",l=a.getElementsByTagName("body")[0];l&&(n=a.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",l.appendChild(n).appendChild(d),d.innerHTML="<table><tr><td></td><td>t</td></tr></table>",o=d.getElementsByTagName("td"),o[0].style.cssText="padding:0;margin:0;border:0;display:none",p=0===o[0].offsetHeight,o[0].style.display="",o[1].style.display="none",t.reliableHiddenOffsets=p&&0===o[0].offsetHeight,d.innerHTML="",d.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",x.swap(l,null!=l.style.zoom?{zoom:1}:{},function(){t.boxSizing=4===d.offsetWidth}),e.getComputedStyle&&(t.pixelPosition="1%"!==(e.getComputedStyle(d,null)||{}).top,t.boxSizingReliable="4px"===(e.getComputedStyle(d,null)||{width:"4px"}).width,r=d.appendChild(a.createElement("div")),r.style.cssText=d.style.cssText=s,r.style.marginRight=r.style.width="0",d.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),typeof d.style.zoom!==i&&(d.innerHTML="",d.style.cssText=s+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=3===d.offsetWidth,d.style.display="block",d.innerHTML="<div></div>",d.firstChild.style.width="5px",t.shrinkWrapBlocks=3!==d.offsetWidth,t.inlineBlockNeedsLayout&&(l.style.zoom=1)),l.removeChild(n),n=d=o=r=null)}),n=s=l=u=r=o=null,t
      }({});var B=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,P=/([A-Z])/g;function R(e,n,r,i){if(x.acceptData(e)){var o,a,s=x.expando,l=e.nodeType,u=l?x.cache:e,c=l?e[s]:e[s]&&s;if(c&&u[c]&&(i||u[c].data)||r!==t||"string"!=typeof n)return c||(c=l?e[s]=p.pop()||x.guid++:s),u[c]||(u[c]=l?{}:{toJSON:x.noop}),("object"==typeof n||"function"==typeof n)&&(i?u[c]=x.extend(u[c],n):u[c].data=x.extend(u[c].data,n)),a=u[c],i||(a.data||(a.data={}),a=a.data),r!==t&&(a[x.camelCase(n)]=r),"string"==typeof n?(o=a[n],null==o&&(o=a[x.camelCase(n)])):o=a,o}}function W(e,t,n){if(x.acceptData(e)){var r,i,o=e.nodeType,a=o?x.cache:e,s=o?e[x.expando]:x.expando;if(a[s]){if(t&&(r=n?a[s]:a[s].data)){x.isArray(t)?t=t.concat(x.map(t,x.camelCase)):t in r?t=[t]:(t=x.camelCase(t),t=t in r?[t]:t.split(" ")),i=t.length;while(i--)delete r[t[i]];if(n?!I(r):!x.isEmptyObject(r))return}(n||(delete a[s].data,I(a[s])))&&(o?x.cleanData([e],!0):x.support.deleteExpando||a!=a.window?delete a[s]:a[s]=null)}}}x.extend({cache:{},noData:{applet:!0,embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(e){return e=e.nodeType?x.cache[e[x.expando]]:e[x.expando],!!e&&!I(e)},data:function(e,t,n){return R(e,t,n)},removeData:function(e,t){return W(e,t)},_data:function(e,t,n){return R(e,t,n,!0)},_removeData:function(e,t){return W(e,t,!0)},acceptData:function(e){if(e.nodeType&&1!==e.nodeType&&9!==e.nodeType)return!1;var t=e.nodeName&&x.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),x.fn.extend({data:function(e,n){var r,i,o=null,a=0,s=this[0];if(e===t){if(this.length&&(o=x.data(s),1===s.nodeType&&!x._data(s,"parsedAttrs"))){for(r=s.attributes;r.length>a;a++)i=r[a].name,0===i.indexOf("data-")&&(i=x.camelCase(i.slice(5)),$(s,i,o[i]));x._data(s,"parsedAttrs",!0)}return o}return"object"==typeof e?this.each(function(){x.data(this,e)}):arguments.length>1?this.each(function(){x.data(this,e,n)}):s?$(s,e,x.data(s,e)):null},removeData:function(e){return this.each(function(){x.removeData(this,e)})}});function $(e,n,r){if(r===t&&1===e.nodeType){var i="data-"+n.replace(P,"-$1").toLowerCase();if(r=e.getAttribute(i),"string"==typeof r){try{r="true"===r?!0:"false"===r?!1:"null"===r?null:+r+""===r?+r:B.test(r)?x.parseJSON(r):r}catch(o){}x.data(e,n,r)}else r=t}return r}function I(e){var t;for(t in e)if(("data"!==t||!x.isEmptyObject(e[t]))&&"toJSON"!==t)return!1;return!0}x.extend({queue:function(e,n,r){var i;return e?(n=(n||"fx")+"queue",i=x._data(e,n),r&&(!i||x.isArray(r)?i=x._data(e,n,x.makeArray(r)):i.push(r)),i||[]):t},dequeue:function(e,t){t=t||"fx";var n=x.queue(e,t),r=n.length,i=n.shift(),o=x._queueHooks(e,t),a=function(){x.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return x._data(e,n)||x._data(e,n,{empty:x.Callbacks("once memory").add(function(){x._removeData(e,t+"queue"),x._removeData(e,n)})})}}),x.fn.extend({queue:function(e,n){var r=2;return"string"!=typeof e&&(n=e,e="fx",r--),r>arguments.length?x.queue(this[0],e):n===t?this:this.each(function(){var t=x.queue(this,e,n);x._queueHooks(this,e),"fx"===e&&"inprogress"!==t[0]&&x.dequeue(this,e)})},dequeue:function(e){return this.each(function(){x.dequeue(this,e)})},delay:function(e,t){return e=x.fx?x.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,o=x.Deferred(),a=this,s=this.length,l=function(){--i||o.resolveWith(a,[a])};"string"!=typeof e&&(n=e,e=t),e=e||"fx";while(s--)r=x._data(a[s],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(l));return l(),o.promise(n)}});var z,X,U=/[\t\r\n\f]/g,V=/\r/g,Y=/^(?:input|select|textarea|button|object)$/i,J=/^(?:a|area)$/i,G=/^(?:checked|selected)$/i,Q=x.support.getSetAttribute,K=x.support.input;x.fn.extend({attr:function(e,t){return x.access(this,x.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){x.removeAttr(this,e)})},prop:function(e,t){return x.access(this,x.prop,e,t,arguments.length>1)},removeProp:function(e){return e=x.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,o,a=0,s=this.length,l="string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).addClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):" ")){o=0;while(i=t[o++])0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=x.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,a=0,s=this.length,l=0===arguments.length||"string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).removeClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):"")){o=0;while(i=t[o++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?x.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e;return"boolean"==typeof t&&"string"===n?t?this.addClass(e):this.removeClass(e):x.isFunction(e)?this.each(function(n){x(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n){var t,r=0,o=x(this),a=e.match(T)||[];while(t=a[r++])o.hasClass(t)?o.removeClass(t):o.addClass(t)}else(n===i||"boolean"===n)&&(this.className&&x._data(this,"__className__",this.className),this.className=this.className||e===!1?"":x._data(this,"__className__")||"")})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(U," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,o=this[0];{if(arguments.length)return i=x.isFunction(e),this.each(function(n){var o;1===this.nodeType&&(o=i?e.call(this,n,x(this).val()):e,null==o?o="":"number"==typeof o?o+="":x.isArray(o)&&(o=x.map(o,function(e){return null==e?"":e+""})),r=x.valHooks[this.type]||x.valHooks[this.nodeName.toLowerCase()],r&&"set"in r&&r.set(this,o,"value")!==t||(this.value=o))});if(o)return r=x.valHooks[o.type]||x.valHooks[o.nodeName.toLowerCase()],r&&"get"in r&&(n=r.get(o,"value"))!==t?n:(n=o.value,"string"==typeof n?n.replace(V,""):null==n?"":n)}}}),x.extend({valHooks:{option:{get:function(e){var t=x.find.attr(e,"value");return null!=t?t:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,a=o?null:[],s=o?i+1:r.length,l=0>i?s:o?i:0;for(;s>l;l++)if(n=r[l],!(!n.selected&&l!==i||(x.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&x.nodeName(n.parentNode,"optgroup"))){if(t=x(n).val(),o)return t;a.push(t)}return a},set:function(e,t){var n,r,i=e.options,o=x.makeArray(t),a=i.length;while(a--)r=i[a],(r.selected=x.inArray(x(r).val(),o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}},attr:function(e,n,r){var o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return typeof e.getAttribute===i?x.prop(e,n,r):(1===s&&x.isXMLDoc(e)||(n=n.toLowerCase(),o=x.attrHooks[n]||(x.expr.match.bool.test(n)?X:z)),r===t?o&&"get"in o&&null!==(a=o.get(e,n))?a:(a=x.find.attr(e,n),null==a?t:a):null!==r?o&&"set"in o&&(a=o.set(e,r,n))!==t?a:(e.setAttribute(n,r+""),r):(x.removeAttr(e,n),t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(T);if(o&&1===e.nodeType)while(n=o[i++])r=x.propFix[n]||n,x.expr.match.bool.test(n)?K&&Q||!G.test(n)?e[r]=!1:e[x.camelCase("default-"+n)]=e[r]=!1:x.attr(e,n,""),e.removeAttribute(Q?n:r)},attrHooks:{type:{set:function(e,t){if(!x.support.radioValue&&"radio"===t&&x.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{"for":"htmlFor","class":"className"},prop:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return a=1!==s||!x.isXMLDoc(e),a&&(n=x.propFix[n]||n,o=x.propHooks[n]),r!==t?o&&"set"in o&&(i=o.set(e,r,n))!==t?i:e[n]=r:o&&"get"in o&&null!==(i=o.get(e,n))?i:e[n]},propHooks:{tabIndex:{get:function(e){var t=x.find.attr(e,"tabindex");return t?parseInt(t,10):Y.test(e.nodeName)||J.test(e.nodeName)&&e.href?0:-1}}}}),X={set:function(e,t,n){return t===!1?x.removeAttr(e,n):K&&Q||!G.test(n)?e.setAttribute(!Q&&x.propFix[n]||n,n):e[x.camelCase("default-"+n)]=e[n]=!0,n}},x.each(x.expr.match.bool.source.match(/\w+/g),function(e,n){var r=x.expr.attrHandle[n]||x.find.attr;x.expr.attrHandle[n]=K&&Q||!G.test(n)?function(e,n,i){var o=x.expr.attrHandle[n],a=i?t:(x.expr.attrHandle[n]=t)!=r(e,n,i)?n.toLowerCase():null;return x.expr.attrHandle[n]=o,a}:function(e,n,r){return r?t:e[x.camelCase("default-"+n)]?n.toLowerCase():null}}),K&&Q||(x.attrHooks.value={set:function(e,n,r){return x.nodeName(e,"input")?(e.defaultValue=n,t):z&&z.set(e,n,r)}}),Q||(z={set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+="","value"===r||n===e.getAttribute(r)?n:t}},x.expr.attrHandle.id=x.expr.attrHandle.name=x.expr.attrHandle.coords=function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&""!==i.value?i.value:null},x.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&r.specified?r.value:t},set:z.set},x.attrHooks.contenteditable={set:function(e,t,n){z.set(e,""===t?!1:t,n)}},x.each(["width","height"],function(e,n){x.attrHooks[n]={set:function(e,r){return""===r?(e.setAttribute(n,"auto"),r):t}}})),x.support.hrefNormalized||x.each(["href","src"],function(e,t){x.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}}),x.support.style||(x.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+""}}),x.support.optSelected||(x.propHooks.selected={get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}}),x.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){x.propFix[this.toLowerCase()]=this}),x.support.enctype||(x.propFix.enctype="encoding"),x.each(["radio","checkbox"],function(){x.valHooks[this]={set:function(e,n){return x.isArray(n)?e.checked=x.inArray(x(e).val(),n)>=0:t}},x.support.checkOn||(x.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var Z=/^(?:input|select|textarea)$/i,et=/^key/,tt=/^(?:mouse|contextmenu)|click/,nt=/^(?:focusinfocus|focusoutblur)$/,rt=/^([^.]*)(?:\.(.+)|)$/;function it(){return!0}function ot(){return!1}function at(){try{return a.activeElement}catch(e){}}x.event={global:{},add:function(e,n,r,o,a){var s,l,u,c,p,f,d,h,g,m,y,v=x._data(e);if(v){r.handler&&(c=r,r=c.handler,a=c.selector),r.guid||(r.guid=x.guid++),(l=v.events)||(l=v.events={}),(f=v.handle)||(f=v.handle=function(e){return typeof x===i||e&&x.event.triggered===e.type?t:x.event.dispatch.apply(f.elem,arguments)},f.elem=e),n=(n||"").match(T)||[""],u=n.length;while(u--)s=rt.exec(n[u])||[],g=y=s[1],m=(s[2]||"").split(".").sort(),g&&(p=x.event.special[g]||{},g=(a?p.delegateType:p.bindType)||g,p=x.event.special[g]||{},d=x.extend({type:g,origType:y,data:o,handler:r,guid:r.guid,selector:a,needsContext:a&&x.expr.match.needsContext.test(a),namespace:m.join(".")},c),(h=l[g])||(h=l[g]=[],h.delegateCount=0,p.setup&&p.setup.call(e,o,m,f)!==!1||(e.addEventListener?e.addEventListener(g,f,!1):e.attachEvent&&e.attachEvent("on"+g,f))),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),a?h.splice(h.delegateCount++,0,d):h.push(d),x.event.global[g]=!0);e=null}},remove:function(e,t,n,r,i){var o,a,s,l,u,c,p,f,d,h,g,m=x.hasData(e)&&x._data(e);if(m&&(c=m.events)){t=(t||"").match(T)||[""],u=t.length;while(u--)if(s=rt.exec(t[u])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){p=x.event.special[d]||{},d=(r?p.delegateType:p.bindType)||d,f=c[d]||[],s=s[2]&&RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),l=o=f.length;while(o--)a=f[o],!i&&g!==a.origType||n&&n.guid!==a.guid||s&&!s.test(a.namespace)||r&&r!==a.selector&&("**"!==r||!a.selector)||(f.splice(o,1),a.selector&&f.delegateCount--,p.remove&&p.remove.call(e,a));l&&!f.length&&(p.teardown&&p.teardown.call(e,h,m.handle)!==!1||x.removeEvent(e,d,m.handle),delete c[d])}else for(d in c)x.event.remove(e,d+t[u],n,r,!0);x.isEmptyObject(c)&&(delete m.handle,x._removeData(e,"events"))}},trigger:function(n,r,i,o){var s,l,u,c,p,f,d,h=[i||a],g=v.call(n,"type")?n.type:n,m=v.call(n,"namespace")?n.namespace.split("."):[];if(u=f=i=i||a,3!==i.nodeType&&8!==i.nodeType&&!nt.test(g+x.event.triggered)&&(g.indexOf(".")>=0&&(m=g.split("."),g=m.shift(),m.sort()),l=0>g.indexOf(":")&&"on"+g,n=n[x.expando]?n:new x.Event(g,"object"==typeof n&&n),n.isTrigger=o?2:3,n.namespace=m.join("."),n.namespace_re=n.namespace?RegExp("(^|\\.)"+m.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,n.result=t,n.target||(n.target=i),r=null==r?[n]:x.makeArray(r,[n]),p=x.event.special[g]||{},o||!p.trigger||p.trigger.apply(i,r)!==!1)){if(!o&&!p.noBubble&&!x.isWindow(i)){for(c=p.delegateType||g,nt.test(c+g)||(u=u.parentNode);u;u=u.parentNode)h.push(u),f=u;f===(i.ownerDocument||a)&&h.push(f.defaultView||f.parentWindow||e)}d=0;while((u=h[d++])&&!n.isPropagationStopped())n.type=d>1?c:p.bindType||g,s=(x._data(u,"events")||{})[n.type]&&x._data(u,"handle"),s&&s.apply(u,r),s=l&&u[l],s&&x.acceptData(u)&&s.apply&&s.apply(u,r)===!1&&n.preventDefault();if(n.type=g,!o&&!n.isDefaultPrevented()&&(!p._default||p._default.apply(h.pop(),r)===!1)&&x.acceptData(i)&&l&&i[g]&&!x.isWindow(i)){f=i[l],f&&(i[l]=null),x.event.triggered=g;try{i[g]()}catch(y){}x.event.triggered=t,f&&(i[l]=f)}return n.result}},dispatch:function(e){e=x.event.fix(e);var n,r,i,o,a,s=[],l=g.call(arguments),u=(x._data(this,"events")||{})[e.type]||[],c=x.event.special[e.type]||{};if(l[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){s=x.event.handlers.call(this,e,u),n=0;while((o=s[n++])&&!e.isPropagationStopped()){e.currentTarget=o.elem,a=0;while((i=o.handlers[a++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(i.namespace))&&(e.handleObj=i,e.data=i.data,r=((x.event.special[i.origType]||{}).handle||i.handler).apply(o.elem,l),r!==t&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,n){var r,i,o,a,s=[],l=n.delegateCount,u=e.target;if(l&&u.nodeType&&(!e.button||"click"!==e.type))for(;u!=this;u=u.parentNode||this)if(1===u.nodeType&&(u.disabled!==!0||"click"!==e.type)){for(o=[],a=0;l>a;a++)i=n[a],r=i.selector+" ",o[r]===t&&(o[r]=i.needsContext?x(r,this).index(u)>=0:x.find(r,this,null,[u]).length),o[r]&&o.push(i);o.length&&s.push({elem:u,handlers:o})}return n.length>l&&s.push({elem:this,handlers:n.slice(l)}),s},fix:function(e){if(e[x.expando])return e;var t,n,r,i=e.type,o=e,s=this.fixHooks[i];s||(this.fixHooks[i]=s=tt.test(i)?this.mouseHooks:et.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new x.Event(o),t=r.length;while(t--)n=r[t],e[n]=o[n];return e.target||(e.target=o.srcElement||a),3===e.target.nodeType&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,o):e},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,i,o,s=n.button,l=n.fromElement;return null==e.pageX&&null!=n.clientX&&(i=e.target.ownerDocument||a,o=i.documentElement,r=i.body,e.pageX=n.clientX+(o&&o.scrollLeft||r&&r.scrollLeft||0)-(o&&o.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(o&&o.scrollTop||r&&r.scrollTop||0)-(o&&o.clientTop||r&&r.clientTop||0)),!e.relatedTarget&&l&&(e.relatedTarget=l===e.target?n.toElement:l),e.which||s===t||(e.which=1&s?1:2&s?3:4&s?2:0),e}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==at()&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:"focusin"},blur:{trigger:function(){return this===at()&&this.blur?(this.blur(),!1):t},delegateType:"focusout"},click:{trigger:function(){return x.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):t},_default:function(e){return x.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=x.extend(new x.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?x.event.trigger(i,null,t):x.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},x.removeEvent=a.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]===i&&(e[r]=null),e.detachEvent(r,n))},x.Event=function(e,n){return this instanceof x.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?it:ot):this.type=e,n&&x.extend(this,n),this.timeStamp=e&&e.timeStamp||x.now(),this[x.expando]=!0,t):new x.Event(e,n)},x.Event.prototype={isDefaultPrevented:ot,isPropagationStopped:ot,isImmediatePropagationStopped:ot,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=it,e&&(e.preventDefault?e.preventDefault():e.returnValue=!1)},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=it,e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=it,this.stopPropagation()}},x.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){x.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return(!i||i!==r&&!x.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),x.support.submitBubbles||(x.event.special.submit={setup:function(){return x.nodeName(this,"form")?!1:(x.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=x.nodeName(n,"input")||x.nodeName(n,"button")?n.form:t;r&&!x._data(r,"submitBubbles")&&(x.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),x._data(r,"submitBubbles",!0))}),t)},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&x.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){return x.nodeName(this,"form")?!1:(x.event.remove(this,"._submit"),t)}}),x.support.changeBubbles||(x.event.special.change={setup:function(){return Z.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(x.event.add(this,"propertychange._change",function(e){"checked"===e.originalEvent.propertyName&&(this._just_changed=!0)}),x.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),x.event.simulate("change",this,e,!0)})),!1):(x.event.add(this,"beforeactivate._change",function(e){var t=e.target;Z.test(t.nodeName)&&!x._data(t,"changeBubbles")&&(x.event.add(t,"change._change",function(e){!this.parentNode||e.isSimulated||e.isTrigger||x.event.simulate("change",this.parentNode,e,!0)}),x._data(t,"changeBubbles",!0))}),t)},handle:function(e){var n=e.target;return this!==n||e.isSimulated||e.isTrigger||"radio"!==n.type&&"checkbox"!==n.type?e.handleObj.handler.apply(this,arguments):t},teardown:function(){return x.event.remove(this,"._change"),!Z.test(this.nodeName)}}),x.support.focusinBubbles||x.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){x.event.simulate(t,e.target,x.event.fix(e),!0)};x.event.special[t]={setup:function(){0===n++&&a.addEventListener(e,r,!0)},teardown:function(){0===--n&&a.removeEventListener(e,r,!0)}}}),x.fn.extend({on:function(e,n,r,i,o){var a,s;if("object"==typeof e){"string"!=typeof n&&(r=r||n,n=t);for(a in e)this.on(a,n,r,e[a],o);return this}if(null==r&&null==i?(i=n,r=n=t):null==i&&("string"==typeof n?(i=r,r=t):(i=r,r=n,n=t)),i===!1)i=ot;else if(!i)return this;return 1===o&&(s=i,i=function(e){return x().off(e),s.apply(this,arguments)},i.guid=s.guid||(s.guid=x.guid++)),this.each(function(){x.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,o;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,x(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if("object"==typeof e){for(o in e)this.off(o,n,e[o]);return this}return(n===!1||"function"==typeof n)&&(r=n,n=t),r===!1&&(r=ot),this.each(function(){x.event.remove(this,e,r,n)})},trigger:function(e,t){return this.each(function(){x.event.trigger(e,t,this)})},triggerHandler:function(e,n){var r=this[0];return r?x.event.trigger(e,n,r,!0):t}});var st=/^.[^:#\[\.,]*$/,lt=/^(?:parents|prev(?:Until|All))/,ut=x.expr.match.needsContext,ct={children:!0,contents:!0,next:!0,prev:!0};x.fn.extend({find:function(e){var t,n=[],r=this,i=r.length;if("string"!=typeof e)return this.pushStack(x(e).filter(function(){for(t=0;i>t;t++)if(x.contains(r[t],this))return!0}));for(t=0;i>t;t++)x.find(e,r[t],n);return n=this.pushStack(i>1?x.unique(n):n),n.selector=this.selector?this.selector+" "+e:e,n},has:function(e){var t,n=x(e,this),r=n.length;return this.filter(function(){for(t=0;r>t;t++)if(x.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e||[],!0))},filter:function(e){return this.pushStack(ft(this,e||[],!1))},is:function(e){return!!ft(this,"string"==typeof e&&ut.test(e)?x(e):e||[],!1).length},closest:function(e,t){var n,r=0,i=this.length,o=[],a=ut.test(e)||"string"!=typeof e?x(e,t||this.context):0;for(;i>r;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(11>n.nodeType&&(a?a.index(n)>-1:1===n.nodeType&&x.find.matchesSelector(n,e))){n=o.push(n);break}return this.pushStack(o.length>1?x.unique(o):o)},index:function(e){return e?"string"==typeof e?x.inArray(this[0],x(e)):x.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?x(e,t):x.makeArray(e&&e.nodeType?[e]:e),r=x.merge(this.get(),n);return this.pushStack(x.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}});function pt(e,t){do e=e[t];while(e&&1!==e.nodeType);return e}x.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return x.dir(e,"parentNode")},parentsUntil:function(e,t,n){return x.dir(e,"parentNode",n)},next:function(e){return pt(e,"nextSibling")},prev:function(e){return pt(e,"previousSibling")},nextAll:function(e){return x.dir(e,"nextSibling")},prevAll:function(e){return x.dir(e,"previousSibling")},nextUntil:function(e,t,n){return x.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return x.dir(e,"previousSibling",n)},siblings:function(e){return x.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return x.sibling(e.firstChild)},contents:function(e){return x.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:x.merge([],e.childNodes)}},function(e,t){x.fn[e]=function(n,r){var i=x.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=x.filter(r,i)),this.length>1&&(ct[e]||(i=x.unique(i)),lt.test(e)&&(i=i.reverse())),this.pushStack(i)}}),x.extend({filter:function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?x.find.matchesSelector(r,e)?[r]:[]:x.find.matches(e,x.grep(t,function(e){return 1===e.nodeType}))},dir:function(e,n,r){var i=[],o=e[n];while(o&&9!==o.nodeType&&(r===t||1!==o.nodeType||!x(o).is(r)))1===o.nodeType&&i.push(o),o=o[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function ft(e,t,n){if(x.isFunction(t))return x.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return x.grep(e,function(e){return e===t!==n});if("string"==typeof t){if(st.test(t))return x.filter(t,e,n);t=x.filter(t,e)}return x.grep(e,function(e){return x.inArray(e,t)>=0!==n})}function dt(e){var t=ht.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}var ht="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",gt=/ jQuery\d+="(?:null|\d+)"/g,mt=RegExp("<(?:"+ht+")[\\s/>]","i"),yt=/^\s+/,vt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bt=/<([\w:]+)/,xt=/<tbody/i,wt=/<|&#?\w+;/,Tt=/<(?:script|style|link)/i,Ct=/^(?:checkbox|radio)$/i,Nt=/checked\s*(?:[^=]|=\s*.checked.)/i,kt=/^$|\/(?:java|ecma)script/i,Et=/^true\/(.*)/,St=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,At={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:x.support.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},jt=dt(a),Dt=jt.appendChild(a.createElement("div"));At.optgroup=At.option,At.tbody=At.tfoot=At.colgroup=At.caption=At.thead,At.th=At.td,x.fn.extend({text:function(e){return x.access(this,function(e){return e===t?x.text(this):this.empty().append((this[0]&&this[0].ownerDocument||a).createTextNode(e))},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=e?x.filter(e,this):this,i=0;for(;null!=(n=r[i]);i++)t||1!==n.nodeType||x.cleanData(Ft(n)),n.parentNode&&(t&&x.contains(n.ownerDocument,n)&&_t(Ft(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++){1===e.nodeType&&x.cleanData(Ft(e,!1));while(e.firstChild)e.removeChild(e.firstChild);e.options&&x.nodeName(e,"select")&&(e.options.length=0)}return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return x.clone(this,e,t)})},html:function(e){return x.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return 1===n.nodeType?n.innerHTML.replace(gt,""):t;if(!("string"!=typeof e||Tt.test(e)||!x.support.htmlSerialize&&mt.test(e)||!x.support.leadingWhitespace&&yt.test(e)||At[(bt.exec(e)||["",""])[1].toLowerCase()])){e=e.replace(vt,"<$1></$2>");try{for(;i>r;r++)n=this[r]||{},1===n.nodeType&&(x.cleanData(Ft(n,!1)),n.innerHTML=e);n=0}catch(o){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=x.map(this,function(e){return[e.nextSibling,e.parentNode]}),t=0;return this.domManip(arguments,function(n){var r=e[t++],i=e[t++];i&&(r&&r.parentNode!==i&&(r=this.nextSibling),x(this).remove(),i.insertBefore(n,r))},!0),t?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t,n){e=d.apply([],e);var r,i,o,a,s,l,u=0,c=this.length,p=this,f=c-1,h=e[0],g=x.isFunction(h);if(g||!(1>=c||"string"!=typeof h||x.support.checkClone)&&Nt.test(h))return this.each(function(r){var i=p.eq(r);g&&(e[0]=h.call(this,r,i.html())),i.domManip(e,t,n)});if(c&&(l=x.buildFragment(e,this[0].ownerDocument,!1,!n&&this),r=l.firstChild,1===l.childNodes.length&&(l=r),r)){for(a=x.map(Ft(l,"script"),Ht),o=a.length;c>u;u++)i=l,u!==f&&(i=x.clone(i,!0,!0),o&&x.merge(a,Ft(i,"script"))),t.call(this[u],i,u);if(o)for(s=a[a.length-1].ownerDocument,x.map(a,qt),u=0;o>u;u++)i=a[u],kt.test(i.type||"")&&!x._data(i,"globalEval")&&x.contains(s,i)&&(i.src?x._evalUrl(i.src):x.globalEval((i.text||i.textContent||i.innerHTML||"").replace(St,"")));l=r=null}return this}});function Lt(e,t){return x.nodeName(e,"table")&&x.nodeName(1===t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function Ht(e){return e.type=(null!==x.find.attr(e,"type"))+"/"+e.type,e}function qt(e){var t=Et.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function _t(e,t){var n,r=0;for(;null!=(n=e[r]);r++)x._data(n,"globalEval",!t||x._data(t[r],"globalEval"))}function Mt(e,t){if(1===t.nodeType&&x.hasData(e)){var n,r,i,o=x._data(e),a=x._data(t,o),s=o.events;if(s){delete a.handle,a.events={};for(n in s)for(r=0,i=s[n].length;i>r;r++)x.event.add(t,n,s[n][r])}a.data&&(a.data=x.extend({},a.data))}}function Ot(e,t){var n,r,i;if(1===t.nodeType){if(n=t.nodeName.toLowerCase(),!x.support.noCloneEvent&&t[x.expando]){i=x._data(t);for(r in i.events)x.removeEvent(t,r,i.handle);t.removeAttribute(x.expando)}"script"===n&&t.text!==e.text?(Ht(t).text=e.text,qt(t)):"object"===n?(t.parentNode&&(t.outerHTML=e.outerHTML),x.support.html5Clone&&e.innerHTML&&!x.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):"input"===n&&Ct.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):"option"===n?t.defaultSelected=t.selected=e.defaultSelected:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}}x.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){x.fn[e]=function(e){var n,r=0,i=[],o=x(e),a=o.length-1;for(;a>=r;r++)n=r===a?this:this.clone(!0),x(o[r])[t](n),h.apply(i,n.get());return this.pushStack(i)}});function Ft(e,n){var r,o,a=0,s=typeof e.getElementsByTagName!==i?e.getElementsByTagName(n||"*"):typeof e.querySelectorAll!==i?e.querySelectorAll(n||"*"):t;if(!s)for(s=[],r=e.childNodes||e;null!=(o=r[a]);a++)!n||x.nodeName(o,n)?s.push(o):x.merge(s,Ft(o,n));return n===t||n&&x.nodeName(e,n)?x.merge([e],s):s}function Bt(e){Ct.test(e.type)&&(e.defaultChecked=e.checked)}x.extend({clone:function(e,t,n){var r,i,o,a,s,l=x.contains(e.ownerDocument,e);if(x.support.html5Clone||x.isXMLDoc(e)||!mt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(Dt.innerHTML=e.outerHTML,Dt.removeChild(o=Dt.firstChild)),!(x.support.noCloneEvent&&x.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||x.isXMLDoc(e)))for(r=Ft(o),s=Ft(e),a=0;null!=(i=s[a]);++a)r[a]&&Ot(i,r[a]);if(t)if(n)for(s=s||Ft(e),r=r||Ft(o),a=0;null!=(i=s[a]);a++)Mt(i,r[a]);else Mt(e,o);return r=Ft(o,"script"),r.length>0&&_t(r,!l&&Ft(e,"script")),r=s=i=null,o},buildFragment:function(e,t,n,r){var i,o,a,s,l,u,c,p=e.length,f=dt(t),d=[],h=0;for(;p>h;h++)if(o=e[h],o||0===o)if("object"===x.type(o))x.merge(d,o.nodeType?[o]:o);else if(wt.test(o)){s=s||f.appendChild(t.createElement("div")),l=(bt.exec(o)||["",""])[1].toLowerCase(),c=At[l]||At._default,s.innerHTML=c[1]+o.replace(vt,"<$1></$2>")+c[2],i=c[0];while(i--)s=s.lastChild;if(!x.support.leadingWhitespace&&yt.test(o)&&d.push(t.createTextNode(yt.exec(o)[0])),!x.support.tbody){o="table"!==l||xt.test(o)?"<table>"!==c[1]||xt.test(o)?0:s:s.firstChild,i=o&&o.childNodes.length;while(i--)x.nodeName(u=o.childNodes[i],"tbody")&&!u.childNodes.length&&o.removeChild(u)}x.merge(d,s.childNodes),s.textContent="";while(s.firstChild)s.removeChild(s.firstChild);s=f.lastChild}else d.push(t.createTextNode(o));s&&f.removeChild(s),x.support.appendChecked||x.grep(Ft(d,"input"),Bt),h=0;while(o=d[h++])if((!r||-1===x.inArray(o,r))&&(a=x.contains(o.ownerDocument,o),s=Ft(f.appendChild(o),"script"),a&&_t(s),n)){i=0;while(o=s[i++])kt.test(o.type||"")&&n.push(o)}return s=null,f},cleanData:function(e,t){var n,r,o,a,s=0,l=x.expando,u=x.cache,c=x.support.deleteExpando,f=x.event.special;for(;null!=(n=e[s]);s++)if((t||x.acceptData(n))&&(o=n[l],a=o&&u[o])){if(a.events)for(r in a.events)f[r]?x.event.remove(n,r):x.removeEvent(n,r,a.handle);
      u[o]&&(delete u[o],c?delete n[l]:typeof n.removeAttribute!==i?n.removeAttribute(l):n[l]=null,p.push(o))}},_evalUrl:function(e){return x.ajax({url:e,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})}}),x.fn.extend({wrapAll:function(e){if(x.isFunction(e))return this.each(function(t){x(this).wrapAll(e.call(this,t))});if(this[0]){var t=x(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&1===e.firstChild.nodeType)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return x.isFunction(e)?this.each(function(t){x(this).wrapInner(e.call(this,t))}):this.each(function(){var t=x(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=x.isFunction(e);return this.each(function(n){x(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){x.nodeName(this,"body")||x(this).replaceWith(this.childNodes)}).end()}});var Pt,Rt,Wt,$t=/alpha\([^)]*\)/i,It=/opacity\s*=\s*([^)]*)/,zt=/^(top|right|bottom|left)$/,Xt=/^(none|table(?!-c[ea]).+)/,Ut=/^margin/,Vt=RegExp("^("+w+")(.*)$","i"),Yt=RegExp("^("+w+")(?!px)[a-z%]+$","i"),Jt=RegExp("^([+-])=("+w+")","i"),Gt={BODY:"block"},Qt={position:"absolute",visibility:"hidden",display:"block"},Kt={letterSpacing:0,fontWeight:400},Zt=["Top","Right","Bottom","Left"],en=["Webkit","O","Moz","ms"];function tn(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=en.length;while(i--)if(t=en[i]+n,t in e)return t;return r}function nn(e,t){return e=t||e,"none"===x.css(e,"display")||!x.contains(e.ownerDocument,e)}function rn(e,t){var n,r,i,o=[],a=0,s=e.length;for(;s>a;a++)r=e[a],r.style&&(o[a]=x._data(r,"olddisplay"),n=r.style.display,t?(o[a]||"none"!==n||(r.style.display=""),""===r.style.display&&nn(r)&&(o[a]=x._data(r,"olddisplay",ln(r.nodeName)))):o[a]||(i=nn(r),(n&&"none"!==n||!i)&&x._data(r,"olddisplay",i?n:x.css(r,"display"))));for(a=0;s>a;a++)r=e[a],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[a]||"":"none"));return e}x.fn.extend({css:function(e,n){return x.access(this,function(e,n,r){var i,o,a={},s=0;if(x.isArray(n)){for(o=Rt(e),i=n.length;i>s;s++)a[n[s]]=x.css(e,n[s],!1,o);return a}return r!==t?x.style(e,n,r):x.css(e,n)},e,n,arguments.length>1)},show:function(){return rn(this,!0)},hide:function(){return rn(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){nn(this)?x(this).show():x(this).hide()})}}),x.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Wt(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":x.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var o,a,s,l=x.camelCase(n),u=e.style;if(n=x.cssProps[l]||(x.cssProps[l]=tn(u,l)),s=x.cssHooks[n]||x.cssHooks[l],r===t)return s&&"get"in s&&(o=s.get(e,!1,i))!==t?o:u[n];if(a=typeof r,"string"===a&&(o=Jt.exec(r))&&(r=(o[1]+1)*o[2]+parseFloat(x.css(e,n)),a="number"),!(null==r||"number"===a&&isNaN(r)||("number"!==a||x.cssNumber[l]||(r+="px"),x.support.clearCloneStyle||""!==r||0!==n.indexOf("background")||(u[n]="inherit"),s&&"set"in s&&(r=s.set(e,r,i))===t)))try{u[n]=r}catch(c){}}},css:function(e,n,r,i){var o,a,s,l=x.camelCase(n);return n=x.cssProps[l]||(x.cssProps[l]=tn(e.style,l)),s=x.cssHooks[n]||x.cssHooks[l],s&&"get"in s&&(a=s.get(e,!0,r)),a===t&&(a=Wt(e,n,i)),"normal"===a&&n in Kt&&(a=Kt[n]),""===r||r?(o=parseFloat(a),r===!0||x.isNumeric(o)?o||0:a):a}}),e.getComputedStyle?(Rt=function(t){return e.getComputedStyle(t,null)},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s.getPropertyValue(n)||s[n]:t,u=e.style;return s&&(""!==l||x.contains(e.ownerDocument,e)||(l=x.style(e,n)),Yt.test(l)&&Ut.test(n)&&(i=u.width,o=u.minWidth,a=u.maxWidth,u.minWidth=u.maxWidth=u.width=l,l=s.width,u.width=i,u.minWidth=o,u.maxWidth=a)),l}):a.documentElement.currentStyle&&(Rt=function(e){return e.currentStyle},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s[n]:t,u=e.style;return null==l&&u&&u[n]&&(l=u[n]),Yt.test(l)&&!zt.test(n)&&(i=u.left,o=e.runtimeStyle,a=o&&o.left,a&&(o.left=e.currentStyle.left),u.left="fontSize"===n?"1em":l,l=u.pixelLeft+"px",u.left=i,a&&(o.left=a)),""===l?"auto":l});function on(e,t,n){var r=Vt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function an(e,t,n,r,i){var o=n===(r?"border":"content")?4:"width"===t?1:0,a=0;for(;4>o;o+=2)"margin"===n&&(a+=x.css(e,n+Zt[o],!0,i)),r?("content"===n&&(a-=x.css(e,"padding"+Zt[o],!0,i)),"margin"!==n&&(a-=x.css(e,"border"+Zt[o]+"Width",!0,i))):(a+=x.css(e,"padding"+Zt[o],!0,i),"padding"!==n&&(a+=x.css(e,"border"+Zt[o]+"Width",!0,i)));return a}function sn(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=Rt(e),a=x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=Wt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Yt.test(i))return i;r=a&&(x.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+an(e,t,n||(a?"border":"content"),r,o)+"px"}function ln(e){var t=a,n=Gt[e];return n||(n=un(e,t),"none"!==n&&n||(Pt=(Pt||x("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(Pt[0].contentWindow||Pt[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=un(e,t),Pt.detach()),Gt[e]=n),n}function un(e,t){var n=x(t.createElement(e)).appendTo(t.body),r=x.css(n[0],"display");return n.remove(),r}x.each(["height","width"],function(e,n){x.cssHooks[n]={get:function(e,r,i){return r?0===e.offsetWidth&&Xt.test(x.css(e,"display"))?x.swap(e,Qt,function(){return sn(e,n,i)}):sn(e,n,i):t},set:function(e,t,r){var i=r&&Rt(e);return on(e,t,r?an(e,n,r,x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,i),i):0)}}}),x.support.opacity||(x.cssHooks.opacity={get:function(e,t){return It.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=x.isNumeric(t)?"alpha(opacity="+100*t+")":"",o=r&&r.filter||n.filter||"";n.zoom=1,(t>=1||""===t)&&""===x.trim(o.replace($t,""))&&n.removeAttribute&&(n.removeAttribute("filter"),""===t||r&&!r.filter)||(n.filter=$t.test(o)?o.replace($t,i):o+" "+i)}}),x(function(){x.support.reliableMarginRight||(x.cssHooks.marginRight={get:function(e,n){return n?x.swap(e,{display:"inline-block"},Wt,[e,"marginRight"]):t}}),!x.support.pixelPosition&&x.fn.position&&x.each(["top","left"],function(e,n){x.cssHooks[n]={get:function(e,r){return r?(r=Wt(e,n),Yt.test(r)?x(e).position()[n]+"px":r):t}}})}),x.expr&&x.expr.filters&&(x.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight||!x.support.reliableHiddenOffsets&&"none"===(e.style&&e.style.display||x.css(e,"display"))},x.expr.filters.visible=function(e){return!x.expr.filters.hidden(e)}),x.each({margin:"",padding:"",border:"Width"},function(e,t){x.cssHooks[e+t]={expand:function(n){var r=0,i={},o="string"==typeof n?n.split(" "):[n];for(;4>r;r++)i[e+Zt[r]+t]=o[r]||o[r-2]||o[0];return i}},Ut.test(e)||(x.cssHooks[e+t].set=on)});var cn=/%20/g,pn=/\[\]$/,fn=/\r?\n/g,dn=/^(?:submit|button|image|reset|file)$/i,hn=/^(?:input|select|textarea|keygen)/i;x.fn.extend({serialize:function(){return x.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=x.prop(this,"elements");return e?x.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!x(this).is(":disabled")&&hn.test(this.nodeName)&&!dn.test(e)&&(this.checked||!Ct.test(e))}).map(function(e,t){var n=x(this).val();return null==n?null:x.isArray(n)?x.map(n,function(e){return{name:t.name,value:e.replace(fn,"\r\n")}}):{name:t.name,value:n.replace(fn,"\r\n")}}).get()}}),x.param=function(e,n){var r,i=[],o=function(e,t){t=x.isFunction(t)?t():null==t?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(n===t&&(n=x.ajaxSettings&&x.ajaxSettings.traditional),x.isArray(e)||e.jquery&&!x.isPlainObject(e))x.each(e,function(){o(this.name,this.value)});else for(r in e)gn(r,e[r],n,o);return i.join("&").replace(cn,"+")};function gn(e,t,n,r){var i;if(x.isArray(t))x.each(t,function(t,i){n||pn.test(e)?r(e,i):gn(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==x.type(t))r(e,t);else for(i in t)gn(e+"["+i+"]",t[i],n,r)}x.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){x.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),x.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}});var mn,yn,vn=x.now(),bn=/\?/,xn=/#.*$/,wn=/([?&])_=[^&]*/,Tn=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Cn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Nn=/^(?:GET|HEAD)$/,kn=/^\/\//,En=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,Sn=x.fn.load,An={},jn={},Dn="*/".concat("*");try{yn=o.href}catch(Ln){yn=a.createElement("a"),yn.href="",yn=yn.href}mn=En.exec(yn.toLowerCase())||[];function Hn(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(T)||[];if(x.isFunction(n))while(r=o[i++])"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function qn(e,n,r,i){var o={},a=e===jn;function s(l){var u;return o[l]=!0,x.each(e[l]||[],function(e,l){var c=l(n,r,i);return"string"!=typeof c||a||o[c]?a?!(u=c):t:(n.dataTypes.unshift(c),s(c),!1)}),u}return s(n.dataTypes[0])||!o["*"]&&s("*")}function _n(e,n){var r,i,o=x.ajaxSettings.flatOptions||{};for(i in n)n[i]!==t&&((o[i]?e:r||(r={}))[i]=n[i]);return r&&x.extend(!0,e,r),e}x.fn.load=function(e,n,r){if("string"!=typeof e&&Sn)return Sn.apply(this,arguments);var i,o,a,s=this,l=e.indexOf(" ");return l>=0&&(i=e.slice(l,e.length),e=e.slice(0,l)),x.isFunction(n)?(r=n,n=t):n&&"object"==typeof n&&(a="POST"),s.length>0&&x.ajax({url:e,type:a,dataType:"html",data:n}).done(function(e){o=arguments,s.html(i?x("<div>").append(x.parseHTML(e)).find(i):e)}).complete(r&&function(e,t){s.each(r,o||[e.responseText,t,e])}),this},x.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){x.fn[t]=function(e){return this.on(t,e)}}),x.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:yn,type:"GET",isLocal:Cn.test(mn[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Dn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":x.parseJSON,"text xml":x.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?_n(_n(e,x.ajaxSettings),t):_n(x.ajaxSettings,e)},ajaxPrefilter:Hn(An),ajaxTransport:Hn(jn),ajax:function(e,n){"object"==typeof e&&(n=e,e=t),n=n||{};var r,i,o,a,s,l,u,c,p=x.ajaxSetup({},n),f=p.context||p,d=p.context&&(f.nodeType||f.jquery)?x(f):x.event,h=x.Deferred(),g=x.Callbacks("once memory"),m=p.statusCode||{},y={},v={},b=0,w="canceled",C={readyState:0,getResponseHeader:function(e){var t;if(2===b){if(!c){c={};while(t=Tn.exec(a))c[t[1].toLowerCase()]=t[2]}t=c[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===b?a:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return b||(e=v[n]=v[n]||e,y[e]=t),this},overrideMimeType:function(e){return b||(p.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>b)for(t in e)m[t]=[m[t],e[t]];else C.always(e[C.status]);return this},abort:function(e){var t=e||w;return u&&u.abort(t),k(0,t),this}};if(h.promise(C).complete=g.add,C.success=C.done,C.error=C.fail,p.url=((e||p.url||yn)+"").replace(xn,"").replace(kn,mn[1]+"//"),p.type=n.method||n.type||p.method||p.type,p.dataTypes=x.trim(p.dataType||"*").toLowerCase().match(T)||[""],null==p.crossDomain&&(r=En.exec(p.url.toLowerCase()),p.crossDomain=!(!r||r[1]===mn[1]&&r[2]===mn[2]&&(r[3]||("http:"===r[1]?"80":"443"))===(mn[3]||("http:"===mn[1]?"80":"443")))),p.data&&p.processData&&"string"!=typeof p.data&&(p.data=x.param(p.data,p.traditional)),qn(An,p,n,C),2===b)return C;l=p.global,l&&0===x.active++&&x.event.trigger("ajaxStart"),p.type=p.type.toUpperCase(),p.hasContent=!Nn.test(p.type),o=p.url,p.hasContent||(p.data&&(o=p.url+=(bn.test(o)?"&":"?")+p.data,delete p.data),p.cache===!1&&(p.url=wn.test(o)?o.replace(wn,"$1_="+vn++):o+(bn.test(o)?"&":"?")+"_="+vn++)),p.ifModified&&(x.lastModified[o]&&C.setRequestHeader("If-Modified-Since",x.lastModified[o]),x.etag[o]&&C.setRequestHeader("If-None-Match",x.etag[o])),(p.data&&p.hasContent&&p.contentType!==!1||n.contentType)&&C.setRequestHeader("Content-Type",p.contentType),C.setRequestHeader("Accept",p.dataTypes[0]&&p.accepts[p.dataTypes[0]]?p.accepts[p.dataTypes[0]]+("*"!==p.dataTypes[0]?", "+Dn+"; q=0.01":""):p.accepts["*"]);for(i in p.headers)C.setRequestHeader(i,p.headers[i]);if(p.beforeSend&&(p.beforeSend.call(f,C,p)===!1||2===b))return C.abort();w="abort";for(i in{success:1,error:1,complete:1})C[i](p[i]);if(u=qn(jn,p,n,C)){C.readyState=1,l&&d.trigger("ajaxSend",[C,p]),p.async&&p.timeout>0&&(s=setTimeout(function(){C.abort("timeout")},p.timeout));try{b=1,u.send(y,k)}catch(N){if(!(2>b))throw N;k(-1,N)}}else k(-1,"No Transport");function k(e,n,r,i){var c,y,v,w,T,N=n;2!==b&&(b=2,s&&clearTimeout(s),u=t,a=i||"",C.readyState=e>0?4:0,c=e>=200&&300>e||304===e,r&&(w=Mn(p,C,r)),w=On(p,w,C,c),c?(p.ifModified&&(T=C.getResponseHeader("Last-Modified"),T&&(x.lastModified[o]=T),T=C.getResponseHeader("etag"),T&&(x.etag[o]=T)),204===e||"HEAD"===p.type?N="nocontent":304===e?N="notmodified":(N=w.state,y=w.data,v=w.error,c=!v)):(v=N,(e||!N)&&(N="error",0>e&&(e=0))),C.status=e,C.statusText=(n||N)+"",c?h.resolveWith(f,[y,N,C]):h.rejectWith(f,[C,N,v]),C.statusCode(m),m=t,l&&d.trigger(c?"ajaxSuccess":"ajaxError",[C,p,c?y:v]),g.fireWith(f,[C,N]),l&&(d.trigger("ajaxComplete",[C,p]),--x.active||x.event.trigger("ajaxStop")))}return C},getJSON:function(e,t,n){return x.get(e,t,n,"json")},getScript:function(e,n){return x.get(e,t,n,"script")}}),x.each(["get","post"],function(e,n){x[n]=function(e,r,i,o){return x.isFunction(r)&&(o=o||i,i=r,r=t),x.ajax({url:e,type:n,dataType:o,data:r,success:i})}});function Mn(e,n,r){var i,o,a,s,l=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),o===t&&(o=e.mimeType||n.getResponseHeader("Content-Type"));if(o)for(s in l)if(l[s]&&l[s].test(o)){u.unshift(s);break}if(u[0]in r)a=u[0];else{for(s in r){if(!u[0]||e.converters[s+" "+u[0]]){a=s;break}i||(i=s)}a=a||i}return a?(a!==u[0]&&u.unshift(a),r[a]):t}function On(e,t,n,r){var i,o,a,s,l,u={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)u[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!l&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),l=o,o=c.shift())if("*"===o)o=l;else if("*"!==l&&l!==o){if(a=u[l+" "+o]||u["* "+o],!a)for(i in u)if(s=i.split(" "),s[1]===o&&(a=u[l+" "+s[0]]||u["* "+s[0]])){a===!0?a=u[i]:u[i]!==!0&&(o=s[0],c.unshift(s[1]));break}if(a!==!0)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(p){return{state:"parsererror",error:a?p:"No conversion from "+l+" to "+o}}}return{state:"success",data:t}}x.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return x.globalEval(e),e}}}),x.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),x.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=a.head||x("head")[0]||a.documentElement;return{send:function(t,i){n=a.createElement("script"),n.async=!0,e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,t){(t||!n.readyState||/loaded|complete/.test(n.readyState))&&(n.onload=n.onreadystatechange=null,n.parentNode&&n.parentNode.removeChild(n),n=null,t||i(200,"success"))},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(t,!0)}}}});var Fn=[],Bn=/(=)\?(?=&|$)|\?\?/;x.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Fn.pop()||x.expando+"_"+vn++;return this[e]=!0,e}}),x.ajaxPrefilter("json jsonp",function(n,r,i){var o,a,s,l=n.jsonp!==!1&&(Bn.test(n.url)?"url":"string"==typeof n.data&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Bn.test(n.data)&&"data");return l||"jsonp"===n.dataTypes[0]?(o=n.jsonpCallback=x.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,l?n[l]=n[l].replace(Bn,"$1"+o):n.jsonp!==!1&&(n.url+=(bn.test(n.url)?"&":"?")+n.jsonp+"="+o),n.converters["script json"]=function(){return s||x.error(o+" was not called"),s[0]},n.dataTypes[0]="json",a=e[o],e[o]=function(){s=arguments},i.always(function(){e[o]=a,n[o]&&(n.jsonpCallback=r.jsonpCallback,Fn.push(o)),s&&x.isFunction(a)&&a(s[0]),s=a=t}),"script"):t});var Pn,Rn,Wn=0,$n=e.ActiveXObject&&function(){var e;for(e in Pn)Pn[e](t,!0)};function In(){try{return new e.XMLHttpRequest}catch(t){}}function zn(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}x.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&In()||zn()}:In,Rn=x.ajaxSettings.xhr(),x.support.cors=!!Rn&&"withCredentials"in Rn,Rn=x.support.ajax=!!Rn,Rn&&x.ajaxTransport(function(n){if(!n.crossDomain||x.support.cors){var r;return{send:function(i,o){var a,s,l=n.xhr();if(n.username?l.open(n.type,n.url,n.async,n.username,n.password):l.open(n.type,n.url,n.async),n.xhrFields)for(s in n.xhrFields)l[s]=n.xhrFields[s];n.mimeType&&l.overrideMimeType&&l.overrideMimeType(n.mimeType),n.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");try{for(s in i)l.setRequestHeader(s,i[s])}catch(u){}l.send(n.hasContent&&n.data||null),r=function(e,i){var s,u,c,p;try{if(r&&(i||4===l.readyState))if(r=t,a&&(l.onreadystatechange=x.noop,$n&&delete Pn[a]),i)4!==l.readyState&&l.abort();else{p={},s=l.status,u=l.getAllResponseHeaders(),"string"==typeof l.responseText&&(p.text=l.responseText);try{c=l.statusText}catch(f){c=""}s||!n.isLocal||n.crossDomain?1223===s&&(s=204):s=p.text?200:404}}catch(d){i||o(-1,d)}p&&o(s,c,p,u)},n.async?4===l.readyState?setTimeout(r):(a=++Wn,$n&&(Pn||(Pn={},x(e).unload($n)),Pn[a]=r),l.onreadystatechange=r):r()},abort:function(){r&&r(t,!0)}}}});var Xn,Un,Vn=/^(?:toggle|show|hide)$/,Yn=RegExp("^(?:([+-])=|)("+w+")([a-z%]*)$","i"),Jn=/queueHooks$/,Gn=[nr],Qn={"*":[function(e,t){var n=this.createTween(e,t),r=n.cur(),i=Yn.exec(t),o=i&&i[3]||(x.cssNumber[e]?"":"px"),a=(x.cssNumber[e]||"px"!==o&&+r)&&Yn.exec(x.css(n.elem,e)),s=1,l=20;if(a&&a[3]!==o){o=o||a[3],i=i||[],a=+r||1;do s=s||".5",a/=s,x.style(n.elem,e,a+o);while(s!==(s=n.cur()/r)&&1!==s&&--l)}return i&&(a=n.start=+a||+r||0,n.unit=o,n.end=i[1]?a+(i[1]+1)*i[2]:+i[2]),n}]};function Kn(){return setTimeout(function(){Xn=t}),Xn=x.now()}function Zn(e,t,n){var r,i=(Qn[t]||[]).concat(Qn["*"]),o=0,a=i.length;for(;a>o;o++)if(r=i[o].call(n,t,e))return r}function er(e,t,n){var r,i,o=0,a=Gn.length,s=x.Deferred().always(function(){delete l.elem}),l=function(){if(i)return!1;var t=Xn||Kn(),n=Math.max(0,u.startTime+u.duration-t),r=n/u.duration||0,o=1-r,a=0,l=u.tweens.length;for(;l>a;a++)u.tweens[a].run(o);return s.notifyWith(e,[u,o,n]),1>o&&l?n:(s.resolveWith(e,[u]),!1)},u=s.promise({elem:e,props:x.extend({},t),opts:x.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Xn||Kn(),duration:n.duration,tweens:[],createTween:function(t,n){var r=x.Tween(e,u.opts,t,n,u.opts.specialEasing[t]||u.opts.easing);return u.tweens.push(r),r},stop:function(t){var n=0,r=t?u.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)u.tweens[n].run(1);return t?s.resolveWith(e,[u,t]):s.rejectWith(e,[u,t]),this}}),c=u.props;for(tr(c,u.opts.specialEasing);a>o;o++)if(r=Gn[o].call(u,e,c,u.opts))return r;return x.map(c,Zn,u),x.isFunction(u.opts.start)&&u.opts.start.call(e,u),x.fx.timer(x.extend(l,{elem:e,anim:u,queue:u.opts.queue})),u.progress(u.opts.progress).done(u.opts.done,u.opts.complete).fail(u.opts.fail).always(u.opts.always)}function tr(e,t){var n,r,i,o,a;for(n in e)if(r=x.camelCase(n),i=t[r],o=e[n],x.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),a=x.cssHooks[r],a&&"expand"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}x.Animation=x.extend(er,{tweener:function(e,t){x.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],Qn[n]=Qn[n]||[],Qn[n].unshift(t)},prefilter:function(e,t){t?Gn.unshift(e):Gn.push(e)}});function nr(e,t,n){var r,i,o,a,s,l,u=this,c={},p=e.style,f=e.nodeType&&nn(e),d=x._data(e,"fxshow");n.queue||(s=x._queueHooks(e,"fx"),null==s.unqueued&&(s.unqueued=0,l=s.empty.fire,s.empty.fire=function(){s.unqueued||l()}),s.unqueued++,u.always(function(){u.always(function(){s.unqueued--,x.queue(e,"fx").length||s.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],"inline"===x.css(e,"display")&&"none"===x.css(e,"float")&&(x.support.inlineBlockNeedsLayout&&"inline"!==ln(e.nodeName)?p.zoom=1:p.display="inline-block")),n.overflow&&(p.overflow="hidden",x.support.shrinkWrapBlocks||u.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t)if(i=t[r],Vn.exec(i)){if(delete t[r],o=o||"toggle"===i,i===(f?"hide":"show"))continue;c[r]=d&&d[r]||x.style(e,r)}if(!x.isEmptyObject(c)){d?"hidden"in d&&(f=d.hidden):d=x._data(e,"fxshow",{}),o&&(d.hidden=!f),f?x(e).show():u.done(function(){x(e).hide()}),u.done(function(){var t;x._removeData(e,"fxshow");for(t in c)x.style(e,t,c[t])});for(r in c)a=Zn(f?d[r]:0,r,u),r in d||(d[r]=a.start,f&&(a.end=a.start,a.start="width"===r||"height"===r?1:0))}}function rr(e,t,n,r,i){return new rr.prototype.init(e,t,n,r,i)}x.Tween=rr,rr.prototype={constructor:rr,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(x.cssNumber[n]?"":"px")},cur:function(){var e=rr.propHooks[this.prop];return e&&e.get?e.get(this):rr.propHooks._default.get(this)},run:function(e){var t,n=rr.propHooks[this.prop];return this.pos=t=this.options.duration?x.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):rr.propHooks._default.set(this),this}},rr.prototype.init.prototype=rr.prototype,rr.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=x.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){x.fx.step[e.prop]?x.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[x.cssProps[e.prop]]||x.cssHooks[e.prop])?x.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},rr.propHooks.scrollTop=rr.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},x.each(["toggle","show","hide"],function(e,t){var n=x.fn[t];x.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(ir(t,!0),e,r,i)}}),x.fn.extend({fadeTo:function(e,t,n,r){return this.filter(nn).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=x.isEmptyObject(e),o=x.speed(t,n,r),a=function(){var t=er(this,x.extend({},e),o);(i||x._data(this,"finish"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return"string"!=typeof e&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=null!=e&&e+"queueHooks",o=x.timers,a=x._data(this);if(n)a[n]&&a[n].stop&&i(a[n]);else for(n in a)a[n]&&a[n].stop&&Jn.test(n)&&i(a[n]);for(n=o.length;n--;)o[n].elem!==this||null!=e&&o[n].queue!==e||(o[n].anim.stop(r),t=!1,o.splice(n,1));(t||!r)&&x.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=x._data(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=x.timers,a=r?r.length:0;for(n.finish=!0,x.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}});function ir(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=Zt[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}x.each({slideDown:ir("show"),slideUp:ir("hide"),slideToggle:ir("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){x.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),x.speed=function(e,t,n){var r=e&&"object"==typeof e?x.extend({},e):{complete:n||!n&&t||x.isFunction(e)&&e,duration:e,easing:n&&t||t&&!x.isFunction(t)&&t};return r.duration=x.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in x.fx.speeds?x.fx.speeds[r.duration]:x.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){x.isFunction(r.old)&&r.old.call(this),r.queue&&x.dequeue(this,r.queue)},r},x.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},x.timers=[],x.fx=rr.prototype.init,x.fx.tick=function(){var e,n=x.timers,r=0;for(Xn=x.now();n.length>r;r++)e=n[r],e()||n[r]!==e||n.splice(r--,1);n.length||x.fx.stop(),Xn=t},x.fx.timer=function(e){e()&&x.timers.push(e)&&x.fx.start()},x.fx.interval=13,x.fx.start=function(){Un||(Un=setInterval(x.fx.tick,x.fx.interval))},x.fx.stop=function(){clearInterval(Un),Un=null},x.fx.speeds={slow:600,fast:200,_default:400},x.fx.step={},x.expr&&x.expr.filters&&(x.expr.filters.animated=function(e){return x.grep(x.timers,function(t){return e===t.elem}).length}),x.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){x.offset.setOffset(this,e,t)});var n,r,o={top:0,left:0},a=this[0],s=a&&a.ownerDocument;if(s)return n=s.documentElement,x.contains(n,a)?(typeof a.getBoundingClientRect!==i&&(o=a.getBoundingClientRect()),r=or(s),{top:o.top+(r.pageYOffset||n.scrollTop)-(n.clientTop||0),left:o.left+(r.pageXOffset||n.scrollLeft)-(n.clientLeft||0)}):o},x.offset={setOffset:function(e,t,n){var r=x.css(e,"position");"static"===r&&(e.style.position="relative");var i=x(e),o=i.offset(),a=x.css(e,"top"),s=x.css(e,"left"),l=("absolute"===r||"fixed"===r)&&x.inArray("auto",[a,s])>-1,u={},c={},p,f;l?(c=i.position(),p=c.top,f=c.left):(p=parseFloat(a)||0,f=parseFloat(s)||0),x.isFunction(t)&&(t=t.call(e,n,o)),null!=t.top&&(u.top=t.top-o.top+p),null!=t.left&&(u.left=t.left-o.left+f),"using"in t?t.using.call(e,u):i.css(u)}},x.fn.extend({position:function(){if(this[0]){var e,t,n={top:0,left:0},r=this[0];return"fixed"===x.css(r,"position")?t=r.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),x.nodeName(e[0],"html")||(n=e.offset()),n.top+=x.css(e[0],"borderTopWidth",!0),n.left+=x.css(e[0],"borderLeftWidth",!0)),{top:t.top-n.top-x.css(r,"marginTop",!0),left:t.left-n.left-x.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||s;while(e&&!x.nodeName(e,"html")&&"static"===x.css(e,"position"))e=e.offsetParent;return e||s})}}),x.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);x.fn[e]=function(i){return x.access(this,function(e,i,o){var a=or(e);return o===t?a?n in a?a[n]:a.document.documentElement[i]:e[i]:(a?a.scrollTo(r?x(a).scrollLeft():o,r?o:x(a).scrollTop()):e[i]=o,t)},e,i,arguments.length,null)}});function or(e){return x.isWindow(e)?e:9===e.nodeType?e.defaultView||e.parentWindow:!1}x.each({Height:"height",Width:"width"},function(e,n){x.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){x.fn[i]=function(i,o){var a=arguments.length&&(r||"boolean"!=typeof i),s=r||(i===!0||o===!0?"margin":"border");return x.access(this,function(n,r,i){var o;return x.isWindow(n)?n.document.documentElement["client"+e]:9===n.nodeType?(o=n.documentElement,Math.max(n.body["scroll"+e],o["scroll"+e],n.body["offset"+e],o["offset"+e],o["client"+e])):i===t?x.css(n,r,s):x.style(n,r,i,s)},n,a?i:t,a,null)}})}),x.fn.size=function(){return this.length},x.fn.andSelf=x.fn.addBack,"object"==typeof module&&module&&"object"==typeof module.exports?module.exports=x:(e.jQuery=e.$=x,"function"==typeof define&&define.amd&&define("jquery",[],function(){return x}))})(window);
      
      /*
      BitcoinLib-JS v0.9.3
      http://github.com/VersoSolutions/BitcoinLib-JS
      Copyright (c) 2013 Verso Solutions LLC
      http://github.com/VersoSolutions/BitcoinLib-JS/blob/master/LICENSE
      */
      
      /*
      
      BitcoinLib-JS
      github.com/VersoSolutions/BitcoinLib-JS
      
      Copyright (c) 2013 Verso Solutions LLC
      
      This file is part of BitcoinLib.
      
      BitcoinLib is free software: you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
      
      BitcoinLib is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
      
      You should have received a copy of the GNU General Public License
      along with BitcoinLib.  If not, see <http://www.gnu.org/licenses/>.
      
      */
      
      /**
       * Verso library top-level namespace
       * @namespace
       */
      var Verso = Verso || {
          /**
           * Bitcoin-related functions
           * @namespace
           * @memberOf Verso
          */
          Bitcoin: {
              /**
               * Bitcoin data providers
               * @namespace
               * @memberOf Verso.Bitcoin
               */
              Providers: {}
          },
          Class: {
              inherit: function (o) {
                  function F() {}
                  F.prototype = o;
                  return new F();
              }
          },
          /**
          * Cryptography-related functions
          * @namespace
          * @memberOf Verso.Helpers
          */
          Cryptography: {},
          /**
          * Encoding-related functions
          * @namespace
          * @memberOf Verso.Helpers
          */
          Encoding: {},
          /**
           * General settings
           * @namespace
           * @memberOf Verso
           */
          Settings: {}
      };
      
      /**
       * Generic error
       *
       * @constructor
       * @param {string}  [msg] Error description
       */
      Verso.Error = function (msg) {
          this.getMessage = function () { return msg; };
      };
      Verso.Error.prototype.toString = function () { return this.getMessage(); };
      
      /**
       * Balance related error (e.g., insufficient funds)
       *
       * @constructor
       * @param {string}  [msg] Error description
       */
      Verso.BalanceError = function (msg) {
          Verso.Error.call(this, msg);
      };
      Verso.BalanceError.prototype = Verso.Class.inherit(Verso.Error.prototype);
      
      /**
       * Connection error
       *
       * @constructor
       * @param {string}  [msg] Error description
       */
      Verso.ConnectionError = function (msg, xhr) {
          Verso.Error.call(this, msg);
          this.xhr = xhr;
      };
      Verso.ConnectionError.prototype = Verso.Class.inherit(Verso.Error.prototype);
      
      /**
       * Authentication error
       *
       * @constructor
       * @param {string}  [msg] Error description
       */
      Verso.CredentialsError = function (msg) {
          Verso.Error.call(this, msg);
      };
      Verso.CredentialsError.prototype = Verso.Class.inherit(Verso.Error.prototype);
      
      /**
       * Main cryptography features
       */
      Verso.Cryptography = (function () {
      
          sjcl.random.setDefaultParanoia(6); // 256 bits of entropy
      
          // Collect additional entropy from sources of noise
          if (sjcl.random.isReady() === 0) {
              sjcl.random.startCollectors();
              sjcl.random.addEventListener("seeded", function() {
                  sjcl.random.stopCollectors();
              });
          }
      
          var entropy = [];
          /**
           * Add entropy to the RNG (without stopping entropy collection)
           *
           * @memberOf Verso.Cryptography
           * @param  {Array}   ba Entropic byte array
           */
          var addPureEntropy = function (ba) {
              entropy = entropy.concat(ba);
          };
      
          /**
           * Returns true if the RNG has enough entropy
           *
           * @memberOf Verso.Cryptography
           * @return {ByteArray}            Returns true if the RNG has enough entropy
           */
          var isRngReady = function (paranoia) {
              return sjcl.random.isReady(paranoia);
          };
      
          /**
           * Random bytes generator
           *
           * @memberOf Verso.Cryptography
           * @param  {Integer}   length     The desired length
           * @param  {Integer}   [paranoia] The desired level of paranoia
           * @return {ByteArray}            The generated random byte array
           */
          var randomBytes = function (length, paranoia) {
              if (paranoia === undefined)
                  paranoia = 0;
      
              var words;
      
              try {
                  if (!sjcl.random.isReady(paranoia) && entropy.length > 0) {
                      sjcl.random.addEntropy(Verso.Encoding.bytesToWords(entropy), 8 * entropy.length);
                      entropy = [];
                  }
      
                  words = sjcl.random.randomWords(Math.ceil(length/4), paranoia);
              }
              catch (e) {
                  throw new Verso.Error("Insufficient entropy!");
              }
      
              return Verso.Encoding.wordsToBytes(words).slice(0,length);
          };
      
          /**
           * Password-based key derivation function as defined in PKCS #5. Always returns a 256-bit key.
           *
           * @memberOf Verso.Cryptography
           * @param  {String}    password   The password
           * @param  {ByteArray} salt       The salt
           * @param  {Integer}   iterations The number of iterations
           * @return {ByteArray}            The derived key
           */
          var PBKDF2 = function (password, salt, iterations) {
              var hmacSHA1 = function (key) { // SJCL uses HMAC-SHA256 by default, we use SHA-1 for compatibility reasons
                  var hasher = new sjcl.misc.hmac(key, sjcl.hash.sha1);
                  this.encrypt = function () { return hasher.encrypt.apply(hasher, arguments); };
              };
      
              // TEMP: Should convert password from UTF8
      
              return Verso.Encoding.wordsToBytes(
                       sjcl.misc.pbkdf2( // SJCL implementation of PBKDF2 much more efficient than CryptoJS implementation
                         password,
                         Verso.Encoding.bytesToWords(salt),
                         iterations,
                         256,
                         hmacSHA1));
          };
      
          /**
           * Hashes the input byte array with SHA256
           *
           * @memberOf Verso.Cryptography
           * @param {ByteArray} ba The data to hash
           */
          var SHA256 = function (ba) {
              return Verso.Encoding.wordArrayToBytes(CryptoJS.SHA256(Verso.Encoding.bytesToWordArray(ba)));
          };
      
          /**
           * Hashes the input byte array with SHA256 of SHA256
           *
           * @memberOf Verso.Cryptography
           * @param {ByteArray} ba The data to hash
           */
          var SHASHA256 = function (ba) {
              return Verso.Encoding.wordArrayToBytes(CryptoJS.SHA256(CryptoJS.SHA256(Verso.Encoding.bytesToWordArray(ba))));
          };
      
          /**
           * Hashes the input byte array with SHA256 of SHA256 of SHA256
           *
           * @memberOf Verso.Cryptography
           * @param {ByteArray} ba The data to hash
           */
          var SHASHASHA256 = function (ba) {
              return Verso.Encoding.wordArrayToBytes(CryptoJS.SHA256(CryptoJS.SHA256(CryptoJS.SHA256(Verso.Encoding.bytesToWordArray(ba)))));
          };
      
          /**
           * Hashes the input byte array with RIPEMD160
           *
           * @memberOf Verso.Cryptography
           * @param {ByteArray} ba The data to hash
           */
          var RIPEMD160 = function (ba) {
              return Verso.Encoding.wordArrayToBytes(CryptoJS.RIPEMD160(Verso.Encoding.bytesToWordArray(ba)));
          };
      
          /**
           * Hashes the input byte array with RIPEMD160 of SHA256
           *
           * @memberOf Verso.Cryptography
           * @param {ByteArray} ba The data to hash
           */
          var SHA256RIPEMD160 = function (ba) {
              return RIPEMD160(SHA256(ba));
          };
      
          /**
           * Hashes the input byte array with HMAC-SHA512
           *
           * @memberOf Verso.Cryptography
           * @param {ByteArray} ba  The data to hash
           * @param {ByteArray} key The key
           * @return {ByteArray}    The hash
          */
          var HMACSHA512 = function (ba, key) {
              return Verso.Encoding.wordArrayToBytes(CryptoJS.HmacSHA512(Verso.Encoding.bytesToWordArray(ba), Verso.Encoding.bytesToWordArray(key)));
          };
      
          /**
           * Encrypts the plaintext with AES-CTR-NoPadding. If the IV is not specified, it is concatenated in front of the resulting ciphertext.
           *
           * @memberOf Verso.Cryptography
           * @param  {ByteArray} plaintext The plaintext
           * @param  {ByteArray} key       The key
           * @param  {ByteArray} [iv]      The IV
           * @return {ByteArray}           The ciphertext
           */
          var aesEncrypt = function (plaintext, key, iv) {
              var ivPredefined = (iv !== undefined);
      
              if (!ivPredefined) {
                  iv = Verso.Cryptography.randomBytes(128/8, 0);
              }
      
              var cipherParams =
              {
                  iv: Verso.Encoding.bytesToWordArray(iv),
                  mode: CryptoJS.mode.CTR,
                  padding: CryptoJS.pad.NoPadding
              };
      
              var ciphertext = Verso.Encoding.wordArrayToBytes(CryptoJS.AES.encrypt(Verso.Encoding.bytesToWordArray(plaintext), Verso.Encoding.bytesToWordArray(key), cipherParams).ciphertext);
      
              if (ivPredefined)
                  return ciphertext;
              else
                  return iv.concat(ciphertext);
          };
      
          /**
           * Decrypts the ciphertext with AES-CTR-NoPadding. If the IV is not specified, assumes that it is concatenated in front of the ciphertext.
           *
           * @memberOf Verso.Cryptography
           * @param  {ByteArray} ciphertext The ciphertext
           * @param  {ByteArray} key        The key
           * @param  {ByteArray} [iv]       The IV
           * @return {ByteArray}            The plaintext
           */
          var aesDecrypt = function (ciphertext, key, iv) {
              if (iv === undefined) {
                  iv = ciphertext.slice(0, 128 / 8);
                  ciphertext = ciphertext.slice(128 / 8);
              }
      
              var cipherParams =
              {
                  iv: Verso.Encoding.bytesToWordArray(iv),
                  mode: CryptoJS.mode.CTR,
                  padding: CryptoJS.pad.NoPadding
              };
      
              return Verso.Encoding.wordArrayToBytes(CryptoJS.AES.decrypt({ciphertext: Verso.Encoding.bytesToWordArray(ciphertext)}, Verso.Encoding.bytesToWordArray(key), cipherParams));
          };
      
          /**
           * Encrypts the plaintext with RSA-2048
           *
           * @memberOf Verso.Cryptography
           * @param  {ByteArray} plaintext The plaintext
           * @param  {Hex}       modulus   The modulus
           * @param  {Hex}       exponent  The public exponent
           * @return {ByteArray}           The ciphertext
           */
          var rsaEncrypt = function (plaintext, modulus, exponent) {
              var rsa = new RSAKey();
              rsa.setPublic(modulus, exponent);
      
              var res = rsa.encrypt(plaintext);
              if (res)
                  return Verso.Encoding.wordArrayToBytes(CryptoJS.enc.Hex.parse(res));
              else
                  return null;
          };
      
          /**
           * Shares the secret based on Shamir's Secret Sharing algorithm
           *
           * @memberOf Verso.Cryptography
           * @param  {ByteArray} secret     The secret to share
           * @param  {Integer}   n          The number of shares to generate
           * @param  {Integer}   k          The minimum number of shares for combination
           * @param  {Integer}   [paranoia] The desired level of paranoia
           * @return {ByteArray}            The secret shares
           */
          var secretShare = function (secret, n, k, paranoia) {
              if (paranoia === undefined)
                  paranoia = 6;
      
              secrets.setRNG(function (bits) {
                  var b = randomBytes(bits / 8, paranoia);
      
                  var result = "";
                  for (var i = 0; i < b.length; i++) {
                      var tmp = b[i].toString(2);
                      while (tmp.length < 8) tmp = "0" + tmp;
                      result += tmp;
                  }
      
                  return result;
              });
      
              var shares = secrets.share(Verso.Encoding.bytesToBase16(secret), n, k);
              shares = shares.map(function (s) { return Verso.Encoding.base16ToBytes(s.slice(1)); });
      
              return shares;
          };
      
          /**
           * Combines the secret shares based on Samir's Secret Sharing algorithm
           *
           * @memberOf Verso.Cryptography
           * @param  {Array.ByteArray} shares The secret shares
           * @return {ByteArray}              The secret
           */
          var secretCombine = function (shares) {
              shares = shares.map(function (s) { return "8".concat(Verso.Encoding.bytesToBase16(s)); });
      
              return Verso.Encoding.base16ToBytes(secrets.combine(shares));
          };
      
          return {
              randomBytes: randomBytes,
              addPureEntropy: addPureEntropy,
              isRngReady: isRngReady,
              PBKDF2: PBKDF2,
              SHA256: SHA256,
              SHASHA256: SHASHA256,
              SHASHASHA256: SHASHASHA256,
              RIPEMD160: RIPEMD160,
              SHA256RIPEMD160: SHA256RIPEMD160,
              HMACSHA512: HMACSHA512,
              aesEncrypt: aesEncrypt,
              aesDecrypt: aesDecrypt,
              rsaEncrypt: rsaEncrypt,
              secretShare: secretShare,
              secretCombine: secretCombine
          };
      })();
      
      /**
       * Main encoding tools
       */
      Verso.Encoding = (function () {
          var Base58Table = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
          var Base94Table = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
      
          var bigIntegerToBytesUnsigned = function (bi, len) {
              var ba = bi.abs().toByteArray();
      
              if (ba.length > 1 && ba[0] === 0) {
                  ba = ba.slice(1);
              }
      
              if (ba.length) {
                  ba = ba.map(function (v) { return (v < 0) ? v + 256 : v; });
              }
              else {
                  ba = [0];
              }
      
              if (len !== undefined) {
                  if (len < ba.length) {
                      ba = ba.slice(ba.length - len);
                  } else while (len > ba.length) {
                      ba.unshift(0);
                  }
              }
      
              return ba;
          };
      
          var bytesUnsignedToBigInteger = function (ba) {
              if (!ba.length) {
                  return new BigInteger(0x00);
              } else if (ba[0] & 0x80) {
                  return new BigInteger([0].concat(ba));
              } else {
                  return new BigInteger(ba);
              }
          };
      
          var bigIntegerToBytesSigned = function (bi) {
              var val = bigIntegerToBytesUnsigned(bi.abs());
              var neg = bi.compareTo(BigInteger.ZERO) < 0;
      
              if (neg) {
                  if (val[0] & 0x80) {
                      val.unshift(0x80);
                  } else {
                      val[0] |= 0x80;
                  }
              } else {
                  if (val[0] & 0x80) {
                      val.unshift(0x00);
                  }
              }
      
              return val;
          };
      
          var bytesSignedToBigInteger = function (ba) {
              if (ba[0] & 0x80) {
                  ba[0] &= 0x7f;
                  return bytesUnsignedToBigInteger(ba).negate();
              } else {
                  return bytesUnsignedToBigInteger(ba);
              }
          };
      
          var integerToBytesUnsigned = function (i, len) {
              return bigIntegerToBytesUnsigned(new BigInteger('' + i, 10), len); // TODO: implement properly
          };
      
          var stringToBytes = function (s, table) {
              var bi = BigInteger.ZERO;
              var n = BigInteger.ONE;
              var base = nbv(table.length);
              var zeros = 0;
      
              for (var i = 0; i < s.length; i++) {
                  var c = s[s.length - i - 1];
                  var k = nbv(table.indexOf(c));
      
                  bi = bi.add(n.multiply(k));
                  n = n.multiply(base);
      
                  if (c == table[0]) zeros++; // count leading zeros
                  else zeros = 0;
              }
      
              var bytes = bigIntegerToBytesUnsigned(bi);
      
              if (bytes.length > 1 || bytes[0] !== 0)
                  while (zeros-- > 0) bytes.unshift(0); // add leading zeros
      
              return bytes;
          };
      
          var bytesToString = function (ba, table) {
              if (!ba.length || (ba.length === 1 && ba[0] === 0))
                  return table[0];
      
              var base = nbv(table.length);
      
              var bi = bytesUnsignedToBigInteger(ba);
              var chars = [];
      
              while (bi.compareTo(base) >= 0) {
                  var mod = bi.mod(base);
                  chars.unshift(table[mod.intValue()]);
                  bi = bi.subtract(mod).divide(base);
              }
              chars.unshift(table[bi.intValue()]);
      
              // Convert leading zeros too.
              for (var i = 0; i < ba.length; i++) {
                  if (ba[i] === 0x00) {
                      chars.unshift(table[0]);
                  } else break;
              }
      
              return chars.join('');
          };
      
          var bytesToWords = function (ba) {
              for (var words = [], i = 0, b = 0; i < ba.length; i++, b += 8)
                  words[b >>> 5] |= ba[i] << (24 - b % 32);
              return words;
          };
      
          var wordsToBytes = function (wa) {
              for (var bytes = [], b = 0; b < wa.length * 32; b += 8)
                  bytes.push((wa[b >>> 5] >>> (24 - b % 32)) & 0xFF);
              return bytes;
          };
      
          var wordArrayToBytes = function (wa) {
              return wordsToBytes(wa.words).slice(0, wa.sigBytes);
          };
      
          var bytesToWordArray = function (ba) {
              return CryptoJS.lib.WordArray.create(bytesToWords(ba), ba.length);
          };
      
          var numToVarInt = function (i) {
              if (i < 0xfd) {
                  // unsigned char
                  return [i];
              } else if (i <= 1 << 16) {
                  // unsigned short (LE)
                  return [0xfd, i >>> 8, i & 255];
              } else if (i <= 1 << 32) {
                  // unsigned int (LE)
                  return [0xfe].concat(wordsToBytes([i]));
              } else {
                  // unsigned long long (LE)
                  return [0xff].concat(wordsToBytes([i >>> 32, i]));
              }
          };
      
          var bytesToCheck = function (ba, version) {
              var bytes = ba.slice(0);
      
              if (version !== undefined)
                  bytes.unshift(version);
      
              var checksum = Verso.Cryptography.SHASHA256(bytes);
      
              return bytes.concat(checksum.slice(0, 4));
          };
      
          var checkToBytes = function (ba, version) {
              if (!Array.isArray(version)) { version = [version]; }
      
              if (version !== undefined && !version.some(function (v) { return ba[0] === v; })) {
                  throw new Verso.Error("Version mismatch!");
              }
      
              var bytes = ba.slice(0, ba.length - 4);
              var checksum = ba.slice(ba.length - 4, ba.length);
      
              var chk = Verso.Cryptography.SHASHA256(bytes).slice(0, 4);
              for (var i = 0; i < 4; i++) if (chk[i] != checksum[i]) throw new Verso.Error("Checksum mismatch!");
      
              if (version === undefined)
                  return bytes;
              return bytes.slice(1);
          };
      
          return {
              base16ToBytes: function (s) {
                  return wordArrayToBytes(CryptoJS.enc.Hex.parse(s));
              },
              bytesToBase16: function (ba) {
                  return CryptoJS.enc.Hex.stringify(bytesToWordArray(ba));
              },
              base58ToBytes: function (s) {
                  return stringToBytes(s, Base58Table);
              },
              bytesToBase58: function (ba) {
                  return bytesToString(ba, Base58Table);
              },
              base64ToBytes: function (s) {
                  return wordArrayToBytes(CryptoJS.enc.Base64.parse(s));
              },
              bytesToBase64: function (ba) {
                  return CryptoJS.enc.Base64.stringify(bytesToWordArray(ba));
              },
              bytesToBase64Url: function(ba) {
                  return CryptoJS.enc.Base64.stringify(bytesToWordArray(ba)).replace("+", "-").replace("/", "_").replace("=", "");
              },
              base94ToBytes: function (s) {
                  return stringToBytes(s, Base94Table);
              },
              bytesToBase94: function (ba) {
                  return bytesToString(ba, Base94Table);
              },
              bytesToUtf8: function(ba) {
                  return CryptoJS.enc.Utf8.stringify(bytesToWordArray(ba));
              },
              utf8ToBytes: function (s) {
                  return wordArrayToBytes(CryptoJS.enc.Utf8.parse(s));
              },
              wordsToBytes: wordsToBytes,
              bytesToWords: bytesToWords,
              wordArrayToBytes: wordArrayToBytes,
              bytesToWordArray: bytesToWordArray,
              bigIntegerToBytesUnsigned: bigIntegerToBytesUnsigned,
              bytesUnsignedToBigInteger: bytesUnsignedToBigInteger,
              bigIntegerToBytesSigned: bigIntegerToBytesSigned,
              bytesSignedToBigInteger: bytesSignedToBigInteger,
              integerToBytesUnsigned: integerToBytesUnsigned,
              numToVarInt: numToVarInt,
              bytesToCheck: bytesToCheck,
              checkToBytes: checkToBytes
          };
      })();
      
      
      /** Bitcoin ECDSA curve */
      Verso.Bitcoin.Curve = (function () { return getSECCurveByName("secp256k1"); })();
      
      /**
       * Bitcoin endpoint (key pair)
       *
       * @constructor
       * @param {ByteArray|String} [data] A private key (raw or WIF) or a public key hash (raw or Base58Check)
       */
      Verso.Bitcoin.Endpoint = function (data) {
          var encoding = Verso.Encoding,
              curve = Verso.Bitcoin.Curve,
              cryptography = Verso.Cryptography,
              bitcoin = Verso.Bitcoin;
      
          var that = this;
          var watchOnly;
          var privateKey;
          var privateCheck;
          var pt;
          var pub;
          var pubc;
          var pubHash;
          var address;
          var version;
      
          var genKey = function (bigint) {
              var key = encoding.bytesUnsignedToBigInteger(cryptography.randomBytes(32, 6))
                  .mod(curve.getN().subtract(BigInteger.ONE))
                  .add(BigInteger.ONE);
      
              if (bigint)
                  return key;
      
              return encoding.bigIntegerToBytesUnsigned(key, 32);
          };
      
          var derivePublic = function () {
              if (watchOnly || (pt !== undefined && pub !== undefined && pubc !== undefined))
                  return;
      
              // Compute public key
              pt = curve.getG().multiply(encoding.bytesUnsignedToBigInteger(privateKey));
              pt = {
                  x: pt.getX().toBigInteger(),
                  y: pt.getY().toBigInteger()
              };
      
              // Convert to DER format
              pub = encoding.bigIntegerToBytesUnsigned(pt.x, 32);
              pub.unshift(0x04);
              pub = pub.concat(encoding.bigIntegerToBytesUnsigned(pt.y, 32));
      
              // Compressed form
              pubc = encoding.bigIntegerToBytesUnsigned(pt.x, 32);
              if (pt.y.isEven())
                  pubc.unshift(0x02);
              else
                  pubc.unshift(0x03);
      
              // Compute address hash and string address
              pubHash = cryptography.SHA256RIPEMD160(pub);
              address = encoding.bytesToBase58(encoding.bytesToCheck(pubHash, 0x00));
          };
      
          if (data === undefined) {
              data = genKey();
          }
          else if (typeof data == "string") {
              data = encoding.base58ToBytes(data);
          }
          else if (data instanceof Verso.Bitcoin.Endpoint) {
              if (data.isWatchOnly())
                  data = data.getPublicHash();
              else
                  data = data.getPrivate();
          }
      
          if (Array.isArray(data) && data.length == 20) { // pubHash
              pubHash = data;
              version = 0x00;
              address = encoding.bytesToBase58(encoding.bytesToCheck(data, 0x00));
              watchOnly = true;
          }
          else if (Array.isArray(data) && data.length == 25) { // address
              pubHash = encoding.checkToBytes(data, [0x00,0x05]);
              version = data[0];
              address = encoding.bytesToBase58(data);
              watchOnly = true;
          }
          else {
              if (Array.isArray(data) && data.length == 32) { // private exponent
                  privateKey = data;
                  privateCheck = encoding.bytesToBase58(encoding.bytesToCheck(privateKey, 0x80));
              }
              else if (Array.isArray(data) && data.length == 37) { // wif
                  privateKey = encoding.checkToBytes(data, 0x80);
                  privateCheck = encoding.bytesToBase58(data);
              }
              else throw new Verso.Error("Invalid argument");
      
              version = 0x00;
              watchOnly = false;
      
              /** Returns the private key */
              this.getPrivate = function () { return privateKey; };
              /** Returns the WIF private key */
              this.getPrivateCheck = function () { return privateCheck; };
              /** Returns the public point of the EC key */
              this.getPublicPoint = function () { derivePublic(); return pt; };
              /** Returns the DER-encoded public EC key */
              this.getPublic = function (compressed) {
                  derivePublic();
                  if (compressed) return pubc;
                  else return pub;
              };
      
              /** Signs a hash using ECDSA algorithm and encodes it in DER */
              this.sign = function (hash) {
                  var d = encoding.bytesUnsignedToBigInteger(that.getPrivate());
                  var n = curve.getN();
                  var e = encoding.bytesUnsignedToBigInteger(hash);
                  var k, r;
      
                  do {
                      k = genKey(true);
                      r = curve.getG().multiply(k).getX().toBigInteger().mod(n);
                  } while (r.compareTo(BigInteger.ZERO) <= 0);
      
                  var s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);
      
                  // DER encoding
                  var rBa = encoding.bigIntegerToBytesSigned(r);
                  var sBa = encoding.bigIntegerToBytesSigned(s);
      
                  var sequence = [];
                  sequence.push(0x02);
                  sequence.push(rBa.length);
                  sequence = sequence.concat(rBa);
      
                  sequence.push(0x02);
                  sequence.push(sBa.length);
                  sequence = sequence.concat(sBa);
      
                  sequence.unshift(sequence.length);
                  sequence.unshift(0x30);
      
                  return sequence;
              };
          }
      
          /** Returns the hash of the public key */
          this.getPublicHash = function () { derivePublic(); return pubHash; };
          /** Returns the endpoint version */
          this.getVersion = function () { return version; };
          /** Returns the Bitcoin address in Base58Check string format */
          this.getAddress = function () { derivePublic(); return address; };
          /** Returns a new watch-only version of the endpoint */
          this.asWatchOnly = function () { derivePublic(); if (!watchOnly) return new Verso.Bitcoin.Endpoint(address); return that; };
          /** Returns true if the endpoint is watch-only */
          this.isWatchOnly = function () { return watchOnly; };
          /** Compares two endpoints */
          this.sameAs = function (ep) {
              if (ep === null)
                  return false;
      
              if (!(ep instanceof Verso.Bitcoin.Endpoint))
                  ep = new Verso.Bitcoin.Endpoint(ep);
      
              if (watchOnly || ep.isWatchOnly()) {
                  return that.getAddress() == ep.getAddress();
              }
      
              var other = ep.getPrivate();
              for (var i = 0; i < privateKey.length; i++) if (privateKey[i] !== other[i]) return false;
              return true;
          };
      };
      
      /**
       * Returns true if the data is a bitcoin address
       *
       * @param  {String|ByteArray} data   The data to test
       * @return {Boolean}                 Returns true if data is a bitcoin address
       */
      Verso.Bitcoin.isAddress = function (data) {
          var encoding = Verso.Encoding;
      
          if (typeof data == "string") {
              data = encoding.base58ToBytes(data);
          }
      
          if (!Array.isArray(data) || data.length != 25)
              return false;
      
          try {
              encoding.checkToBytes(data, [0x00, 0x05]);
              return true;
          }
          catch (e) {
              return false;
          }
      };
      
      /**
       * Processes the list of loosely-typed endpoints (string addresses, endpoints, etc.) into an array of corresponding Endpoint instances
       *
       * @param  {Endpoint|String|ByteArray} endpoints The list of endpoints
       * @return {Array.Endpoint}                      The processed array of endpoints
       */
      Verso.Bitcoin.Endpoint.toList = function (endpoints) {
          if (endpoints === undefined)
              return [];
      
          if (!Array.isArray(endpoints))
              endpoints = [endpoints];
      
          for (var i = 0; i < endpoints.length; i++) {
              if (!(endpoints[i] instanceof Verso.Bitcoin.Endpoint))
                  endpoints[i] = new Verso.Bitcoin.Endpoint(endpoints[i]);
          }
      
          return endpoints;
      };
      
      /**
       * Bitcoin extended endpoint as defined in BIP 0032
       *
       * @constructor
       * @extends {Endpoint}
       * @param   {ByteArray|String} data      The private key (raw or WIF)
       * @param   {ByteArray}        chainCode The chain code
       */
      Verso.Bitcoin.ExtendedEndpoint = function (data, chainCode) {
          Verso.Bitcoin.Endpoint.call(this, data);
      
          /** Returns the chain code of the extended endpoint */
          this.getChainCode = function () { return chainCode; };
      };
      
      Verso.Bitcoin.ExtendedEndpoint.prototype = Verso.Class.inherit(Verso.Bitcoin.Endpoint.prototype);
      
      /**
       * Generates a child extended endpoint
       *
       * @param  {Integer}          index The index of the child
       * @param  {Boolean)          pub   Boolean indicating whether public derivation should be used
       * @return {ExtendedEndpoint}       The child extended endpoint
       */
      Verso.Bitcoin.ExtendedEndpoint.prototype.getChild = function (index, pub) {
          var encoding = Verso.Encoding,
              curve = Verso.Bitcoin.Curve,
              cryptography = Verso.Cryptography;
      
          if (index === undefined)
              index = 0;
          else if (index < 0)
              throw new Verso.Error("Index cannot be negative!");
      
          var IL, IR, newKey;
          index--;
          do {
              index++;
      
              if (index > 0x7FFFFFFF)
                  throw new Verso.Error("Index is too large!");
      
              var hmacData = encoding.integerToBytesUnsigned(index, 4);
              if (pub) {
                  hmacData[0] &= 0x7F;
                  hmacData = this.getPublic(true).concat(hmacData);
              }
              else {
                  hmacData[0] |= 0x80;
                  hmacData = [0x00].concat(this.getPrivate()).concat(hmacData);
              }
      
              var I = cryptography.HMACSHA512(hmacData, this.getChainCode());
              IL = encoding.bytesUnsignedToBigInteger(I.slice(0, 32));
              IR = encoding.bytesUnsignedToBigInteger(I.slice(32));
              newKey = IL.add(encoding.bytesUnsignedToBigInteger(this.getPrivate())).mod(curve.getN());
          } while (IL.compareTo(curve.getN()) >= 0 || newKey.compareTo(BigInteger.ZERO) === 0);
      
          return new Verso.Bitcoin.ChildEndpoint(encoding.bigIntegerToBytesUnsigned(newKey, 32), encoding.bigIntegerToBytesUnsigned(IR, 32), this, index);
      };
      
      /**
       * Bitcoin master endpoint
       *
       * @constructor
       * @extends {Endpoint}
       * @param   {ByteArray|String} [seed]      The seed used for determinism
       */
      Verso.Bitcoin.MasterEndpoint = function (seed) {
          var encoding = Verso.Encoding,
          curve = Verso.Bitcoin.Curve,
          cryptography = Verso.Cryptography;
      
          var endpoint;
          var chainCode;
      
          var derive = function (s) {
              var I = cryptography.HMACSHA512(s, encoding.utf8ToBytes("Bitcoin seed"));
      
              var key = I.slice(0, 32);
              var chainCode = I.slice(32);
      
              var bi = encoding.bytesUnsignedToBigInteger(key);
              if (bi.compareTo(curve.getN()) >= 0 || bi.compareTo(BigInteger.ZERO) === 0)
                  return { valid: false };
              return { key: key, chainCode: chainCode, valid: true };
          };
      
          var derived;
      
          if (seed === undefined) {
              do {
                  seed = cryptography.randomBytes(32, 6);
                  derived = derive(seed);
              } while (!derived.valid);
          } else {
              derived = derive(seed);
      
              if (!derived.valid)
                  throw new Verso.Error("Invalid seed!");
          }
      
          Verso.Bitcoin.ExtendedEndpoint.call(this, derived.key, derived.chainCode);
      
          /** Returns the seed of the master node */
          this.getSeed = function () { return seed.slice(0); };
          /** Returns the path of the extended endpoint */
          this.getPath = function () { return []; };
          /** Returns true if object is the seed */
          this.isMaster = function () { return true; };
      };
      
      Verso.Bitcoin.MasterEndpoint.prototype = Verso.Class.inherit(Verso.Bitcoin.ExtendedEndpoint.prototype);
      
      /**
       * Bitcoin extended endpoint as defined in BIP 0032
       *
       * @constructor
       * @extends {Endpoint}
       * @param   {ByteArray|String} data      The private key (raw or WIF)
       * @param   {ByteArray}        chainCode The chain code
       * @param   {ExtendedEndpoint} parent    The parent endpoint
       * @param   {IntArray}         path      The node path
       */
      Verso.Bitcoin.ChildEndpoint = function (data, chainCode, parent, index) {
          Verso.Bitcoin.ExtendedEndpoint.call(this, data, chainCode);
      
          var path = parent.getPath().concat([index]);
      
          /** Returns the parent node of the extended endpoint */
          this.getParent = function () { return parent; };
          /** Returns the path of the extended endpoint */
          this.getPath = function () { return path; };
          /** Returns true if object is the master node */
          this.isMaster = function () { return false; };
      };
      
      Verso.Bitcoin.ChildEndpoint.prototype = Verso.Class.inherit(Verso.Bitcoin.ExtendedEndpoint.prototype);
      
      /**
       * Converts Satoshis to Bitcoins
       *
       * @param  {Integer} index The number of Satoshis
       * @return {Number}        The number of Bitcoins
       */
      Verso.Bitcoin.satToBtc = function (s) { return s / 1e8; };
      
      /**
       * Converts Bitcoins to Satoshis
       *
       * @param  {Number} index The number of Bitcoins
       * @return {Integer}      The number of Satoshis
       */
      Verso.Bitcoin.btcToSat = function (b) { return Math.round(b * 1e8); };
      
      /**
       * Bitcoin transaction input
       *
       * @constructor
       * @param {Endpoint}  endpoint   The input endpoint
       * @param {Integer}   amount     The input amount in Satoshis
       * @param {ByteArray} [hash]     The hash of the transaction used as input [big-endian]
       * @param {Integer}   [index]    The output index of the input
       * @param {ByteArray} [script]   The script [big-endian]
       * @param {ByteArray} [sequence] The sequence number [big-endian]
       */
      Verso.Bitcoin.TxIn = function (endpoint, amount, hash, index, script, sequence) {
          if (!(endpoint instanceof Verso.Bitcoin.Endpoint))
              endpoint = new Verso.Bitcoin.Endpoint(endpoint);
      
          if (hash === undefined)
              hash = [];
          if (index === undefined)
              index = -1;
          if (script === undefined)
              script = [];
          if (sequence === undefined)
              sequence = [0xFF, 0xFF, 0xFF, 0xFF];
      
          /** Returns a copy of the transaction hash [big-endian] */
          this.getHash = function () { return hash.slice(0); };
          /** Returns the transaction input index */
          this.getIndex = function () { return index; };
          /** Returns the transaction input script [big-endian] */
          this.getScript = function () { return script.slice(0); };
          /** Returns the transaction sequence number [big-endian] */
          this.getSequence = function () { return sequence.slice(0); };
          /** Returns the transaction endpoint */
          this.getEndpoint = function () { return endpoint; };
          /** Returns the amount of the transaction input in Satoshis */
          this.getAmount = function () { return amount; };
          /** Sets a new script for the transaction input */
          this.setScript = function(newScript) {
              script = newScript;
          };
          /** Clones the transaction input */
          this.clone = function () {
              return new Verso.Bitcoin.TxIn(endpoint, amount, hash.slice(0), index, script.slice(0), sequence.slice(0));
          };
          /** Returns true if transaction input can be used to sign a transaction */
          this.canSign = function () {
              return !endpoint.isWatchOnly() && hash.length > 0 && index >= 0 && script.length > 0 && sequence.length > 0;
          };
      };
      
      /**
       * Bitcoin transaction output
       *
       * @constructor
       * @param {Endpoint}          endpoint The output endpoint
       * @param {ByteArray|Numeric} amount   The output amount
       * @param {ByteArray}         [script] The script, [DUP EQUALVERIFY publicHash HASH160 CHECKSIG] by default
       */
      Verso.Bitcoin.TxOut = function (endpoint, amount, script) {
          if (!(endpoint instanceof Verso.Bitcoin.Endpoint))
              endpoint = new Verso.Bitcoin.Endpoint(endpoint);
      
          var outputScript = function () {
              var OP_DUP = 118,
                  OP_EQUAL = 135,
                  OP_EQUALVERIFY = 136,
                  OP_HASH160 = 169,
                  OP_CHECKSIG = 172,
                  pub;
      
              if (script === undefined && (endpoint.getVersion() === undefined || endpoint.getVersion() === 0x00)) { // pay-to-pubkey-hash
                  pub = endpoint.getPublicHash();
      
                  script = [];
                  script.push(OP_DUP);
                  script.push(OP_HASH160);
                  script.push(pub.length);
                  script = script.concat(pub);
                  script.push(OP_EQUALVERIFY);
                  script.push(OP_CHECKSIG);
              } else if (script === undefined && endpoint.getVersion() === 0x05) { // pay-to-script-hash
                  pub = endpoint.getPublicHash();
      
                  script = [];
                  script.push(OP_HASH160);
                  script.push(pub.length);
                  script = script.concat(pub);
                  script.push(OP_EQUAL);
              }
          };
      
          if (script === undefined) { outputScript(); }
      
          /** Returns the destination endpoint */
          this.getEndpoint = function () { return endpoint; };
          /** Returns the amount */
          this.getAmount = function () { return amount; };
          /** Returns the output script */
          this.getScript = function () { return script.slice(0); };
      };
      
      /**
       * Bitcoin transaction
       *
       * @constructor
       * @param {Array.TxIn}  ins       The inputs
       * @param {Array.TxOut} outs      The outputs
       * @param {ByteArray}   [hash]    The transaction hash
       * @param {Integer}     [block]   The block height in which transaction was first added
       * @param {Number}      [Date]    The time at which transaction was broadcasted
       */
      Verso.Bitcoin.Tx = function (ins, outs, hash, block, time) {
          var encoding = Verso.Encoding,
              cryptography = Verso.Cryptography,
              bitcoin = Verso.Bitcoin;
      
          if (!Array.isArray(ins))
              ins = [ins];
          if (!Array.isArray(outs))
              outs = [outs];
          if (hash === undefined)
              hash = [];
          if (block === undefined)
              block = new bitcoin.Block();
          if (time === undefined)
              time = 0;
      
          var serialized = [];
          ins = ins.slice(0);
          outs = outs.slice(0);
      
          var fees = ins.reduce(function (prev, curr) { return prev + curr.getAmount(); }, 0) -
                     outs.reduce(function (prev, curr) { return prev + curr.getAmount(); }, 0);
      
          var serializeTx = function (ins, outs) {
              var buffer = [],
                  i;
      
              buffer = buffer.concat([0x01, 0x00, 0x00, 0x00]);
      
              buffer = buffer.concat(encoding.numToVarInt(ins.length));
              for (i = 0; i < ins.length; i++) {
                  buffer = buffer.concat(ins[i].getHash().reverse());
                  buffer = buffer.concat(encoding.wordsToBytes([parseInt(ins[i].getIndex())]).reverse());
      
                  buffer = buffer.concat(encoding.numToVarInt(ins[i].getScript().length));
                  buffer = buffer.concat(ins[i].getScript());
                  buffer = buffer.concat(ins[i].getSequence().reverse());
              }
      
              buffer = buffer.concat(encoding.numToVarInt(outs.length));
              for (i = 0; i < outs.length; i++) {
                  buffer = buffer.concat(encoding.integerToBytesUnsigned(outs[i].getAmount(), 8).reverse());
      
                  buffer = buffer.concat(encoding.numToVarInt(outs[i].getScript().length));
                  buffer = buffer.concat(outs[i].getScript());
              }
      
              buffer = buffer.concat([0x00, 0x00, 0x00, 0x00]);
      
              return buffer;
          };
      
          var inputScript = function (index) {
              var hashType = 1;
      
              var ins_ = [];
              for (var i = 0; i < ins.length; i++) {
                  var input = ins[i].clone();
      
                  if (i != index)
                      input.setScript([]);
      
                  ins_.push(input);
              }
      
              var buffer = serializeTx(ins_, outs);
              buffer = buffer.concat(encoding.wordsToBytes([parseInt(hashType)]).reverse());
      
              var hash = cryptography.SHASHA256(buffer);
              var sign = ins[index].getEndpoint().sign(hash);
              var pub = ins[index].getEndpoint().getPublic();
      
              var script = [];
              script.push(sign.length+1);
              script = script.concat(sign);
              script.push(0x01);
              script.push(pub.length);
              script = script.concat(pub);
      
              return script;
          };
      
          /** Returns the transaction inputs */
          this.getIns = function () { return ins.slice(0); };
          /** Returns the transaction outputs */
          this.getOuts = function () { return outs.slice(0); };
          /** Returns the block height in which transaction is first included */
          this.getBlock = function () { return block; };
          /** Sets the block height in which transaction is first included */
          this.setBlock = function (b) { block = b; };
          /** Returns the time at which transaction is broadcasted */
          this.getTime = function () { return time; };
          /** Sets the time at which transaction is broadcasted */
          this.setTime = function (t) { time = t; };
          /** Returns the transaction hash */
          this.getHash = function () { return hash.slice(0); };
          /** Returns the transaction fees */
          this.getFees = function () { return fees; };
          /** Returns true if endpoints are related to the transaction */
          this.hasEndpoints = function (ep) {
              for (var i = 0; i < ep.length; i++) {
                  if (this.getIns().some(function (ti) { return ti.getEndpoint().sameAs(ep[i]); }) ||
                     this.getOuts().some(function (to) { return to.getEndpoint().sameAs(ep[i]); }))
                      return true;
              }
      
              return false;
          };
          /** Returns the serialized version of the transaction */
          this.serialize = function () {
              if (serialized.length > 0)
                  return serialized;
      
              if (!ins.every(function (i) { return i.canSign(); }))
                  throw new Verso.Error("Tx inputs cannot be signed!");
      
              var ins_ = [];
      
              for (var i = 0; i < ins.length; i++) {
                  var in_ = ins[i].clone();
                  in_.setScript(inputScript(i));
                  ins_.push(in_);
              }
      
              serialized = serializeTx(ins_, outs);
              hash = cryptography.SHASHA256(serialized);
              return serialized;
          };
      };
      
      /**
        * Returns true if the transactions are the same (comparing the hash)
        *
        * @param  {Verso.Bitcoin.Tx} tx Other transaction
        * @return {Boolean}             The comparison result
        */
      Verso.Bitcoin.Tx.prototype.sameAs = function (tx) {
          if (tx instanceof Verso.Bitcoin.Tx)
              tx = tx.getHash();
          if (Array.isArray(tx))
              tx = Verso.Encoding.bytesToBase16(tx);
      
          return Verso.Encoding.bytesToBase16(this.getHash()) === tx;
      };
      
      /**
       * Returns true if the transaction is confirmed
       *
       * @param  {Block}   latestBlock        The latest block
       * @param  {Integer} [minConfirmations] The number of confirmations required
       * @return {Boolean}                    The confirmation status
       */
      Verso.Bitcoin.Tx.prototype.isConfirmed = function (latestBlock, minConfirmations) {
          if (minConfirmations === undefined)
              minConfirmations = 1;
      
          return (this.getBlock().getHeight() !== undefined && latestBlock.getHeight() - this.getBlock().getHeight() >=  minConfirmations - 1);
      };
      
      /**
       * Returns the transaction type
       *
       * @param  {Array.Endpoint} The list of wallet endpoints (used to identify change)
       * @return {Integer}        The transaction amount in Satoshis
       */
      Verso.Bitcoin.Tx.prototype.getAmount = function (ep) {
          ep = Verso.Bitcoin.Endpoint.toList(ep);
      
          var amount = this.getOuts()
                             .filter(function (to) { return ep.some(function (e) { return e.sameAs(to.getEndpoint()); }); })
                             .reduce(function (prev, curr) { return prev + curr.getAmount(); }, 0) -
                       this.getIns()
                             .filter(function (ti) { return ep.some(function (e) { return e.sameAs(ti.getEndpoint()); }); })
                             .reduce(function (prev, curr) { return prev + curr.getAmount(); }, 0);
      
          var otherOut = this.getOuts().filter(function (to) { return !ep.some(function (e) { return e.sameAs(to.getEndpoint()); }); });
      
          if (amount < 0 && (otherOut.length > 0 || this.getOuts().length === 0)) {
              return amount + this.getFees();
          }
          else if (amount <= 0 && otherOut.length === 0 && this.getOuts().length > 0) {
              return -this.getOuts().reduce(function (prev, curr) { return prev + curr.getAmount(); }, 0);
          }
      
          return amount;
      };
      
      /**
       * Returns the main endpoint of the transaction (e.g. largest output for outgoing transactions, largest input for incoming transactions)
       *
       * @param  {Array.Endpoint} The list of wallet endpoints (used to identify change)
       * @return {Integer}        The main endpoint
       */
      Verso.Bitcoin.Tx.prototype.getMainEndpoint = function (ep) {
          var amount = this.getOuts()
                         .filter(function (to) { return ep.some(function (e) { return e.sameAs(to.getEndpoint()); }); })
                         .reduce(function (prev, curr) { return prev + curr.getAmount(); }, 0) -
                       this.getIns()
                         .filter(function (ti) { return ep.some(function (e) { return e.sameAs(ti.getEndpoint()); }); })
                         .reduce(function (prev, curr) { return prev + curr.getAmount(); }, 0);
      
          var otherOut = this.getOuts().filter(function (to) { return !ep.some(function (e) { return e.sameAs(to.getEndpoint()); }); });
      
          if (amount < 0 && otherOut.length > 0) {
              return otherOut.sort(function (a, b) { return b.getAmount() - a.getAmount(); })[0].getEndpoint();
          }
          else if (amount <= 0 && otherOut.length === 0 && this.getOuts().length > 0) {
              return this.getOuts().sort(function (a, b) { return b.getAmount() - a.getAmount(); })[0].getEndpoint();
          }
          else if (amount > 0) {
              return this.getIns()
                              .filter(function (ti) { return !ep.some(function (e) { return e.sameAs(ti.getEndpoint()); }); })
                              .sort(function (a, b) { return b.getAmount() - a.getAmount(); })[0]
                              .getEndpoint();
          }
      
          return false;
      };
      
      /**
       * Bitcoin block
       *
       * @param {Integer} [height] The height of the block
       */
      Verso.Bitcoin.Block = function (height) {
          this.getHeight = function () { return height; };
      };
      
      
      /**
       * Bitcoin wallet
       *
       * @constructor
       * @param  {Endpoint} ep                 Endpoint or list of enpoints used by the wallet
       * @param  {Function} [changeMethod]     Function selecting the change address, main address by default
       * @param  {Number}   [minConfirmations] Minimum number of confirmations for balance (2 by default)
       * @param  {Number}   [defaultFee]       Default fee amount in Satoshis (50000 by default)
       * @param  {Object}   [provider]         Object providing Bitcoin services (Verso.Bitcoin.Providers.Blockchain by default)
       */
      Verso.Bitcoin.Wallet = function (ep, changeMethod, minConfirmations, defaultFee, provider) {
          var bitcoin = Verso.Bitcoin,
              encoding = Verso.Encoding;
      
          var that = this;
          var endpoints = [];
          var transactions = [];
          var balance = 0;
          var balancePending = 0;
          var onTx = [];
          var onBalance = [];
          var fetchTime;
          var unspents;
      
          if (changeMethod === undefined || changeMethod === null)
              changeMethod = function (e) { return that.getEndpoint(); };
          if (minConfirmations === undefined || minConfirmations < 1)
              minConfirmations = 2;
          if (defaultFee === undefined)
              defaultFee = 10000; // TODO: Make this dependent on transaction size
          if (provider === undefined)
              provider = bitcoin.Providers.Blockchain;
      
          /** Adds enpoints to the wallet */
          this.addEndpoints = function (e) {
              e = bitcoin.Endpoint.toList(e);
      
              for (var i = 0; i < e.length; i++) {
                  var exists = false;
      
                  for (var j = 0; j < endpoints.length; j++) {
                      if (endpoints[j].sameAs(e[i])) {
                          if (!e[i].isWatchOnly())
                              endpoints[j] = e[i];
                          exists = true;
                          break;
                      }
                  }
      
                  if (!exists) {
                      endpoints.push(e[i]);
                  }
              }
          };
      
          this.addEndpoints(ep);
      
          /** Returns the main endpoint */
          this.getEndpoint = function () {
              return endpoints[0];
          };
      
          /** Returns a copy of the wallet endpoints */
          this.getEndpoints = function () {
              return endpoints.slice(0);
          };
      
          /** Returns the next endpoint used for change and adds it to the wallet endpoints */
          this.nextChangeEndpoint = function () {
              var change = changeMethod(that);
              that.addEndpoints(change);
      
              return change;
          };
      
          /** Sets the change method */
          this.setChangeMethod = function (method) {
              changeMethod = method;
          };
      
          /** Returns the Bitcoin service provider */
          this.getProvider = function () {
              return provider;
          };
      
          /** Makes all endpoints watch-only */
          this.makeWatchOnly = function () {
              endpoints = endpoints.map( function(ep) { return ep.asWatchOnly(); });
          };
      
          /** Returns a spendable copy of the wallet */
          this.makeSpendable = function (eps) {
              eps = bitcoin.Endpoint.toList(eps);
      
              endpoints = endpoints.map(function (ep) {
                  e = eps.filter(function (ee) { return ee.sameAs(ep); });
      
                  if (e.length > 0)
                      return e[0];
                  return ep;
              });
          };
      
          /** Adds transactions to the wallet */
          this.addTransactions = function (txs, all) {
              if(!Array.isArray(txs))
                  txs = [txs];
      
              var newTx = [];
              var newConfirm = false;
              var i;
      
              for (i = 0; i < txs.length; i++) {
                  if (!txs[i].hasEndpoints(that.getEndpoints())) {
                      continue;
                  }
      
                  var exists = transactions.some(function (t) { return t.sameAs(txs[i]); });
      
                  if (!exists) {
                      transactions.push(txs[i]);
                      newTx.push(txs[i]);
                  } else if(txs[i].getBlock().getHeight() !== undefined) {
                      var tx = transactions.filter(function (t) { return t.sameAs(txs[i]); })[0];
      
                      if (tx.getBlock().getHeight() === undefined) {
                          tx.setBlock(txs[i].getBlock());
                          newConfirm = true;
                      }
                  }
              }
      
              if (newTx.length > 0 || newConfirm) {
                  for (i = 0; i < onTx.length; i++) {
                      try {
                          onTx[i](that, newTx);
                      } catch (e) {}
                  }
              }
      
              if (all)
                  fetched = true;
          };
      
          /** Returns a copy of the wallet transactions */
          this.getTransactions = function () {
              return transactions.slice(0);
          };
      
          /** Clears transactions kept in the wallet */
          this.clearTransactions = function () {
              transactions = [];
          };
      
          /** Adds a transaction event handler */
          this.addTransactionEventHandler = function (event) {
              onTx.push(event);
          };
      
          /** Removes a transaction event handler */
          this.removeTransactionEventHandler = function (event) {
              var i = onTx.indexOf(event);
      
              if (i > -1)
                  onTx.splice(i, 1);
          };
      
          provider.subscribeBlock(function (block) {
              // Check whether previously unconfirmed txs are now in blockchain
              if (transactions.some(function (tx) { return tx.getBlock().getHeight() === undefined; }))
                  that.fetch();
          });
      
          this.setBalance = function (bal, pending) {
              if (pending === undefined)
                  pending = balancePending;
      
              if (bal != balance || balancePending != pending) {
                  balance = bal;
                  balancePending = pending;
      
                  for (var i = 0; i < onBalance.length; i++) {
                      try {
                          onBalance[i](that, balance, balancePending);
                      } catch (e) { }
                  }
              }
          };
      
          /** Returns the confirmed wallet balance */
          this.getBalance = function () {
              return balance;
          };
      
          /** Returns the unconfirmed wallet balance */
          this.getBalancePending = function () {
              return balancePending;
          };
      
          /** Adds a balance event handler */
          this.addBalanceEventHandler = function (event) {
              onBalance.push(event);
          };
      
          /** Removes a balance event handler */
          this.removeBalanceEventHandler = function (event) {
              var i = onBalance.indexOf(event);
      
              if (i > -1)
                  onBalance.splice(i, 1);
          };
      
          /** Returns the minimum number of confirmations used to compute balance */
          this.getMinConfirmations = function () {
              return minConfirmations;
          };
      
          /** Returns the default fee */
          this.getDefaultFee = function () {
              return defaultFee;
          };
      
          /** Sets the default fee */
          this.setDefaultFee = function (fee) {
              defaultFee = fee;
          };
      
          /** Returns the time of the last fetch */
          this.getFetchTime = function () {
              return fetchTime;
          };
      
          /** Sets the time of last fetch */
          this.setFetchTime = function (time) {
              if(fetchTime === undefined || time > fetchTime)
                  fetchTime = time;
          };
      
          /** Sets the usable unspents */
          this.setUnspents = function (u) {
              unspents = u;
          };
      
          /** Returns the fee in satoshis for the next payment */
          this.getCurrentFee = function () {
              return this.getDefaultFee();
          };
      };
      
      /**
       * Fetches all wallet information (e.g. transactions, balance, latest block, unspent)
       *
       * @param  {Function} [onResult]  Callback for transactions, balance, pending balance and unspent outputs
       * @param  {Function} [onBalance] Callback for balance, pending balance and unspent outputs
       * @param  {Function} [onError]   Callback in case of error
       */
      Verso.Bitcoin.Wallet.prototype.fetch = function (onResult, onError) {
          var that = this;
      
          this.getProvider().fetchTx(
              that.getEndpoints(),
              function (txs) {
                  that.addTransactions(txs, true);
      
                  that.getProvider().fetchUnspent(that.getEndpoints(), function (ins) {
                      var bal;
                      var pending;
      
                      var usable = ins.filter(function (i) {
                          var conf = i.confirmations >= that.getMinConfirmations();
      
                          var tx = that.getTransactions().filter(function (t) { return t.sameAs(i.getHash()); });
      
                          // Allow using unconfirmed inputs if they come from the wallet (e.g. change)
                          return conf || (tx.length == 1 && tx[0].getIns().every(function (ii) { return that.getEndpoints().some(function (ep) { return ep.sameAs(ii.getEndpoint()); }); }));
                      });
      
                      bal = usable.reduce(function (i, j) { return i + j.getAmount(); }, 0);
                      pending = ins.reduce(function (i, j) { return i + j.getAmount(); }, 0) - bal;
      
                      that.setBalance(bal, pending);
                      that.setUnspents(usable);
      
                      that.setFetchTime(new Date());
      
                      try
                      {
                          if (onResult)
                              onResult(txs, bal, pending, usable);
                      }
                      catch (e) {
                      }
                  },
                  onError);
              },
              onError
          );
      };
      
      /**
       * Sends Bitcoins from the wallet to a given address
       *
       * @param  {Endpoint|String|ByteArray} to          The destination endpoint (can be the public hash in Base58Check or byte array format)
       * @param  {Number}                    amount      The amount to send (in satoshis)
       * @param  {Number}                    [fee]       The fee for the transaction
       * @param  {Function}                  [onSuccess] Callback in case of success
       * @param  {Function}                  [onError]   Callback in case of error
       */
      Verso.Bitcoin.Wallet.prototype.send = function (to, amount, fee, onSuccess, onError) {
          var encoding = Verso.Encoding;
          var bitcoin = Verso.Bitcoin;
      
          if (to === undefined) {
              throw new Verso.Error("Invalid destination");
          }
          if (amount === undefined || amount <= 0) {
              throw new Verso.Error("Invalid amount");
          }
          if (fee === undefined) {
              fee = this.getDefaultFee();
          } else if (fee > 1e5) {
              fee = 1e5;
          }
          if (!(to instanceof bitcoin.Endpoint)) {
              to = new bitcoin.Endpoint(to);
          }
      
          var that = this;
          amount = Math.round(amount); // in satoshis
          fee = Math.round(fee);
      
          this.fetch(
              function (txs, balance, pending, ins) {
                  try {
                      // Select inputs
                      ins = ins.filter(function (i) { return !i.getEndpoint().isWatchOnly(); })
                               .sort(function (a, b) { // Sort by decreasing age
                                   var blocka, blockb;
      
                                   var txa = txs.filter(function (t) {
                                       return t.sameAs(a.getHash());
                                   })[0];
                                   if (txa !== undefined) {
                                      blocka = txa.getBlock().getHeight();
                                   } else {
                                      blocka = 0;
                                   }
      
                                   var txb = txs.filter(function (t) {
                                       return t.sameAs(b.getHash());
                                   })[0];
                                   if (txb !== undefined) {
                                      blockb = txb.getBlock().getHeight();
                                   } else {
                                      blockb = 0;
                                   }
      
                                   if (blocka === undefined && blockb === undefined) {
                                       return 0;
                                   } else if (blocka === undefined && blockb !== undefined) {
                                       return 1;
                                   } else if (blockb === undefined && blocka !== undefined) {
                                       return -1;
                                   } else {
                                       return blocka - blockb;
                                   }
                               });
      
                      balance = 0;
                      var i = 0, selectedIns = [];
                      while (i < ins.length && balance < amount + fee) {
                          balance += ins[i].getAmount();
                          selectedIns.push(ins[i]);
                          i++;
                      }
      
                      var change = balance - (amount + fee);
      
                      if (change >= 0) {
                          var outs = [new bitcoin.TxOut(to, amount)];
      
                          if (change > 0)
                              outs.push(new bitcoin.TxOut(that.nextChangeEndpoint(), change));
      
                          that.getProvider().send(new Verso.Bitcoin.Tx(selectedIns, outs), onSuccess, onError);
                      }
                      else if (onError) {
                          onError(new Verso.BalanceError("Insufficient balance!"));
                      }
                  }
                  catch (err) {
                      if (onError)
                          onError(new Verso.Error("Transaction interrupted!"));
                  }
              },
              onError
          );
      };
      
      /**
      * Redeem an Endpoint
      *
      * @param  {Endpoint|String|ByteArray} source      The source endpoint
      * @param  {Number}                    [fee]       The fee for the transaction
      * @param  {Function}                  [onSuccess] Callback in case of success
      * @param  {Function}                  [onError]   Callback in case of error
      */
      Verso.Bitcoin.Wallet.prototype.redeem = function (source, fee, onSuccess, onError) {
          var that = this;
      
          this.getProvider().fetchUnspent(source, function (ins) {
              try {
                  var balance = ins.reduce(function (i, j) { return i + j.getAmount(); }, 0);
      
                  if (fee === undefined) {
                      fee = this.getDefaultFee();
                  } else if (fee > 1e5) {
                      fee = 1e5;
                  }
      
                  if (balance > 0) {
                      var outs = [new bitcoin.TxOut(that.getEndpoint(), balance - fee)];
      
                      that.getProvider().send(new Verso.Bitcoin.Tx(ins, outs), onSuccess, onError);
                  }
                  else if (onError) {
                      onError(new Verso.BalanceError("No funds to redeem!"));
                  }
              }
              catch (err) {
                  if (onError)
                      onError(new Verso.Error("Transaction interrupted!"));
              }
          },
          onError
          );
      };
      
      /**
       * Wrapper for main services of Blockchain.info (in particular, unspent outputs, address transactions history, transaction broadcast)
       */
      Verso.Bitcoin.Providers.Blockchain = (function () {
          var encoding = Verso.Encoding,
              bitcoin = Verso.Bitcoin,
              that = this;
      
          var latestBlock = new Verso.Bitcoin.Block(); // Keeps track of latest block (updated when adequate service is called)
          var onBlock;
      
          var setLatestBlock = function (block) {
              if (latestBlock.getHeight() === undefined || block.getHeight() > latestBlock.getHeight()) {
                  latestBlock = block;
      
                  if (onBlock) {
                      try {
                          onBlock(latestBlock);
                      } catch (err) {
      
                      }
                  }
              }
          };
      
          /** Returns the latest block */
          var getLatestBlock = function () {
              return latestBlock;
          };
      
          /** Subscribes a callback to a new-block event */
          var subscribeBlock = function (callback) { // TODO: allow for multiple callbacks
              onBlock = callback;
          };
      
          var fetch = function (url, onSuccess, onError, data, method) {
              jQuery.ajax({
                  type: (method === undefined) ? "GET" : method,
                  url: url,
                  data: data,
                  success: function (res) {
                      if (onSuccess)
                          onSuccess(res);
                  },
                  error: function (xhr, opt, err) {
                      if (onError)
                          onError(new Verso.ConnectionError("Error connecting the server!", xhr));
                  }
              });
          };
      
          var foldEndpoints = function (ep) {
              var addr = "";
              for (var i = 0; i < ep.length; i++) {
                  addr += ep[i].getAddress();
                  if (i < ep.length - 1)
                      addr += "|";
              }
      
              return addr;
          };
      
          /**
           * Fetches unspent outputs of a sent of endpoints
           *
           * @memberOf Verso.Providers.Blockchain
           * @param {Endpoint} ep        An endpoint or an array of endpoints
           * @param {Function} onUnspent Function called with unspent outputs in case of success
           * @param {Function} onError   Function called in case of error
           */
          var fetchUnspent = function (ep, onUnspent, onError) {
              ep = bitcoin.Endpoint.toList(ep);
      
              var addr = foldEndpoints(ep);
      
              var url = "https://blockchain.info/unspent";
              var data = { cors: true, active: addr };
      
              var parseUnspent = function (data) {
                  var txs = data.unspent_outputs;
      
                  var unspent = [];
      
                  for (var i = 0; i < txs.length; i++) {
                      var conf = parseInt(txs[i].confirmations);
                      var script = encoding.base16ToBytes(txs[i].script);
      
                      var hash = encoding.base16ToBytes(txs[i].tx_hash).reverse();
                      var amount = parseInt(txs[i].value, 10);
                      var index = txs[i].tx_output_n;
                      var sequence = [0xFF, 0xFF, 0xFF, 0xFF];
      
                      if (script.length == 25 && script[0] == 118 && script[1] == 169 && script[23] == 136 && script[24] == 172) { // accept only standard tx for the timing
                          var e = new bitcoin.Endpoint(script.slice(3, 23));
      
                          for (var j = 0; j < ep.length; j++) {
                              if (ep[j].sameAs(e)) {
                                  e = ep[j];
                                  break;
                              }
                          }
      
                          if (e !== null) {
                              var tin = new bitcoin.TxIn(e, amount, hash, index, script, sequence);
                              tin.confirmations = conf;
      
                              unspent.push(tin);
                          }
                      }
                  }
      
                  return unspent;
              };
      
              fetch(url,
                  function (data) {
                      try {
                          if (onUnspent)
                              onUnspent(parseUnspent(data));
                      }
                      catch (e) {
                          if (onError)
                              onError(new Verso.ConnectionError("Cannot parse server data!"));
                      }
                  },
                  function (error) {
                      if (error.xhr.responseText === "No free outputs to spend") {
                          if (onUnspent)
                              onUnspent([]);
                      } else {
                          if (onError)
                              onError(error);
                      }
                  }, data);
          };
      
          /**
           * Fetches transactions related to a set of endpoints
           *
           * @memberOf Verso.Providers.Blockchain
           * @param {Endpoint} ep        An endpoint or an array of endpoints
           * @param {Function} onSuccess Function called with parsed transactions in case of success
           * @param {Function} onError   Function called in case of error
           */
          var fetchTx = function (ep, onSuccess, onError) {
              var parseTx = function (txs) {
                  var res = [];
      
                  for (var i = 0; i < txs.length; i++) {
                      var hash = encoding.base16ToBytes(txs[i].hash);// seems that it is already big endian      .reverse();
                      var time = new Date(parseInt(txs[i].time) * 1000); // unix timestamp
                      var idx = txs[i].tx_index;
                      var block;
                      var k, amount, endpoint;
      
                      if (txs[i].block_height !== undefined) {
                          block = new bitcoin.Block(parseInt(txs[i].block_height));
                      }
                      else {
                          block = new bitcoin.Block();
                      }
      
                      var txin = [];
                      for (k = 0; k < txs[i].inputs.length; k++) {
                          amount = parseInt(txs[i].inputs[k].prev_out.value, 10);
                          endpoint = new bitcoin.Endpoint(txs[i].inputs[k].prev_out.addr);
      
                          txin.push(new bitcoin.TxIn(endpoint, amount));
                      }
      
                      var txout = [];
                      for (k = 0; k < txs[i].out.length; k++) {
                          amount = parseInt(txs[i].out[k].value, 10);
                          endpoint = new bitcoin.Endpoint(txs[i].out[k].addr);
      
                          txout.push(new bitcoin.TxOut(endpoint, amount));
                      }
      
                      res.push(new bitcoin.Tx(txin, txout, hash, block, time, idx));
                  }
      
                  return res;
              };
      
              var that = this;
              ep = bitcoin.Endpoint.toList(ep);
      
              var addr = foldEndpoints(ep);
      
              var url = "https://blockchain.info/multiaddr";
              var data = { cors: true, active: addr };
      
              fetch(url, function (data) {
                  var parsed;
      
                  try {
                      setLatestBlock(new bitcoin.Block(data.info.latest_block.height));
      
                      if (onSuccess)
                          onSuccess(parseTx(data.txs));
                  }
                  catch (e) {
                      if (onError)
                          onError(new Verso.ConnectionError("Cannot parse server data!"));
                  }
              }, onError, data);
          };
      
          /**
           * Fetches the latest block found
           *
           * @memberOf Verso.Providers.Blockchain
           * @param {Function} onSuccess Function called with the latest block in case of success
           * @param {Function} onError   Function called in case of error
           */
          var fetchLatestBlock = function (onSuccess, onError) {
              var url = "https://blockchain.info/q/getblockcount";
              var data = { cors: true };
      
              var onFetchSuccess = function (data) {
                  try {
                      setLatestBlock(new bitcoin.Block(parseInt(data)));
      
                      if (onSuccess)
                          onSuccess(latestBlock);
                  } catch (e) {
                      if (onError)
                          onError(new Verso.ConnectionError("Cannot parse server data!"));
                  }
              };
      
              fetch(url, onFetchSuccess, onError, data);
          };
      
          /**
           * Broadcasts a transaction through Blockchain.info
           *
           * @memberOf Verso.Providers.Blockchain
           * @param {Verso.Bitcoin.Transaction} tx Transaction to broadcast
           * @param {Function} onSuccess Function called with the latest block in case of success
           * @param {Function} onError   Function called in case of error
           */
          var send = function (tx, onSuccess, onError) {
              tx = encoding.bytesToBase16(tx.serialize());
      
              var url = 'https://blockchain.info/pushtx';
              var data = { cors: true, tx: tx };
      
              fetch(url, onSuccess, onError, data, "POST");
          };
      
          return {
              getLatestBlock: getLatestBlock,
              subscribeBlock: subscribeBlock,
              fetchUnspent: fetchUnspent,
              fetchTx: fetchTx,
              fetchLatestBlock: fetchLatestBlock,
              send: send
          };
      })();
      /*
      VersoLib-JS v0.9.3
      http://github.com/VersoSolutions/VersoLib-JS
      Copyright (c) 2013 Verso Solutions LLC
      http://github.com/VersoSolutions/VersoLib-JS/blob/master/LICENSE
      */
      
      /**
       * Wrapper for services of versocards.com
       */
      Verso.Services = (function () {
          var encoding = Verso.Encoding;
      
          /**
           * Get card information associated to an authID
           *
           * @param  {ByteArray}  authID   The card authID
           * @param  {Function}   onInfos  Function called when the card name is received
           * @param  {Function}   onError  Function called in case of error
           */
          var cardDetails = function (authID, onInfos, onError) {
              $.ajax({
                  type: "POST",
                  url: "https://versocards.com/api/cardDetails/",
                  data: {
                      "authID": encoding.bytesToBase16(authID)
                  },
                  success: function (res) {
                      res = JSON.parse(res);
      
                      if (!res.error) {
                          onInfos({ name: res.name });
                      }
                      else if (onError) {
                          onError(new Verso.CredentialsError("Invalid credentials!"));
                      }
                  },
                  error: function (xhr, opt, err) {
                      if (onError)
                          onError(new Verso.ConnectionError("Connection problem!"));
                  }
              });
          };
      
          /**
           * Get the indices of the deterministic addresses associated to an authID (e.g. k for m/k such as in BIP0032)
           *
           * @param  {ByteArray}  authID   The card authID
           * @param  {Function}   onInfos  Function called when the card name is received
           * @param  {Function}   onError  Function called in case of error
           */
          var indices = function (authID, onIndices, onError) {
              // TODO: Finish this.
              onIndices([]);
              return;
      
              // jQuery.ajax({
              //     type: "POST",
              //     url: "https://versocards.com/api/indices/",
              //     data: {
              //         "authID": encoding.bytesToBase16(authID)
              //     },
              //     success: function (res) {
              //         res = JSON.parse(res);
      
              //         if (!res.error) {
              //             var indices = [];
      
              //             for (var i = 0; i < res.indices; i++) {
              //                 indices.push(parseInt(res.onIndices[i]));
              //             }
              //             onIndices({ name: res.name });
              //         }
              //         else if (onError) {
              //             onError(new Verso.CredentialsError("Invalid credentials!"));
              //         }
              //     },
              //     error: function (xhr, opt, err) {
              //         if (onError)
              //             onError(new Verso.ConnectionError("Connection problem!"));
              //     }
              // });
          };
      
          /**
           * Get the encrypted seed share associated to a Gold Card
           *
           * @param  {ByteArray}  authID   The card authID
           * @param  {ByteArray}  authKey  The user authKey
           * @param  {Function}   onShare  Function called when the share is received
           * @param  {Function}   onError  Function called in case of error
           */
          var seedShare = function (authID, authKey, onShare, onError) {
              $.ajax({
                  type: "POST",
                  url: "https://versocards.com/api/seedShare/",
                  data: {
                      "authID": encoding.bytesToBase16(authID),
                      "authKey": encoding.bytesToBase16(authKey)
                  },
                  success: function (res) {
                      res = JSON.parse(res);
      
                      if (res.seed !== undefined && res.seed != "false") {
                          onShare(encoding.base16ToBytes(res.seed));
                      }
                      else if (onError) {
                          onError(new Verso.CredentialsError("Invalid credentials!"));
                      }
                  },
                  error: function (xhr, opt, err) {
                      if (onError)
                          onError(new Verso.ConnectionError("Connection problem!"));
                  }
              });
          };
      
          /**
           * Get some entropy from server /dev/urandom
           *
           * @param  {ByteArray}  authID     The card authID
           * @param  {Integer}    n          The number of desired bytes
           * @param  {Function}   onEntropy  Function called when the entropy is received
           * @param  {Function}   [onError]  Function called in case of error
           */
          var entropy = function (authID, n, onEntropy, onError) {
              $.ajax({
                  type: "POST",
                  url: "https://versocards.com/api/entropy/",
                  data: {
                      "authID": encoding.bytesToBase16(authID),
                      "nBytes": n
                  },
                  success: function (res) {
                      res = JSON.parse(res);
      
                      if (res.entropy !== undefined && res.seed != "false") {
                          onEntropy(encoding.base16ToBytes(res.entropy));
                      }
                      else if (onError) {
                          onError(new Verso.CredentialsError("Invalid credentials!"));
                      }
                  },
                  error: function (xhr, opt, err) {
                      if (onError)
                          onError(new Verso.ConnectionError("Connection problem!"));
                  }
              });
          };
      
          return {
              cardDetails: cardDetails,
              seedShare: seedShare,
              entropy: entropy
          };
      })();
      
      Verso.Settings.rsaKey = {
          modulus: "87784cf8f6feb6c9d78c7a81b58f34c0e83d39b9170c7bd0fd12de7c6ea69dfa783fb7fef5752b444ac407427b584eb6ae52b58785013d8d59d3704da6e5d9780e665e63254c04c7aa92cdbc31fbfe56255e9b21738a96bab016c05ed3b4dcf4bd4d16c87b9106b9dfaa04c258107621ac8c15b9e01cc273f13549d701d91d2f7150c1320f14cfe597bd8f8cf740e68e40861ad36fdb9d1688a7edfe90b50f38439df14ed264ed2318e05597cb3d246fd117a8fbe7ab39ab46fdc9a4fa95c4c260b8fd8649239a7f49944b1dd7305c3587df069a187c794faaa448e371348c3d520ef0d619e7af7d4bce79c0be65135d37ca06bd1d118567f1ba0ee54a94e3a5",
          exponent: "010001"
      };
      
      /**
       * The generic Verso Card providing basic properties unrelated to the wallet
       *
       * @constructor
       * @param {Array}  [cardKey] Key of the card, randomly generated if undefined
       */
      Verso.Card = function (cardKey) {
          var encoding = Verso.Encoding,
              cryptography = Verso.Cryptography,
              bitcoin = Verso.Bitcoin;
      
          if (cardKey === undefined)
              cardKey = cryptography.randomBytes(16); // Create new card
      
          var authID = cryptography.SHASHASHA256(cardKey).slice(0, 16);
      
          /** Returns the card's cardKey */
          this.getCardKey = function () { return cardKey; };
          /** Returns the card's authID */
          this.getAuthID = function () { return authID; }; // AuthID is used to authentify the card on the Verso server
          /** Returns the salt used in PBKDF2 */
          this.getSalt = function () { return cryptography.SHA256(cardKey); }; // Salt is used as an input of the key derivation function
          /** Returns the IV used in AES */
          this.getIV = function () { return cryptography.SHASHA256(cardKey).slice(0, 16); }; // IV is used as an input of the AES encryptor
          /** Returns the user key used to decrypt encSeed */
          this.getUserKey = function (password) { return cryptography.PBKDF2(password, this.getSalt(), 500); }; // UserKey is used to encrypt/decrypt the bitcoin private key
          /** Returns the auth key used to authentify the card on the web server, where data is either the password or the userKey */
          this.getAuthKey = function (data) { // AuthKey is used to authentify the user on the Verso Server
              if (!Array.isArray(data))
                  data = this.getUserKey(data);
      
              return cryptography.SHA256(data).slice(0, 16);
          };
      };
      
      /** Returns the encrypted seed, where key is either the password or the userKey
       *
       * @param {Array}  seed   Seed to be encrypted
       * @param {Array}  [key]  Key or password used to encrypt the seed
       * @return Encrypted seed
       */
      Verso.Card.prototype.encryptSeed = function (seed, key) {
          var cryptography = Verso.Cryptography;
      
          if (!Array.isArray(key))
              key = this.getUserKey(key);
      
          return cryptography.aesEncrypt(seed, key, this.getIV());
      };
      
      /** Returns the wallet derived from a seed or a master endpoint
       *
       * @param {Array|MasterEndpoint}  data   Seed or MasterEndpoint from which wallet is derived
       * @return Wallet associated to the card
      */
      Verso.Card.prototype.deriveWallet = function (data) {
          var bitcoin = Verso.Bitcoin;
      
          if (Array.isArray(data))
              return new bitcoin.Wallet(new bitcoin.MasterEndpoint(data).getChild());
          else if (data instanceof bitcoin.ExtendedEndpoint && data.isMaster())
              return new bitcoin.Wallet(data.getChild());
      
          throw new Verso.Error("Invalid argument!");
      };
      
      /**
       * The Verso Silver corresponding to the data in a private QR code.
       *
       * @constructor
       * @param {Array}  cardKey   Key of the card
       * @param {Array}  encSeed   Encrypted seed of the card
       * @param {Array}  pubHash   Public key has of the card
       */
      Verso.SilverCard = function (cardKey, encSeed, pubHash) {
          Verso.Card.call(this, cardKey);
      
          var endpoint = new Verso.Bitcoin.Endpoint(pubHash);
      
          /** Returns the card's version */
          this.getVersion = function () { return 0; };
          /** Returns the encrypted seed of the card */
          this.getEncSeed = function () { return encSeed; };
          /** Returns the public hash of the card */
          this.getPublicHash = function() { return pubHash; };
          /** Returns the endpoints of the card */
          this.getEndpoints = function (password, all, onResult, onError) { // TODO: implement "all" with determinism
              var cryptography = Verso.Cryptography;
      
              if(password) {
                  var seed = cryptography.aesDecrypt(this.getEncSeed(), this.getUserKey(password), this.getIV());
      
                  try {
                      var ep = new Verso.Bitcoin.MasterEndpoint(seed).getChild();
      
                      if (ep.sameAs(this.getPublicHash())) {
                          onResult([ep]);
                      }
                      else {
                          onError(new Verso.CredentialsError("Invalid password!"));
                      }
                  } catch (e) {
                      onError(new Verso.Error(e.toString()));
                  }
              }
              else {
                  onResult([endpoint]);
              }
          };
      };
      
      Verso.SilverCard.prototype = Verso.Class.inherit(Verso.Card.prototype);
      
      /**
       * Serialize card
       *
       * @return Serialized card with private side format
       */
      Verso.SilverCard.prototype.serialize = function () {
          var encoding = Verso.Encoding;
      
          return encoding.bytesToBase94(this.getVersion()) + " " + encoding.bytesToBase94(this.getCardKey()) + " " + encoding.bytesToBase94(this.getEncSeed()) + " " + encoding.bytesToBase94(this.getPublicHash());
      };
      
      /**
       * The Verso Gold corresponding to the data in a private QR code.
       *
       * @constructor
       * @param {Array}  cardKey   Key of the card
       * @param {Array}  encSeed1  Encrypted seed share of the card
       * @param {Array}  pubHash   Public key hash of the card
       */
      Verso.GoldCard = function (cardKey, encSeed1, pubHash) {
          Verso.Card.call(this, cardKey);
      
          var cryphography = Verso.Cryptography,
              bitcoin = Verso.Bitcoin;
      
          var endpoint = new bitcoin.Endpoint(pubHash);
      
          /** Returns the card's version */
          this.getVersion = function () { return 1; };
          /** Returns the encrypted seed share of the card */
          this.getEncSeed1 = function () { return encSeed1; };
          /** Returns the public hash of the card */
          this.getPublicHash = function () { return pubHash; };
          /** Returns the endpoints of the card */
          this.getEndpoints = function (password, all, onResult, onError, encEncSeedShare) { // TODO: implement "all" with determinism
              var cryptography = Verso.Cryptography,
                  encoding = Verso.Encoding;
              var that = this;
      
              if (password) {
                  var userKey = that.getUserKey(password);
      
                  var onSeedShare = function (encEncSeedShare) {
                      var encSeedShare = cryptography.aesDecrypt(encEncSeedShare, that.getCardKey());
                      var encSeed = cryptography.secretCombine([that.getEncSeed1(), encSeedShare]);
                      var seed = cryptography.aesDecrypt(encSeed, userKey, that.getIV());
      
                      try {
                          var ep = new Verso.Bitcoin.MasterEndpoint(seed).getChild();
      
                          if (ep.sameAs(that.getPublicHash())) {
                              onResult([ep]);
                          }
                          else {
                              onError(new Verso.CredentialsError("Invalid password!"));
                          }
                      } catch (e) {
                          onError(new Verso.Error(e.toString()));
                      }
                  };
      
                  if (encEncSeedShare) {
                      onSeedShare(encEncSeedShare);
                  } else {
                      Verso.Services.seedShare(that.getAuthID(), that.getAuthKey(userKey), onSeedShare, onError);
                  }
              } else {
                  onResult([endpoint]);
              }
          };
      };
      
      Verso.GoldCard.prototype = Verso.Class.inherit(Verso.Card.prototype);
      
      /**
       * Serialize card
       *
       * @return Serialized card with private side format
       */
      Verso.GoldCard.prototype.serialize = function () {
          var encoding = Verso.Encoding;
      
          return encoding.bytesToBase94(this.getVersion()) + " " + encoding.bytesToBase94(this.getCardKey()) + " " + encoding.bytesToBase94(this.getEncSeed1()) + " " + encoding.bytesToBase94(this.getPublicHash());
      };
      
      /** Returns the watch-only endpoint corresponding to the card public or private side data */
      Verso.Card.parsePublic = function (data) {
          var encoding = Verso.Encoding;
      
          if (!data) return false;
      
          var pub = new RegExp("^(?:bitcoin:)?(1[a-zA-Z0-9]+)(?:\\?[a-zA-Z]+=[^&=]+(&[a-zA-Z]+=[^&=]+)*)?$");
      
          if (pub.test(data)) {
              try {
                  return new Verso.Bitcoin.Endpoint(pub.exec(data)[1]);
              } catch (e) {
                  return false;
              }
          }
      
          try {
              var items = data.split(" ").map(function (item) { return encoding.base94ToBytes(item); });
      
              var version = items[0][0];
      
              if (version === 0 || version === 1)
                  return new Verso.Bitcoin.Endpoint(items[3]);
          }
          catch (e) {}
      
          return false;
      };
      
      /** Returns the Card corresponding to the card private side data
       *
       * @param {String}  data   Content of the QR code
       * @return Card corresponding to the private QR code
      */
      Verso.Card.parsePrivate = function (data) {
          var encoding = Verso.Encoding;
      
          if (!data)
              return false;
      
          try {
              var items = data.split(" ").map(function (item) { return encoding.base94ToBytes(item); });
      
              var version = items[0][0];
              var cardKey = items[1];
              var tmp = items.slice(2);
      
              if (version === 0)
                  return new Verso.SilverCard(cardKey, tmp[0], tmp[1]);
              else if (version === 1)
                  return new Verso.GoldCard(cardKey, tmp[0], tmp[1]);
          }
          catch (e) { }
      
          return false;
      };
      
      /**
       * Currency and exchange rate
       *
       * @constructor
       * @param {String}  Ticker The ticker of the currency
       * @param {Number}  The exchange rate with respect to bitcoin
       */
      Verso.Currency = function (ticker, rate) {
          this.getTicker = function () {
              return ticker;
          };
      
          this.getRate = function () {
              return rate;
          };
      };
      
      /** Fetches the exchange rates
       * 
       * @param {Function}  onCurrencies Function called with the list of currencies in case of success
       * @param {Function}  onError      Function called in case of error
       */
      Verso.Currency.fetch = function (onCurrencies, onError) {
          $.ajax({
              type: "GET",
              url: "https://blockchain.info/ticker",
              data: { cors: true },
              success: function (data) {
      
                  if (data.USD) {
                      var XBTUSD = parseFloat(data.USD.last);
      
                      jQuery.ajax({
                          type: "GET",
                          url: "http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml",
                          data: { cors: true },
                          cache: false,
                          dataType: "xml",
                          success: function (xml) {
      
                              try {
                                  var pairs = [];
                                  $(xml).find('Cube').each(function () {
                                      $(this).find('Cube').each(function () {
                                          $(this).find('Cube').each(function () {
                                              var ticker = $(this).attr('currency');
                                              var rate = $(this).attr('rate');
      
                                              pairs.push({ ticker: ticker, rate: rate });
                                          });
                                      });
                                  });
      
                                  var EURUSD = pairs.filter(function (p) { return p.ticker == "USD"; });
      
                                  if (EURUSD.length == 1) {
                                      EURUSD = EURUSD[0];
      
                                      var XBTEUR = XBTUSD / EURUSD;
      
                                      pairs = pairs.filter(function (p) { return p.ticker != "USD"; })
                                                   .map(function (p) {
                                                       return new Verso.Currency(p.ticker, p.rate * XBTEUR);
                                                   });
                                      pairs.unshift(new Verso.Currency("USD", XBTUSD));
                                  }
                                  else {
                                      pairs = [new Verso.Currency("USD", XBTUSD)];
                                  }
      
                                  if (onCurrencies)
                                      onCurrencies(pairs);
                              }
                              catch (e) {
                                  if (onError)
                                      onError(new Verso.ConnectionError("Parsing error!"));
                              }
                          },
                          error: function (xhr, opt, err) {
                              if (onError)
                                  onError(new Verso.ConnectionError("Error connecting the server!"));
                          }
                      });
                  }
              },
              error: function (xhr, opt, err) {
                  if (onError)
                      onError(new Verso.ConnectionError("Error connecting the server!"));
              }
          });
      };
      
      // http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml
      
      // Add entropy from server dev/urandom if available
      if (Verso.Settings.entropy !== undefined)
          Verso.Cryptography.addPureEntropy(Verso.Settings.entropy);
      
      /**
       * Orders used on the website
       * 
       * @param {Integer} version    Card version (e.g., 0 for silver, 1 for gold)
       * @param {String}  password   Password
       * @param {Array}   [orderKey] Key used to encrypt order data
       */
      Verso.Order = function (version, password, name, orderKeyObject) {
      
          var cryptography = Verso.Cryptography,
              encoding = Verso.Encoding,
              bitcoin = Verso.Bitcoin,
              toBase16 = Verso.Encoding.bytesToBase16,
              toBase94 = Verso.Encoding.bytesToBase94;
      
          if (orderKeyObject === undefined)
              orderKeyObject = Verso.Order.newKey();
      
          var coldOrderKey = orderKeyObject.coldOrderKey;
          var orderKey = orderKeyObject.orderKey;
          
          var data = {};
          var card = new Verso.Card();
      
          var cardKey = card.getCardKey();
          var salt = card.getSalt();
          var iv = card.getIV();
          var userKey = card.getUserKey(password);
          var authID = card.getAuthID();
          var authKey = card.getAuthKey(userKey);
      
          var master = new Verso.Bitcoin.MasterEndpoint();
      
          var ep = card.deriveWallet(master).getEndpoint();
          var address = encoding.base58ToBytes(ep.getAddress());
          var encSeed = card.encryptSeed(master.getSeed(), userKey);
      
          var coldAddress = cryptography.aesEncrypt(address, orderKey);
          var coldCardKey = cryptography.aesEncrypt(cardKey, orderKey);
      
          if (version === 0) {
              var coldEncSeed = cryptography.aesEncrypt(encSeed, orderKey);
      
              data.version = 0;
              data.accountName = name;
              data.authID = toBase16(authID);
              data.authKey = toBase16(authKey);
              data.coldCardKey = toBase16(coldCardKey);
              data.coldAddress = toBase16(coldAddress);
              data.coldEncSeed = toBase16(coldEncSeed);
      
          } else if (version === 1) {
              var i;
              var shares = cryptography.secretShare(encSeed, 4, 2);
              var coldEncSeedShares = [];
              for (i = 0; i <= 2; i++) {
                  coldEncSeedShares[i] = cryptography.aesEncrypt(shares[i], orderKey);
              }
              var encEncSeed4 = cryptography.aesEncrypt(shares[3], cardKey);
      
              shares = cryptography.secretShare(cardKey, 3, 2);
              var coldCardKeyShares = [];
              for (i = 0; i <= 2; i++) {
                  coldCardKeyShares[i] = cryptography.aesEncrypt(shares[i], orderKey);
              }
      
              var recoverySalt = cryptography.randomBytes(32);
              var recoveryKey = cryptography.PBKDF2(password, recoverySalt, 1000);
      
              shares = cryptography.secretShare(recoveryKey, 3, 2);
              var coldRecoveryKeyShares = [];
              for (i = 0; i <= 2; i++) {
                  coldRecoveryKeyShares[i] = cryptography.aesEncrypt(shares[i], orderKey);
              }
      
              data.version = 1;
              data.accountName = name;
              data.authID = toBase16(authID);
              data.authKey = toBase16(authKey);
              data.coldCardKey = toBase16(coldCardKey);
              data.coldAddress = toBase16(coldAddress);
              data.coldEncSeed1 = toBase16(coldEncSeedShares[0]);
              data.coldEncSeed2 = toBase16(coldEncSeedShares[1]);
              data.coldEncSeed3 = toBase16(coldEncSeedShares[2]);
              data.encEncSeed4 = toBase16(encEncSeed4);
              data.coldCardKey1 = toBase16(coldCardKeyShares[0]);
              data.coldCardKey2 = toBase16(coldCardKeyShares[1]);
              data.coldCardKey3 = toBase16(coldCardKeyShares[2]);
              data.recoverySalt = toBase16(recoverySalt);
              data.coldRecoveryKey1 = toBase16(coldRecoveryKeyShares[0]);
              data.coldRecoveryKey2 = toBase16(coldRecoveryKeyShares[1]);
              data.coldRecoveryKey3 = toBase16(coldRecoveryKeyShares[2]);
          } else throw new Verso.Error("Invalid card version!");
      
          return data;
      };
      
      Verso.Order.newKey = function () {
          var orderKey = Verso.Cryptography.randomBytes(32, 6);
          var coldOrderKey = Verso.Cryptography.rsaEncrypt(orderKey, Verso.Settings.rsaKey.modulus, Verso.Settings.rsaKey.exponent);
      
          return {
              orderKey: orderKey,
              coldOrderKey: Verso.Encoding.bytesToBase16(coldOrderKey)
          };
      };
      Verso.Offline = {
          version: '0.1.1',
          cards: []
      };
      
      var validateCardData = function () {
          var password = $('#password').val(),
              passwordConfirm = $('#passwordConfirm').val(),
              accountName = $('#accountName').val(),
              messages = [];
      
          if (password !== passwordConfirm) {
              messages.push("Passwords don't match");
          }
          if (password.length < 6 || password.length > 100) {
              messages.push("Password must be between 6 and 100 characters long");
          }
          if (accountName.length > 20) {
              messages.push("Account name cannot be longer than 20 characters");
          }
      
          if (messages.length === 0) {
              $('#cardData .error').hide();
              $('#errorMessages').html('');
              return true;
          } else {
              $('#errorMessages').html(messages.reduce(function (prev, curr) {
                  return prev + '<li>' + curr + '</li>';
              }, ''));
              $('#cardData .error').show();
              return false;
          }
      };
      
      var clearCardData = function () {
          $('#accountName').val('');
          $('#password').val('');
          $('#passwordConfirm').val('');
          $('#cardData .error').hide();
          $('#errorMessages').html('');
      };
      
      var updateOrder = function () {
          var cards = Verso.Offline.cards;
          if (cards.length === 0) {
              // Add "no cards" row
              $('#cards tbody').html('<tr class="none"><td colspan="3">No cards yet.</td></tr>');
      
              // Empty serialized order
              $('#orderData').val('');
          } else {
              // Add cards to the table
              $('#cards tbody').html('');
              for (var i = 0; i < cards.length; i++) {
                  $('#cards tbody').append('<tr><td>Silver</td><td>' + cards[i].accountName + '</td><td><button class="remove" data-id="' + i +'">Remove</button></td></tr>');
              }
              $('.remove').on('click', function () {
                  $(this).prop("disabled", true);
                  cards.splice($(this).data('id'), 1);
                  updateOrder();
              });
      
              // Update serialized order
              var order = {
                  version: Verso.Offline.version,
                  cards: cards,
                  coldOrderKey: Verso.Offline.orderKey.coldOrderKey
              };
              $('#orderData').val(JSON.stringify(order));
          }
      
      };
      
      $(document).ready(function () {
          updateOrder();
      
          $('#cancelCard').on('click', function (e) {
              e.preventDefault();
              clearCardData();
          });
      
          $('#saveCard').on('click', function (e) {
              e.preventDefault();
              $('#cardData').trigger('submit');
          });
      
          $('#cardData').on('submit', function (e) {
              e.preventDefault();
      
              if (!validateCardData()) {
                  return false;
              }
      
              $(this).prop("disabled", true);
      
              if (Verso.Offline.orderKey === undefined) {
                  Verso.Offline.orderKey = Verso.Order.newKey();
              }
      
              var version = 0;
              var password = $('#password').val();
              var accountName = $('#accountName').val();
              var card = Verso.Order(version, password, accountName, Verso.Offline.orderKey);
              Verso.Offline.cards.push(card);
      
              updateOrder();
              clearCardData();
              $(this).prop("disabled", false);
          });
      
      
      });
      
    </script>

    <h1>Verso Cards - Offline Generator</h1>

    <h2>1. Choose your cards</h2>

    <p>Add all the cards you wish to order.</p>

    <form id="cardData">
      <div>
        <label for="version">Card Type</label>
        <select id="version">
          <option value="0" selected>Verso Silver</option>
        </select>
      </div>

      <div>
        <label for="accountName">Account Name</label>
        <input type="text" id="accountName" />
      </div>

      <div>
        <label for="password">Password</label>
        <input type="password" id="password" />
      </div>

      <div>
        <label for="passwordConfirm">Confirm Password</label>
        <input type="password" id="passwordConfirm" />
      </div>

      <div class="buttons">
        <button id="saveCard">Save</button>
        <button id="cancelCard">Cancel</button>
      </div>

      <div class="error">
        <p>There was a problem with the data you entered:</p>
        <ul id="errorMessages"></ul>
      </div>
    </form>

    <p>Here are the cards that you have ordered so far:</p>

    <table id="cards">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Options</th>
      </tr>
    </thead>
    <tbody>
    </tbody>
    </table>

    <h2>2. Export your order</h2>

    <p>Copy the content of the text field below and import it on the order page of our website.</p>

    <textarea id="orderData"></textarea>

  </body>
</html>