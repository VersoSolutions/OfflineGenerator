/*
VersoLib-JS v0.9.2
http://github.com/VersoSolutions/VersoLib-JS
Copyright (c) 2013 Verso Solutions LLC
http://github.com/VersoSolutions/VersoLib-JS/blob/master/LICENSE
*/

/**
 * Wrapper for services of versocards.com
 */
Verso.Services = (function () {
    var encoding = Verso.Encoding;

    /**
     * Get card information associated to an authID
     *
     * @param  {ByteArray}  authID   The card authID
     * @param  {Function}   onInfos  Function called when the card name is received
     * @param  {Function}   onError  Function called in case of error
     */
    var cardDetails = function (authID, onInfos, onError) {
        $.ajax({
            type: "POST",
            url: "https://versocards.com/api/cardDetails/",
            data: {
                "authID": encoding.bytesToBase16(authID)
            },
            success: function (res) {
                res = JSON.parse(res);

                if (!res.error) {
                    onInfos({ name: res.name });
                }
                else if (onError) {
                    onError(new Verso.CredentialsError("Invalid credentials!"));
                }
            },
            error: function (xhr, opt, err) {
                if (onError)
                    onError(new Verso.ConnectionError("Connection problem!"));
            }
        });
    };

    /**
     * Get the indices of the deterministic addresses associated to an authID (e.g. k for m/k such as in BIP0032)
     *
     * @param  {ByteArray}  authID   The card authID
     * @param  {Function}   onInfos  Function called when the card name is received
     * @param  {Function}   onError  Function called in case of error
     */
    var indices = function (authID, onIndices, onError) {
        // TODO: Finish this.
        onIndices([]);
        return;

        // jQuery.ajax({
        //     type: "POST",
        //     url: "https://versocards.com/api/indices/",
        //     data: {
        //         "authID": encoding.bytesToBase16(authID)
        //     },
        //     success: function (res) {
        //         res = JSON.parse(res);

        //         if (!res.error) {
        //             var indices = [];

        //             for (var i = 0; i < res.indices; i++) {
        //                 indices.push(parseInt(res.onIndices[i]));
        //             }
        //             onIndices({ name: res.name });
        //         }
        //         else if (onError) {
        //             onError(new Verso.CredentialsError("Invalid credentials!"));
        //         }
        //     },
        //     error: function (xhr, opt, err) {
        //         if (onError)
        //             onError(new Verso.ConnectionError("Connection problem!"));
        //     }
        // });
    };

    /**
     * Get the encrypted seed share associated to a Gold Card
     *
     * @param  {ByteArray}  authID   The card authID
     * @param  {ByteArray}  authKey  The user authKey
     * @param  {Function}   onShare  Function called when the share is received
     * @param  {Function}   onError  Function called in case of error
     */
    var seedShare = function (authID, authKey, onShare, onError) {
        $.ajax({
            type: "POST",
            url: "https://versocards.com/api/seedShare/",
            data: {
                "authID": encoding.bytesToBase16(authID),
                "authKey": encoding.bytesToBase16(authKey)
            },
            success: function (res) {
                res = JSON.parse(res);

                if (res.seed !== undefined && res.seed != "false") {
                    onShare(encoding.base16ToBytes(res.seed));
                }
                else if (onError) {
                    onError(new Verso.CredentialsError("Invalid credentials!"));
                }
            },
            error: function (xhr, opt, err) {
                if (onError)
                    onError(new Verso.ConnectionError("Connection problem!"));
            }
        });
    };

    /**
     * Get some entropy from server /dev/urandom
     *
     * @param  {ByteArray}  authID     The card authID
     * @param  {Integer}    n          The number of desired bytes
     * @param  {Function}   onEntropy  Function called when the entropy is received
     * @param  {Function}   [onError]  Function called in case of error
     */
    var entropy = function (authID, n, onEntropy, onError) {
        $.ajax({
            type: "POST",
            url: "https://versocards.com/api/entropy/",
            data: {
                "authID": encoding.bytesToBase16(authID),
                "nBytes": n
            },
            success: function (res) {
                res = JSON.parse(res);

                if (res.entropy !== undefined && res.seed != "false") {
                    onEntropy(encoding.base16ToBytes(res.entropy));
                }
                else if (onError) {
                    onError(new Verso.CredentialsError("Invalid credentials!"));
                }
            },
            error: function (xhr, opt, err) {
                if (onError)
                    onError(new Verso.ConnectionError("Connection problem!"));
            }
        });
    };

    return {
        cardDetails: cardDetails,
        seedShare: seedShare,
        entropy: entropy
    };
})();

Verso.Settings.rsaKey = {
    modulus: "ad8d4433ba0b7401b6be9876e85ff28d6f9a36f580833188715c05b87ca9a045871433fa31aa0290a04982553afb4741fb5956e8743f16b75b36eb31276eebd1f00d2731bdce73fcf2d09a879a1b3343d889d1b6a5ed45caccadf0d4d44eed6c6da4f4cbbfe7f67dbf97950fcc4ec9a36dcd45bdb13803b3f6dd86021e73610f11d5ff95901070cccc7dc586269687724aee2cfe37bbf169a1c1c005ad51d996f29f93ad9535fb65c5c625cad415f52fb481006c517e6c978a2d2792c7fb98e84d843c13363575e0fabbf4a0a80c5df2d9df67f00219f22446272bafe2fd7b5780f7d82058001ef746fb63e1c54aa3960d3612affe40aeb9b8b9668798c65219",
    exponent: "010001"
};

/**
 * The generic Verso Card providing basic properties unrelated to the wallet
 *
 * @constructor
 * @param {Array}  [cardKey] Key of the card, randomly generated if undefined
 */
Verso.Card = function (cardKey) {
    var encoding = Verso.Encoding,
        cryptography = Verso.Cryptography,
        bitcoin = Verso.Bitcoin;

    if (cardKey === undefined)
        cardKey = cryptography.randomBytes(16); // Create new card

    var authID = cryptography.SHASHASHA256(cardKey).slice(0, 16);

    /** Returns the card's cardKey */
    this.getCardKey = function () { return cardKey; };
    /** Returns the card's authID */
    this.getAuthID = function () { return authID; }; // AuthID is used to authentify the card on the Verso server
    /** Returns the salt used in PBKDF2 */
    this.getSalt = function () { return cryptography.SHA256(cardKey); }; // Salt is used as an input of the key derivation function
    /** Returns the IV used in AES */
    this.getIV = function () { return cryptography.SHASHA256(cardKey).slice(0, 16); }; // IV is used as an input of the AES encryptor
    /** Returns the user key used to decrypt encSeed */
    this.getUserKey = function (password) { return cryptography.PBKDF2(password, this.getSalt(), 500); }; // UserKey is used to encrypt/decrypt the bitcoin private key
    /** Returns the auth key used to authentify the card on the web server, where data is either the password or the userKey */
    this.getAuthKey = function (data) { // AuthKey is used to authentify the user on the Verso Server
        if (!Array.isArray(data))
            data = this.getUserKey(data);

        return cryptography.SHA256(data).slice(0, 16);
    };
};

/** Returns the encrypted seed, where key is either the password or the userKey
 *
 * @param {Array}  seed   Seed to be encrypted
 * @param {Array}  [key]  Key or password used to encrypt the seed
 * @return Encrypted seed
 */
Verso.Card.prototype.encryptSeed = function (seed, key) {
    var cryptography = Verso.Cryptography;

    if (!Array.isArray(key))
        key = this.getUserKey(key);

    return cryptography.aesEncrypt(seed, key, this.getIV());
};

/** Returns the wallet derived from a seed or a master endpoint
 *
 * @param {Array|MasterEndpoint}  data   Seed or MasterEndpoint from which wallet is derived
 * @return Wallet associated to the card
*/
Verso.Card.prototype.deriveWallet = function (data) {
    var bitcoin = Verso.Bitcoin;

    if (Array.isArray(data))
        return new bitcoin.Wallet(new bitcoin.MasterEndpoint(data).getChild());
    else if (data instanceof bitcoin.ExtendedEndpoint && data.isMaster())
        return new bitcoin.Wallet(data.getChild());

    throw new Verso.Error("Invalid argument!");
};

/**
 * The Verso Silver corresponding to the data in a private QR code.
 *
 * @constructor
 * @param {Array}  cardKey   Key of the card
 * @param {Array}  encSeed   Encrypted seed of the card
 * @param {Array}  pubHash   Public key has of the card
 */
Verso.SilverCard = function (cardKey, encSeed, pubHash) {
    Verso.Card.call(this, cardKey);

    var endpoint = new Verso.Bitcoin.Endpoint(pubHash);

    /** Returns the card's version */
    this.getVersion = function () { return 0; };
    /** Returns the encrypted seed of the card */
    this.getEncSeed = function () { return encSeed; };
    /** Returns the public hash of the card */
    this.getPublicHash = function() { return pubHash; };
    /** Returns the endpoints of the card */
    this.getEndpoints = function (password, all, onResult, onError) { // TODO: implement "all" with determinism
        var cryptography = Verso.Cryptography;

        if(password) {
            var seed = cryptography.aesDecrypt(this.getEncSeed(), this.getUserKey(password), this.getIV());

            try {
                var ep = new Verso.Bitcoin.MasterEndpoint(seed).getChild();

                if (ep.sameAs(this.getPublicHash())) {
                    onResult([ep]);
                }
                else {
                    onError(new Verso.CredentialsError("Invalid password!"));
                }
            } catch (e) {
                onError(new Verso.Error(e.toString()));
            }
        }
        else {
            onResult([endpoint]);
        }
    };
};

Verso.SilverCard.prototype = Verso.Class.inherit(Verso.Card.prototype);

/**
 * Serialize card
 *
 * @return Serialized card with private side format
 */
Verso.SilverCard.prototype.serialize = function () {
    var encoding = Verso.Encoding;

    return encoding.bytesToBase94(this.getVersion()) + " " + encoding.bytesToBase94(this.getCardKey()) + " " + encoding.bytesToBase94(this.getEncSeed()) + " " + encoding.bytesToBase94(this.getPublicHash());
};

/**
 * The Verso Gold corresponding to the data in a private QR code.
 *
 * @constructor
 * @param {Array}  cardKey   Key of the card
 * @param {Array}  encSeed1  Encrypted seed share of the card
 * @param {Array}  pubHash   Public key hash of the card
 */
Verso.GoldCard = function (cardKey, encSeed1, pubHash) {
    Verso.Card.call(this, cardKey);

    var cryphography = Verso.Cryptography,
        bitcoin = Verso.Bitcoin;

    var endpoint = new bitcoin.Endpoint(pubHash);

    /** Returns the card's version */
    this.getVersion = function () { return 1; };
    /** Returns the encrypted seed share of the card */
    this.getEncSeed1 = function () { return encSeed1; };
    /** Returns the public hash of the card */
    this.getPublicHash = function () { return pubHash; };
    /** Returns the endpoints of the card */
    this.getEndpoints = function (password, all, onResult, onError, encEncSeedShare) { // TODO: implement "all" with determinism
        var cryptography = Verso.Cryptography,
            encoding = Verso.Encoding;
        var that = this;

        if (password) {
            var userKey = that.getUserKey(password);

            var onSeedShare = function (encEncSeedShare) {
                var encSeedShare = cryptography.aesDecrypt(encEncSeedShare, that.getCardKey());
                var encSeed = cryptography.secretCombine([that.getEncSeed1(), encSeedShare]);
                var seed = cryptography.aesDecrypt(encSeed, userKey, that.getIV());

                try {
                    var ep = new Verso.Bitcoin.MasterEndpoint(seed).getChild();

                    if (ep.sameAs(that.getPublicHash())) {
                        onResult([ep]);
                    }
                    else {
                        onError(new Verso.CredentialsError("Invalid password!"));
                    }
                } catch (e) {
                    onError(new Verso.Error(e.toString()));
                }
            };

            if (encEncSeedShare) {
                onSeedShare(encEncSeedShare);
            } else {
                Verso.Services.seedShare(that.getAuthID(), that.getAuthKey(userKey), onSeedShare, onError);
            }
        } else {
            onResult([endpoint]);
        }
    };
};

Verso.GoldCard.prototype = Verso.Class.inherit(Verso.Card.prototype);

/**
 * Serialize card
 *
 * @return Serialized card with private side format
 */
Verso.GoldCard.prototype.serialize = function () {
    var encoding = Verso.Encoding;

    return encoding.bytesToBase94(this.getVersion()) + " " + encoding.bytesToBase94(this.getCardKey()) + " " + encoding.bytesToBase94(this.getEncSeed1()) + " " + encoding.bytesToBase94(this.getPublicHash());
};

/** Returns the watch-only endpoint corresponding to the card public or private side data */
Verso.Card.parsePublic = function (data) {
    var encoding = Verso.Encoding;

    if (!data) return false;

    var pub = new RegExp("^(?:bitcoin:)?(1[a-zA-Z0-9]+)(?:\\?[a-zA-Z]+=[^&=]+(&[a-zA-Z]+=[^&=]+)*)?$");

    if (pub.test(data)) {
        try {
            return new Verso.Bitcoin.Endpoint(pub.exec(data)[1]);
        } catch (e) {
            return false;
        }
    }

    try {
        var items = data.split(" ").map(function (item) { return encoding.base94ToBytes(item); });

        var version = items[0][0];

        if (version === 0 || version === 1)
            return new Verso.Bitcoin.Endpoint(items[3]);
    }
    catch (e) {}

    return false;
};

/** Returns the Card corresponding to the card private side data
 *
 * @param {String}  data   Content of the QR code
 * @return Card corresponding to the private QR code
*/
Verso.Card.parsePrivate = function (data) {
    var encoding = Verso.Encoding;

    if (!data)
        return false;

    try {
        var items = data.split(" ").map(function (item) { return encoding.base94ToBytes(item); });

        var version = items[0][0];
        var cardKey = items[1];
        var tmp = items.slice(2);

        if (version === 0)
            return new Verso.SilverCard(cardKey, tmp[0], tmp[1]);
        else if (version === 1)
            return new Verso.GoldCard(cardKey, tmp[0], tmp[1]);
    }
    catch (e) { }

    return false;
};

/**
 * Currency and exchange rate
 *
 * @constructor
 * @param {String}  Ticker The ticker of the currency
 * @param {Number}  The exchange rate with respect to bitcoin
 */
Verso.Currency = function (ticker, rate) {
    this.getTicker = function () {
        return ticker;
    };

    this.getRate = function () {
        return rate;
    };
};

/** Fetches the exchange rates
 * 
 * @param {Function}  onCurrencies Function called with the list of currencies in case of success
 * @param {Function}  onError      Function called in case of error
 */
Verso.Currency.fetch = function (onCurrencies, onError) {
    $.ajax({
        type: "GET",
        url: "https://blockchain.info/ticker",
        data: { cors: true },
        success: function (data) {

            if (data.USD) {
                var XBTUSD = parseFloat(data.USD.last);

                jQuery.ajax({
                    type: "GET",
                    url: "http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml",
                    data: { cors: true },
                    cache: false,
                    dataType: "xml",
                    success: function (xml) {

                        try {
                            var pairs = [];
                            $(xml).find('Cube').each(function () {
                                $(this).find('Cube').each(function () {
                                    $(this).find('Cube').each(function () {
                                        var ticker = $(this).attr('currency');
                                        var rate = $(this).attr('rate');

                                        pairs.push({ ticker: ticker, rate: rate });
                                    });
                                });
                            });

                            var EURUSD = pairs.filter(function (p) { return p.ticker == "USD"; });

                            if (EURUSD.length == 1) {
                                EURUSD = EURUSD[0];

                                var XBTEUR = XBTUSD / EURUSD;

                                pairs = pairs.filter(function (p) { return p.ticker != "USD"; })
                                             .map(function (p) {
                                                 return new Verso.Currency(p.ticker, p.rate * XBTEUR);
                                             });
                                pairs.unshift(new Verso.Currency("USD", XBTUSD));
                            }
                            else {
                                pairs = [new Verso.Currency("USD", XBTUSD)];
                            }

                            if (onCurrencies)
                                onCurrencies(pairs);
                        }
                        catch (e) {
                            if (onError)
                                onError(new Verso.ConnectionError("Parsing error!"));
                        }
                    },
                    error: function (xhr, opt, err) {
                        if (onError)
                            onError(new Verso.ConnectionError("Error connecting the server!"));
                    }
                });
            }
        },
        error: function (xhr, opt, err) {
            if (onError)
                onError(new Verso.ConnectionError("Error connecting the server!"));
        }
    });
};

// http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml

// Add entropy from server dev/urandom if available
if (Verso.Settings.entropy !== undefined)
    Verso.Cryptography.addPureEntropy(Verso.Settings.entropy);

/**
 * Orders used on the website
 * 
 * @param {Integer} version    Card version (e.g., 0 for silver, 1 for gold)
 * @param {String}  password   Password
 * @param {Array}   [orderKey] Key used to encrypt order data
 */
Verso.Order = function (version, password, name, orderKeyObject) {

    var cryptography = Verso.Cryptography,
        encoding = Verso.Encoding,
        bitcoin = Verso.Bitcoin,
        toBase16 = Verso.Encoding.bytesToBase16,
        toBase94 = Verso.Encoding.bytesToBase94;

    if (orderKeyObject === undefined)
        orderKeyObject = Verso.Order.newKey();

    var coldOrderKey = orderKeyObject.coldOrderKey;
    var orderKey = orderKeyObject.orderKey;
    
    var data = {};
    var card = new Verso.Card();

    var cardKey = card.getCardKey();
    var salt = card.getSalt();
    var iv = card.getIV();
    var userKey = card.getUserKey(password);
    var authID = card.getAuthID();
    var authKey = card.getAuthKey(userKey);

    var master = new Verso.Bitcoin.MasterEndpoint();

    var ep = card.deriveWallet(master).getEndpoint();
    var address = encoding.base58ToBytes(ep.getAddress());
    var encSeed = card.encryptSeed(master.getSeed(), userKey);

    var coldAddress = cryptography.aesEncrypt(address, orderKey);
    var coldCardKey = cryptography.aesEncrypt(cardKey, orderKey);

    if (version === 0) {
        var coldEncSeed = cryptography.aesEncrypt(encSeed, orderKey);

        data.version = 0;
        data.accountName = name;
        data.authID = toBase16(authID);
        data.authKey = toBase16(authKey);
        data.coldCardKey = toBase16(coldCardKey);
        data.coldAddress = toBase16(coldAddress);
        data.coldEncSeed = toBase16(coldEncSeed);

    } else if (version === 1) {
        var i;
        var shares = cryptography.secretShare(encSeed, 4, 2);
        var coldEncSeedShares = [];
        for (i = 0; i <= 2; i++) {
            coldEncSeedShares[i] = cryptography.aesEncrypt(shares[i], orderKey);
        }
        var encEncSeed4 = cryptography.aesEncrypt(shares[3], cardKey);

        shares = cryptography.secretShare(cardKey, 3, 2);
        var coldCardKeyShares = [];
        for (i = 0; i <= 2; i++) {
            coldCardKeyShares[i] = cryptography.aesEncrypt(shares[i], orderKey);
        }

        var recoverySalt = cryptography.randomBytes(32);
        var recoveryKey = cryptography.PBKDF2(password, recoverySalt, 1000);

        shares = cryptography.secretShare(recoveryKey, 3, 2);
        var coldRecoveryKeyShares = [];
        for (i = 0; i <= 2; i++) {
            coldRecoveryKeyShares[i] = cryptography.aesEncrypt(shares[i], orderKey);
        }

        data.version = 1;
        data.accountName = name;
        data.authID = toBase16(authID);
        data.authKey = toBase16(authKey);
        data.coldCardKey = toBase16(coldCardKey);
        data.coldAddress = toBase16(coldAddress);
        data.coldEncSeed1 = toBase16(coldEncSeedShares[0]);
        data.coldEncSeed2 = toBase16(coldEncSeedShares[1]);
        data.coldEncSeed3 = toBase16(coldEncSeedShares[2]);
        data.encEncSeed4 = toBase16(encEncSeed4);
        data.coldCardKey1 = toBase16(coldCardKeyShares[0]);
        data.coldCardKey2 = toBase16(coldCardKeyShares[1]);
        data.coldCardKey3 = toBase16(coldCardKeyShares[2]);
        data.recoverySalt = toBase16(recoverySalt);
        data.coldRecoveryKey1 = toBase16(coldRecoveryKeyShares[0]);
        data.coldRecoveryKey2 = toBase16(coldRecoveryKeyShares[1]);
        data.coldRecoveryKey3 = toBase16(coldRecoveryKeyShares[2]);
    } else throw new Verso.Error("Invalid card version!");

    return data;
};

Verso.Order.newKey = function () {
    var orderKey = Verso.Cryptography.randomBytes(32, 6);
    var coldOrderKey = Verso.Cryptography.rsaEncrypt(orderKey, Verso.Settings.rsaKey.modulus, Verso.Settings.rsaKey.exponent);

    return {
        orderKey: orderKey,
        coldOrderKey: Verso.Encoding.bytesToBase16(coldOrderKey)
    };
};