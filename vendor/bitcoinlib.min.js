/*
BitcoinLib-JS v0.9.3
http://github.com/VersoSolutions/BitcoinLib-JS
Copyright (c) 2013 Verso Solutions LLC
http://github.com/VersoSolutions/BitcoinLib-JS/blob/master/LICENSE
*/

/*

BitcoinLib-JS
github.com/VersoSolutions/BitcoinLib-JS

Copyright (c) 2013 Verso Solutions LLC

This file is part of BitcoinLib.

BitcoinLib is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

BitcoinLib is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with BitcoinLib.  If not, see <http://www.gnu.org/licenses/>.

*/

/**
 * Verso library top-level namespace
 * @namespace
 */
var Verso = Verso || {
    /**
     * Bitcoin-related functions
     * @namespace
     * @memberOf Verso
    */
    Bitcoin: {
        /**
         * Bitcoin data providers
         * @namespace
         * @memberOf Verso.Bitcoin
         */
        Providers: {}
    },
    Class: {
        inherit: function (o) {
            function F() {}
            F.prototype = o;
            return new F();
        }
    },
    /**
    * Cryptography-related functions
    * @namespace
    * @memberOf Verso.Helpers
    */
    Cryptography: {},
    /**
    * Encoding-related functions
    * @namespace
    * @memberOf Verso.Helpers
    */
    Encoding: {},
    /**
     * General settings
     * @namespace
     * @memberOf Verso
     */
    Settings: {}
};

/**
 * Generic error
 *
 * @constructor
 * @param {string}  [msg] Error description
 */
Verso.Error = function (msg) {
    this.getMessage = function () { return msg; };
};
Verso.Error.prototype.toString = function () { return this.getMessage(); };

/**
 * Balance related error (e.g., insufficient funds)
 *
 * @constructor
 * @param {string}  [msg] Error description
 */
Verso.BalanceError = function (msg) {
    Verso.Error.call(this, msg);
};
Verso.BalanceError.prototype = Verso.Class.inherit(Verso.Error.prototype);

/**
 * Connection error
 *
 * @constructor
 * @param {string}  [msg] Error description
 */
Verso.ConnectionError = function (msg, xhr) {
    Verso.Error.call(this, msg);
    this.xhr = xhr;
};
Verso.ConnectionError.prototype = Verso.Class.inherit(Verso.Error.prototype);

/**
 * Authentication error
 *
 * @constructor
 * @param {string}  [msg] Error description
 */
Verso.CredentialsError = function (msg) {
    Verso.Error.call(this, msg);
};
Verso.CredentialsError.prototype = Verso.Class.inherit(Verso.Error.prototype);

/**
 * Main cryptography features
 */
Verso.Cryptography = (function () {

    sjcl.random.setDefaultParanoia(6); // 256 bits of entropy

    // Collect additional entropy from sources of noise
    if (sjcl.random.isReady() === 0) {
        sjcl.random.startCollectors();
        sjcl.random.addEventListener("seeded", function() {
            sjcl.random.stopCollectors();
        });
    }

    var entropy = [];
    /**
     * Add entropy to the RNG (without stopping entropy collection)
     *
     * @memberOf Verso.Cryptography
     * @param  {Array}   ba Entropic byte array
     */
    var addPureEntropy = function (ba) {
        entropy = entropy.concat(ba);
    };

    /**
     * Returns true if the RNG has enough entropy
     *
     * @memberOf Verso.Cryptography
     * @return {ByteArray}            Returns true if the RNG has enough entropy
     */
    var isRngReady = function (paranoia) {
        return sjcl.random.isReady(paranoia);
    };

    /**
     * Random bytes generator
     *
     * @memberOf Verso.Cryptography
     * @param  {Integer}   length     The desired length
     * @param  {Integer}   [paranoia] The desired level of paranoia
     * @return {ByteArray}            The generated random byte array
     */
    var randomBytes = function (length, paranoia) {
        if (paranoia === undefined)
            paranoia = 0;

        var words;

        try {
            if (!sjcl.random.isReady(paranoia) && entropy.length > 0) {
                sjcl.random.addEntropy(Verso.Encoding.bytesToWords(entropy), 8 * entropy.length);
                entropy = [];
            }

            words = sjcl.random.randomWords(Math.ceil(length/4), paranoia);
        }
        catch (e) {
            throw new Verso.Error("Insufficient entropy!");
        }

        return Verso.Encoding.wordsToBytes(words).slice(0,length);
    };

    /**
     * Password-based key derivation function as defined in PKCS #5. Always returns a 256-bit key.
     *
     * @memberOf Verso.Cryptography
     * @param  {String}    password   The password
     * @param  {ByteArray} salt       The salt
     * @param  {Integer}   iterations The number of iterations
     * @return {ByteArray}            The derived key
     */
    var PBKDF2 = function (password, salt, iterations) {
        var hmacSHA1 = function (key) { // SJCL uses HMAC-SHA256 by default, we use SHA-1 for compatibility reasons
            var hasher = new sjcl.misc.hmac(key, sjcl.hash.sha1);
            this.encrypt = function () { return hasher.encrypt.apply(hasher, arguments); };
        };

        // TEMP: Should convert password from UTF8

        return Verso.Encoding.wordsToBytes(
                 sjcl.misc.pbkdf2( // SJCL implementation of PBKDF2 much more efficient than CryptoJS implementation
                   password,
                   Verso.Encoding.bytesToWords(salt),
                   iterations,
                   256,
                   hmacSHA1));
    };

    /**
     * Hashes the input byte array with SHA256
     *
     * @memberOf Verso.Cryptography
     * @param {ByteArray} ba The data to hash
     */
    var SHA256 = function (ba) {
        return Verso.Encoding.wordArrayToBytes(CryptoJS.SHA256(Verso.Encoding.bytesToWordArray(ba)));
    };

    /**
     * Hashes the input byte array with SHA256 of SHA256
     *
     * @memberOf Verso.Cryptography
     * @param {ByteArray} ba The data to hash
     */
    var SHASHA256 = function (ba) {
        return Verso.Encoding.wordArrayToBytes(CryptoJS.SHA256(CryptoJS.SHA256(Verso.Encoding.bytesToWordArray(ba))));
    };

    /**
     * Hashes the input byte array with SHA256 of SHA256 of SHA256
     *
     * @memberOf Verso.Cryptography
     * @param {ByteArray} ba The data to hash
     */
    var SHASHASHA256 = function (ba) {
        return Verso.Encoding.wordArrayToBytes(CryptoJS.SHA256(CryptoJS.SHA256(CryptoJS.SHA256(Verso.Encoding.bytesToWordArray(ba)))));
    };

    /**
     * Hashes the input byte array with RIPEMD160
     *
     * @memberOf Verso.Cryptography
     * @param {ByteArray} ba The data to hash
     */
    var RIPEMD160 = function (ba) {
        return Verso.Encoding.wordArrayToBytes(CryptoJS.RIPEMD160(Verso.Encoding.bytesToWordArray(ba)));
    };

    /**
     * Hashes the input byte array with RIPEMD160 of SHA256
     *
     * @memberOf Verso.Cryptography
     * @param {ByteArray} ba The data to hash
     */
    var SHA256RIPEMD160 = function (ba) {
        return RIPEMD160(SHA256(ba));
    };

    /**
     * Hashes the input byte array with HMAC-SHA512
     *
     * @memberOf Verso.Cryptography
     * @param {ByteArray} ba  The data to hash
     * @param {ByteArray} key The key
     * @return {ByteArray}    The hash
    */
    var HMACSHA512 = function (ba, key) {
        return Verso.Encoding.wordArrayToBytes(CryptoJS.HmacSHA512(Verso.Encoding.bytesToWordArray(ba), Verso.Encoding.bytesToWordArray(key)));
    };

    /**
     * Encrypts the plaintext with AES-CTR-NoPadding. If the IV is not specified, it is concatenated in front of the resulting ciphertext.
     *
     * @memberOf Verso.Cryptography
     * @param  {ByteArray} plaintext The plaintext
     * @param  {ByteArray} key       The key
     * @param  {ByteArray} [iv]      The IV
     * @return {ByteArray}           The ciphertext
     */
    var aesEncrypt = function (plaintext, key, iv) {
        var ivPredefined = (iv !== undefined);

        if (!ivPredefined) {
            iv = Verso.Cryptography.randomBytes(128/8, 0);
        }

        var cipherParams =
        {
            iv: Verso.Encoding.bytesToWordArray(iv),
            mode: CryptoJS.mode.CTR,
            padding: CryptoJS.pad.NoPadding
        };

        var ciphertext = Verso.Encoding.wordArrayToBytes(CryptoJS.AES.encrypt(Verso.Encoding.bytesToWordArray(plaintext), Verso.Encoding.bytesToWordArray(key), cipherParams).ciphertext);

        if (ivPredefined)
            return ciphertext;
        else
            return iv.concat(ciphertext);
    };

    /**
     * Decrypts the ciphertext with AES-CTR-NoPadding. If the IV is not specified, assumes that it is concatenated in front of the ciphertext.
     *
     * @memberOf Verso.Cryptography
     * @param  {ByteArray} ciphertext The ciphertext
     * @param  {ByteArray} key        The key
     * @param  {ByteArray} [iv]       The IV
     * @return {ByteArray}            The plaintext
     */
    var aesDecrypt = function (ciphertext, key, iv) {
        if (iv === undefined) {
            iv = ciphertext.slice(0, 128 / 8);
            ciphertext = ciphertext.slice(128 / 8);
        }

        var cipherParams =
        {
            iv: Verso.Encoding.bytesToWordArray(iv),
            mode: CryptoJS.mode.CTR,
            padding: CryptoJS.pad.NoPadding
        };

        return Verso.Encoding.wordArrayToBytes(CryptoJS.AES.decrypt({ciphertext: Verso.Encoding.bytesToWordArray(ciphertext)}, Verso.Encoding.bytesToWordArray(key), cipherParams));
    };

    /**
     * Encrypts the plaintext with RSA-2048
     *
     * @memberOf Verso.Cryptography
     * @param  {ByteArray} plaintext The plaintext
     * @param  {Hex}       modulus   The modulus
     * @param  {Hex}       exponent  The public exponent
     * @return {ByteArray}           The ciphertext
     */
    var rsaEncrypt = function (plaintext, modulus, exponent) {
        var rsa = new RSAKey();
        rsa.setPublic(modulus, exponent);

        var res = rsa.encrypt(plaintext);
        if (res)
            return Verso.Encoding.wordArrayToBytes(CryptoJS.enc.Hex.parse(res));
        else
            return null;
    };

    /**
     * Shares the secret based on Shamir's Secret Sharing algorithm
     *
     * @memberOf Verso.Cryptography
     * @param  {ByteArray} secret     The secret to share
     * @param  {Integer}   n          The number of shares to generate
     * @param  {Integer}   k          The minimum number of shares for combination
     * @param  {Integer}   [paranoia] The desired level of paranoia
     * @return {ByteArray}            The secret shares
     */
    var secretShare = function (secret, n, k, paranoia) {
        if (paranoia === undefined)
            paranoia = 6;

        secrets.setRNG(function (bits) {
            var b = randomBytes(bits / 8, paranoia);

            var result = "";
            for (var i = 0; i < b.length; i++) {
                var tmp = b[i].toString(2);
                while (tmp.length < 8) tmp = "0" + tmp;
                result += tmp;
            }

            return result;
        });

        var shares = secrets.share(Verso.Encoding.bytesToBase16(secret), n, k);
        shares = shares.map(function (s) { return Verso.Encoding.base16ToBytes(s.slice(1)); });

        return shares;
    };

    /**
     * Combines the secret shares based on Samir's Secret Sharing algorithm
     *
     * @memberOf Verso.Cryptography
     * @param  {Array.ByteArray} shares The secret shares
     * @return {ByteArray}              The secret
     */
    var secretCombine = function (shares) {
        shares = shares.map(function (s) { return "8".concat(Verso.Encoding.bytesToBase16(s)); });

        return Verso.Encoding.base16ToBytes(secrets.combine(shares));
    };

    return {
        randomBytes: randomBytes,
        addPureEntropy: addPureEntropy,
        isRngReady: isRngReady,
        PBKDF2: PBKDF2,
        SHA256: SHA256,
        SHASHA256: SHASHA256,
        SHASHASHA256: SHASHASHA256,
        RIPEMD160: RIPEMD160,
        SHA256RIPEMD160: SHA256RIPEMD160,
        HMACSHA512: HMACSHA512,
        aesEncrypt: aesEncrypt,
        aesDecrypt: aesDecrypt,
        rsaEncrypt: rsaEncrypt,
        secretShare: secretShare,
        secretCombine: secretCombine
    };
})();

/**
 * Main encoding tools
 */
Verso.Encoding = (function () {
    var Base58Table = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    var Base94Table = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";

    var bigIntegerToBytesUnsigned = function (bi, len) {
        var ba = bi.abs().toByteArray();

        if (ba.length > 1 && ba[0] === 0) {
            ba = ba.slice(1);
        }

        if (ba.length) {
            ba = ba.map(function (v) { return (v < 0) ? v + 256 : v; });
        }
        else {
            ba = [0];
        }

        if (len !== undefined) {
            if (len < ba.length) {
                ba = ba.slice(ba.length - len);
            } else while (len > ba.length) {
                ba.unshift(0);
            }
        }

        return ba;
    };

    var bytesUnsignedToBigInteger = function (ba) {
        if (!ba.length) {
            return new BigInteger(0x00);
        } else if (ba[0] & 0x80) {
            return new BigInteger([0].concat(ba));
        } else {
            return new BigInteger(ba);
        }
    };

    var bigIntegerToBytesSigned = function (bi) {
        var val = bigIntegerToBytesUnsigned(bi.abs());
        var neg = bi.compareTo(BigInteger.ZERO) < 0;

        if (neg) {
            if (val[0] & 0x80) {
                val.unshift(0x80);
            } else {
                val[0] |= 0x80;
            }
        } else {
            if (val[0] & 0x80) {
                val.unshift(0x00);
            }
        }

        return val;
    };

    var bytesSignedToBigInteger = function (ba) {
        if (ba[0] & 0x80) {
            ba[0] &= 0x7f;
            return bytesUnsignedToBigInteger(ba).negate();
        } else {
            return bytesUnsignedToBigInteger(ba);
        }
    };

    var integerToBytesUnsigned = function (i, len) {
        return bigIntegerToBytesUnsigned(new BigInteger('' + i, 10), len); // TODO: implement properly
    };

    var stringToBytes = function (s, table) {
        var bi = BigInteger.ZERO;
        var n = BigInteger.ONE;
        var base = nbv(table.length);
        var zeros = 0;

        for (var i = 0; i < s.length; i++) {
            var c = s[s.length - i - 1];
            var k = nbv(table.indexOf(c));

            bi = bi.add(n.multiply(k));
            n = n.multiply(base);

            if (c == table[0]) zeros++; // count leading zeros
            else zeros = 0;
        }

        var bytes = bigIntegerToBytesUnsigned(bi);

        if (bytes.length > 1 || bytes[0] !== 0)
            while (zeros-- > 0) bytes.unshift(0); // add leading zeros

        return bytes;
    };

    var bytesToString = function (ba, table) {
        if (!ba.length || (ba.length === 1 && ba[0] === 0))
            return table[0];

        var base = nbv(table.length);

        var bi = bytesUnsignedToBigInteger(ba);
        var chars = [];

        while (bi.compareTo(base) >= 0) {
            var mod = bi.mod(base);
            chars.unshift(table[mod.intValue()]);
            bi = bi.subtract(mod).divide(base);
        }
        chars.unshift(table[bi.intValue()]);

        // Convert leading zeros too.
        for (var i = 0; i < ba.length; i++) {
            if (ba[i] === 0x00) {
                chars.unshift(table[0]);
            } else break;
        }

        return chars.join('');
    };

    var bytesToWords = function (ba) {
        for (var words = [], i = 0, b = 0; i < ba.length; i++, b += 8)
            words[b >>> 5] |= ba[i] << (24 - b % 32);
        return words;
    };

    var wordsToBytes = function (wa) {
        for (var bytes = [], b = 0; b < wa.length * 32; b += 8)
            bytes.push((wa[b >>> 5] >>> (24 - b % 32)) & 0xFF);
        return bytes;
    };

    var wordArrayToBytes = function (wa) {
        return wordsToBytes(wa.words).slice(0, wa.sigBytes);
    };

    var bytesToWordArray = function (ba) {
        return CryptoJS.lib.WordArray.create(bytesToWords(ba), ba.length);
    };

    var numToVarInt = function (i) {
        if (i < 0xfd) {
            // unsigned char
            return [i];
        } else if (i <= 1 << 16) {
            // unsigned short (LE)
            return [0xfd, i >>> 8, i & 255];
        } else if (i <= 1 << 32) {
            // unsigned int (LE)
            return [0xfe].concat(wordsToBytes([i]));
        } else {
            // unsigned long long (LE)
            return [0xff].concat(wordsToBytes([i >>> 32, i]));
        }
    };

    var bytesToCheck = function (ba, version) {
        var bytes = ba.slice(0);

        if (version !== undefined)
            bytes.unshift(version);

        var checksum = Verso.Cryptography.SHASHA256(bytes);

        return bytes.concat(checksum.slice(0, 4));
    };

    var checkToBytes = function (ba, version) {
        if (!Array.isArray(version)) { version = [version]; }

        if (version !== undefined && !version.some(function (v) { return ba[0] === v; })) {
            throw new Verso.Error("Version mismatch!");
        }

        var bytes = ba.slice(0, ba.length - 4);
        var checksum = ba.slice(ba.length - 4, ba.length);

        var chk = Verso.Cryptography.SHASHA256(bytes).slice(0, 4);
        for (var i = 0; i < 4; i++) if (chk[i] != checksum[i]) throw new Verso.Error("Checksum mismatch!");

        if (version === undefined)
            return bytes;
        return bytes.slice(1);
    };

    return {
        base16ToBytes: function (s) {
            return wordArrayToBytes(CryptoJS.enc.Hex.parse(s));
        },
        bytesToBase16: function (ba) {
            return CryptoJS.enc.Hex.stringify(bytesToWordArray(ba));
        },
        base58ToBytes: function (s) {
            return stringToBytes(s, Base58Table);
        },
        bytesToBase58: function (ba) {
            return bytesToString(ba, Base58Table);
        },
        base64ToBytes: function (s) {
            return wordArrayToBytes(CryptoJS.enc.Base64.parse(s));
        },
        bytesToBase64: function (ba) {
            return CryptoJS.enc.Base64.stringify(bytesToWordArray(ba));
        },
        bytesToBase64Url: function(ba) {
            return CryptoJS.enc.Base64.stringify(bytesToWordArray(ba)).replace("+", "-").replace("/", "_").replace("=", "");
        },
        base94ToBytes: function (s) {
            return stringToBytes(s, Base94Table);
        },
        bytesToBase94: function (ba) {
            return bytesToString(ba, Base94Table);
        },
        bytesToUtf8: function(ba) {
            return CryptoJS.enc.Utf8.stringify(bytesToWordArray(ba));
        },
        utf8ToBytes: function (s) {
            return wordArrayToBytes(CryptoJS.enc.Utf8.parse(s));
        },
        wordsToBytes: wordsToBytes,
        bytesToWords: bytesToWords,
        wordArrayToBytes: wordArrayToBytes,
        bytesToWordArray: bytesToWordArray,
        bigIntegerToBytesUnsigned: bigIntegerToBytesUnsigned,
        bytesUnsignedToBigInteger: bytesUnsignedToBigInteger,
        bigIntegerToBytesSigned: bigIntegerToBytesSigned,
        bytesSignedToBigInteger: bytesSignedToBigInteger,
        integerToBytesUnsigned: integerToBytesUnsigned,
        numToVarInt: numToVarInt,
        bytesToCheck: bytesToCheck,
        checkToBytes: checkToBytes
    };
})();


/** Bitcoin ECDSA curve */
Verso.Bitcoin.Curve = (function () { return getSECCurveByName("secp256k1"); })();

/**
 * Bitcoin endpoint (key pair)
 *
 * @constructor
 * @param {ByteArray|String} [data] A private key (raw or WIF) or a public key hash (raw or Base58Check)
 */
Verso.Bitcoin.Endpoint = function (data) {
    var encoding = Verso.Encoding,
        curve = Verso.Bitcoin.Curve,
        cryptography = Verso.Cryptography,
        bitcoin = Verso.Bitcoin;

    var that = this;
    var watchOnly;
    var privateKey;
    var privateCheck;
    var pt;
    var pub;
    var pubc;
    var pubHash;
    var address;
    var version;

    var genKey = function (bigint) {
        var key = encoding.bytesUnsignedToBigInteger(cryptography.randomBytes(32, 6))
            .mod(curve.getN().subtract(BigInteger.ONE))
            .add(BigInteger.ONE);

        if (bigint)
            return key;

        return encoding.bigIntegerToBytesUnsigned(key, 32);
    };

    var derivePublic = function () {
        if (watchOnly || (pt !== undefined && pub !== undefined && pubc !== undefined))
            return;

        // Compute public key
        pt = curve.getG().multiply(encoding.bytesUnsignedToBigInteger(privateKey));
        pt = {
            x: pt.getX().toBigInteger(),
            y: pt.getY().toBigInteger()
        };

        // Convert to DER format
        pub = encoding.bigIntegerToBytesUnsigned(pt.x, 32);
        pub.unshift(0x04);
        pub = pub.concat(encoding.bigIntegerToBytesUnsigned(pt.y, 32));

        // Compressed form
        pubc = encoding.bigIntegerToBytesUnsigned(pt.x, 32);
        if (pt.y.isEven())
            pubc.unshift(0x02);
        else
            pubc.unshift(0x03);

        // Compute address hash and string address
        pubHash = cryptography.SHA256RIPEMD160(pub);
        address = encoding.bytesToBase58(encoding.bytesToCheck(pubHash, 0x00));
    };

    if (data === undefined) {
        data = genKey();
    }
    else if (typeof data == "string") {
        data = encoding.base58ToBytes(data);
    }
    else if (data instanceof Verso.Bitcoin.Endpoint) {
        if (data.isWatchOnly())
            data = data.getPublicHash();
        else
            data = data.getPrivate();
    }

    if (Array.isArray(data) && data.length == 20) { // pubHash
        pubHash = data;
        version = 0x00;
        address = encoding.bytesToBase58(encoding.bytesToCheck(data, 0x00));
        watchOnly = true;
    }
    else if (Array.isArray(data) && data.length == 25) { // address
        pubHash = encoding.checkToBytes(data, [0x00,0x05]);
        version = data[0];
        address = encoding.bytesToBase58(data);
        watchOnly = true;
    }
    else {
        if (Array.isArray(data) && data.length == 32) { // private exponent
            privateKey = data;
            privateCheck = encoding.bytesToBase58(encoding.bytesToCheck(privateKey, 0x80));
        }
        else if (Array.isArray(data) && data.length == 37) { // wif
            privateKey = encoding.checkToBytes(data, 0x80);
            privateCheck = encoding.bytesToBase58(data);
        }
        else throw new Verso.Error("Invalid argument");

        version = 0x00;
        watchOnly = false;

        /** Returns the private key */
        this.getPrivate = function () { return privateKey; };
        /** Returns the WIF private key */
        this.getPrivateCheck = function () { return privateCheck; };
        /** Returns the public point of the EC key */
        this.getPublicPoint = function () { derivePublic(); return pt; };
        /** Returns the DER-encoded public EC key */
        this.getPublic = function (compressed) {
            derivePublic();
            if (compressed) return pubc;
            else return pub;
        };

        /** Signs a hash using ECDSA algorithm and encodes it in DER */
        this.sign = function (hash) {
            var d = encoding.bytesUnsignedToBigInteger(that.getPrivate());
            var n = curve.getN();
            var e = encoding.bytesUnsignedToBigInteger(hash);
            var k, r;

            do {
                k = genKey(true);
                r = curve.getG().multiply(k).getX().toBigInteger().mod(n);
            } while (r.compareTo(BigInteger.ZERO) <= 0);

            var s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);

            // DER encoding
            var rBa = encoding.bigIntegerToBytesSigned(r);
            var sBa = encoding.bigIntegerToBytesSigned(s);

            var sequence = [];
            sequence.push(0x02);
            sequence.push(rBa.length);
            sequence = sequence.concat(rBa);

            sequence.push(0x02);
            sequence.push(sBa.length);
            sequence = sequence.concat(sBa);

            sequence.unshift(sequence.length);
            sequence.unshift(0x30);

            return sequence;
        };
    }

    /** Returns the hash of the public key */
    this.getPublicHash = function () { derivePublic(); return pubHash; };
    /** Returns the endpoint version */
    this.getVersion = function () { return version; };
    /** Returns the Bitcoin address in Base58Check string format */
    this.getAddress = function () { derivePublic(); return address; };
    /** Returns a new watch-only version of the endpoint */
    this.asWatchOnly = function () { derivePublic(); if (!watchOnly) return new Verso.Bitcoin.Endpoint(address); return that; };
    /** Returns true if the endpoint is watch-only */
    this.isWatchOnly = function () { return watchOnly; };
    /** Compares two endpoints */
    this.sameAs = function (ep) {
        if (ep === null)
            return false;

        if (!(ep instanceof Verso.Bitcoin.Endpoint))
            ep = new Verso.Bitcoin.Endpoint(ep);

        if (watchOnly || ep.isWatchOnly()) {
            return that.getAddress() == ep.getAddress();
        }

        var other = ep.getPrivate();
        for (var i = 0; i < privateKey.length; i++) if (privateKey[i] !== other[i]) return false;
        return true;
    };
};

/**
 * Returns true if the data is a bitcoin address
 *
 * @param  {String|ByteArray} data   The data to test
 * @return {Boolean}                 Returns true if data is a bitcoin address
 */
Verso.Bitcoin.isAddress = function (data) {
    var encoding = Verso.Encoding;

    if (typeof data == "string") {
        data = encoding.base58ToBytes(data);
    }

    if (!Array.isArray(data) || data.length != 25)
        return false;

    try {
        encoding.checkToBytes(data, [0x00, 0x05]);
        return true;
    }
    catch (e) {
        return false;
    }
};

/**
 * Processes the list of loosely-typed endpoints (string addresses, endpoints, etc.) into an array of corresponding Endpoint instances
 *
 * @param  {Endpoint|String|ByteArray} endpoints The list of endpoints
 * @return {Array.Endpoint}                      The processed array of endpoints
 */
Verso.Bitcoin.Endpoint.toList = function (endpoints) {
    if (endpoints === undefined)
        return [];

    if (!Array.isArray(endpoints))
        endpoints = [endpoints];

    for (var i = 0; i < endpoints.length; i++) {
        if (!(endpoints[i] instanceof Verso.Bitcoin.Endpoint))
            endpoints[i] = new Verso.Bitcoin.Endpoint(endpoints[i]);
    }

    return endpoints;
};

/**
 * Bitcoin extended endpoint as defined in BIP 0032
 *
 * @constructor
 * @extends {Endpoint}
 * @param   {ByteArray|String} data      The private key (raw or WIF)
 * @param   {ByteArray}        chainCode The chain code
 */
Verso.Bitcoin.ExtendedEndpoint = function (data, chainCode) {
    Verso.Bitcoin.Endpoint.call(this, data);

    /** Returns the chain code of the extended endpoint */
    this.getChainCode = function () { return chainCode; };
};

Verso.Bitcoin.ExtendedEndpoint.prototype = Verso.Class.inherit(Verso.Bitcoin.Endpoint.prototype);

/**
 * Generates a child extended endpoint
 *
 * @param  {Integer}          index The index of the child
 * @param  {Boolean)          pub   Boolean indicating whether public derivation should be used
 * @return {ExtendedEndpoint}       The child extended endpoint
 */
Verso.Bitcoin.ExtendedEndpoint.prototype.getChild = function (index, pub) {
    var encoding = Verso.Encoding,
        curve = Verso.Bitcoin.Curve,
        cryptography = Verso.Cryptography;

    if (index === undefined)
        index = 0;
    else if (index < 0)
        throw new Verso.Error("Index cannot be negative!");

    var IL, IR, newKey;
    index--;
    do {
        index++;

        if (index > 0x7FFFFFFF)
            throw new Verso.Error("Index is too large!");

        var hmacData = encoding.integerToBytesUnsigned(index, 4);
        if (pub) {
            hmacData[0] &= 0x7F;
            hmacData = this.getPublic(true).concat(hmacData);
        }
        else {
            hmacData[0] |= 0x80;
            hmacData = [0x00].concat(this.getPrivate()).concat(hmacData);
        }

        var I = cryptography.HMACSHA512(hmacData, this.getChainCode());
        IL = encoding.bytesUnsignedToBigInteger(I.slice(0, 32));
        IR = encoding.bytesUnsignedToBigInteger(I.slice(32));
        newKey = IL.add(encoding.bytesUnsignedToBigInteger(this.getPrivate())).mod(curve.getN());
    } while (IL.compareTo(curve.getN()) >= 0 || newKey.compareTo(BigInteger.ZERO) === 0);

    return new Verso.Bitcoin.ChildEndpoint(encoding.bigIntegerToBytesUnsigned(newKey, 32), encoding.bigIntegerToBytesUnsigned(IR, 32), this, index);
};

/**
 * Bitcoin master endpoint
 *
 * @constructor
 * @extends {Endpoint}
 * @param   {ByteArray|String} [seed]      The seed used for determinism
 */
Verso.Bitcoin.MasterEndpoint = function (seed) {
    var encoding = Verso.Encoding,
    curve = Verso.Bitcoin.Curve,
    cryptography = Verso.Cryptography;

    var endpoint;
    var chainCode;

    var derive = function (s) {
        var I = cryptography.HMACSHA512(s, encoding.utf8ToBytes("Bitcoin seed"));

        var key = I.slice(0, 32);
        var chainCode = I.slice(32);

        var bi = encoding.bytesUnsignedToBigInteger(key);
        if (bi.compareTo(curve.getN()) >= 0 || bi.compareTo(BigInteger.ZERO) === 0)
            return { valid: false };
        return { key: key, chainCode: chainCode, valid: true };
    };

    var derived;

    if (seed === undefined) {
        do {
            seed = cryptography.randomBytes(32, 6);
            derived = derive(seed);
        } while (!derived.valid);
    } else {
        derived = derive(seed);

        if (!derived.valid)
            throw new Verso.Error("Invalid seed!");
    }

    Verso.Bitcoin.ExtendedEndpoint.call(this, derived.key, derived.chainCode);

    /** Returns the seed of the master node */
    this.getSeed = function () { return seed.slice(0); };
    /** Returns the path of the extended endpoint */
    this.getPath = function () { return []; };
    /** Returns true if object is the seed */
    this.isMaster = function () { return true; };
};

Verso.Bitcoin.MasterEndpoint.prototype = Verso.Class.inherit(Verso.Bitcoin.ExtendedEndpoint.prototype);

/**
 * Bitcoin extended endpoint as defined in BIP 0032
 *
 * @constructor
 * @extends {Endpoint}
 * @param   {ByteArray|String} data      The private key (raw or WIF)
 * @param   {ByteArray}        chainCode The chain code
 * @param   {ExtendedEndpoint} parent    The parent endpoint
 * @param   {IntArray}         path      The node path
 */
Verso.Bitcoin.ChildEndpoint = function (data, chainCode, parent, index) {
    Verso.Bitcoin.ExtendedEndpoint.call(this, data, chainCode);

    var path = parent.getPath().concat([index]);

    /** Returns the parent node of the extended endpoint */
    this.getParent = function () { return parent; };
    /** Returns the path of the extended endpoint */
    this.getPath = function () { return path; };
    /** Returns true if object is the master node */
    this.isMaster = function () { return false; };
};

Verso.Bitcoin.ChildEndpoint.prototype = Verso.Class.inherit(Verso.Bitcoin.ExtendedEndpoint.prototype);

/**
 * Converts Satoshis to Bitcoins
 *
 * @param  {Integer} index The number of Satoshis
 * @return {Number}        The number of Bitcoins
 */
Verso.Bitcoin.satToBtc = function (s) { return s / 1e8; };

/**
 * Converts Bitcoins to Satoshis
 *
 * @param  {Number} index The number of Bitcoins
 * @return {Integer}      The number of Satoshis
 */
Verso.Bitcoin.btcToSat = function (b) { return Math.round(b * 1e8); };

/**
 * Bitcoin transaction input
 *
 * @constructor
 * @param {Endpoint}  endpoint   The input endpoint
 * @param {Integer}   amount     The input amount in Satoshis
 * @param {ByteArray} [hash]     The hash of the transaction used as input [big-endian]
 * @param {Integer}   [index]    The output index of the input
 * @param {ByteArray} [script]   The script [big-endian]
 * @param {ByteArray} [sequence] The sequence number [big-endian]
 */
Verso.Bitcoin.TxIn = function (endpoint, amount, hash, index, script, sequence) {
    if (!(endpoint instanceof Verso.Bitcoin.Endpoint))
        endpoint = new Verso.Bitcoin.Endpoint(endpoint);

    if (hash === undefined)
        hash = [];
    if (index === undefined)
        index = -1;
    if (script === undefined)
        script = [];
    if (sequence === undefined)
        sequence = [0xFF, 0xFF, 0xFF, 0xFF];

    /** Returns a copy of the transaction hash [big-endian] */
    this.getHash = function () { return hash.slice(0); };
    /** Returns the transaction input index */
    this.getIndex = function () { return index; };
    /** Returns the transaction input script [big-endian] */
    this.getScript = function () { return script.slice(0); };
    /** Returns the transaction sequence number [big-endian] */
    this.getSequence = function () { return sequence.slice(0); };
    /** Returns the transaction endpoint */
    this.getEndpoint = function () { return endpoint; };
    /** Returns the amount of the transaction input in Satoshis */
    this.getAmount = function () { return amount; };
    /** Sets a new script for the transaction input */
    this.setScript = function(newScript) {
        script = newScript;
    };
    /** Clones the transaction input */
    this.clone = function () {
        return new Verso.Bitcoin.TxIn(endpoint, amount, hash.slice(0), index, script.slice(0), sequence.slice(0));
    };
    /** Returns true if transaction input can be used to sign a transaction */
    this.canSign = function () {
        return !endpoint.isWatchOnly() && hash.length > 0 && index >= 0 && script.length > 0 && sequence.length > 0;
    };
};

/**
 * Bitcoin transaction output
 *
 * @constructor
 * @param {Endpoint}          endpoint The output endpoint
 * @param {ByteArray|Numeric} amount   The output amount
 * @param {ByteArray}         [script] The script, [DUP EQUALVERIFY publicHash HASH160 CHECKSIG] by default
 */
Verso.Bitcoin.TxOut = function (endpoint, amount, script) {
    if (!(endpoint instanceof Verso.Bitcoin.Endpoint))
        endpoint = new Verso.Bitcoin.Endpoint(endpoint);

    var outputScript = function () {
        var OP_DUP = 118,
            OP_EQUAL = 135,
            OP_EQUALVERIFY = 136,
            OP_HASH160 = 169,
            OP_CHECKSIG = 172,
            pub;

        if (script === undefined && (endpoint.getVersion() === undefined || endpoint.getVersion() === 0x00)) { // pay-to-pubkey-hash
            pub = endpoint.getPublicHash();

            script = [];
            script.push(OP_DUP);
            script.push(OP_HASH160);
            script.push(pub.length);
            script = script.concat(pub);
            script.push(OP_EQUALVERIFY);
            script.push(OP_CHECKSIG);
        } else if (script === undefined && endpoint.getVersion() === 0x05) { // pay-to-script-hash
            pub = endpoint.getPublicHash();

            script = [];
            script.push(OP_HASH160);
            script.push(pub.length);
            script = script.concat(pub);
            script.push(OP_EQUAL);
        }
    };

    if (script === undefined) { outputScript(); }

    /** Returns the destination endpoint */
    this.getEndpoint = function () { return endpoint; };
    /** Returns the amount */
    this.getAmount = function () { return amount; };
    /** Returns the output script */
    this.getScript = function () { return script.slice(0); };
};

/**
 * Bitcoin transaction
 *
 * @constructor
 * @param {Array.TxIn}  ins       The inputs
 * @param {Array.TxOut} outs      The outputs
 * @param {ByteArray}   [hash]    The transaction hash
 * @param {Integer}     [block]   The block height in which transaction was first added
 * @param {Number}      [Date]    The time at which transaction was broadcasted
 */
Verso.Bitcoin.Tx = function (ins, outs, hash, block, time) {
    var encoding = Verso.Encoding,
        cryptography = Verso.Cryptography,
        bitcoin = Verso.Bitcoin;

    if (!Array.isArray(ins))
        ins = [ins];
    if (!Array.isArray(outs))
        outs = [outs];
    if (hash === undefined)
        hash = [];
    if (block === undefined)
        block = new bitcoin.Block();
    if (time === undefined)
        time = 0;

    var serialized = [];
    ins = ins.slice(0);
    outs = outs.slice(0);

    var fees = ins.reduce(function (prev, curr) { return prev + curr.getAmount(); }, 0) -
               outs.reduce(function (prev, curr) { return prev + curr.getAmount(); }, 0);

    var serializeTx = function (ins, outs) {
        var buffer = [],
            i;

        buffer = buffer.concat([0x01, 0x00, 0x00, 0x00]);

        buffer = buffer.concat(encoding.numToVarInt(ins.length));
        for (i = 0; i < ins.length; i++) {
            buffer = buffer.concat(ins[i].getHash().reverse());
            buffer = buffer.concat(encoding.wordsToBytes([parseInt(ins[i].getIndex())]).reverse());

            buffer = buffer.concat(encoding.numToVarInt(ins[i].getScript().length));
            buffer = buffer.concat(ins[i].getScript());
            buffer = buffer.concat(ins[i].getSequence().reverse());
        }

        buffer = buffer.concat(encoding.numToVarInt(outs.length));
        for (i = 0; i < outs.length; i++) {
            buffer = buffer.concat(encoding.integerToBytesUnsigned(outs[i].getAmount(), 8).reverse());

            buffer = buffer.concat(encoding.numToVarInt(outs[i].getScript().length));
            buffer = buffer.concat(outs[i].getScript());
        }

        buffer = buffer.concat([0x00, 0x00, 0x00, 0x00]);

        return buffer;
    };

    var inputScript = function (index) {
        var hashType = 1;

        var ins_ = [];
        for (var i = 0; i < ins.length; i++) {
            var input = ins[i].clone();

            if (i != index)
                input.setScript([]);

            ins_.push(input);
        }

        var buffer = serializeTx(ins_, outs);
        buffer = buffer.concat(encoding.wordsToBytes([parseInt(hashType)]).reverse());

        var hash = cryptography.SHASHA256(buffer);
        var sign = ins[index].getEndpoint().sign(hash);
        var pub = ins[index].getEndpoint().getPublic();

        var script = [];
        script.push(sign.length+1);
        script = script.concat(sign);
        script.push(0x01);
        script.push(pub.length);
        script = script.concat(pub);

        return script;
    };

    /** Returns the transaction inputs */
    this.getIns = function () { return ins.slice(0); };
    /** Returns the transaction outputs */
    this.getOuts = function () { return outs.slice(0); };
    /** Returns the block height in which transaction is first included */
    this.getBlock = function () { return block; };
    /** Sets the block height in which transaction is first included */
    this.setBlock = function (b) { block = b; };
    /** Returns the time at which transaction is broadcasted */
    this.getTime = function () { return time; };
    /** Sets the time at which transaction is broadcasted */
    this.setTime = function (t) { time = t; };
    /** Returns the transaction hash */
    this.getHash = function () { return hash.slice(0); };
    /** Returns the transaction fees */
    this.getFees = function () { return fees; };
    /** Returns true if endpoints are related to the transaction */
    this.hasEndpoints = function (ep) {
        for (var i = 0; i < ep.length; i++) {
            if (this.getIns().some(function (ti) { return ti.getEndpoint().sameAs(ep[i]); }) ||
               this.getOuts().some(function (to) { return to.getEndpoint().sameAs(ep[i]); }))
                return true;
        }

        return false;
    };
    /** Returns the serialized version of the transaction */
    this.serialize = function () {
        if (serialized.length > 0)
            return serialized;

        if (!ins.every(function (i) { return i.canSign(); }))
            throw new Verso.Error("Tx inputs cannot be signed!");

        var ins_ = [];

        for (var i = 0; i < ins.length; i++) {
            var in_ = ins[i].clone();
            in_.setScript(inputScript(i));
            ins_.push(in_);
        }

        serialized = serializeTx(ins_, outs);
        hash = cryptography.SHASHA256(serialized);
        return serialized;
    };
};

/**
  * Returns true if the transactions are the same (comparing the hash)
  *
  * @param  {Verso.Bitcoin.Tx} tx Other transaction
  * @return {Boolean}             The comparison result
  */
Verso.Bitcoin.Tx.prototype.sameAs = function (tx) {
    if (tx instanceof Verso.Bitcoin.Tx)
        tx = tx.getHash();
    if (Array.isArray(tx))
        tx = Verso.Encoding.bytesToBase16(tx);

    return Verso.Encoding.bytesToBase16(this.getHash()) === tx;
};

/**
 * Returns true if the transaction is confirmed
 *
 * @param  {Block}   latestBlock        The latest block
 * @param  {Integer} [minConfirmations] The number of confirmations required
 * @return {Boolean}                    The confirmation status
 */
Verso.Bitcoin.Tx.prototype.isConfirmed = function (latestBlock, minConfirmations) {
    if (minConfirmations === undefined)
        minConfirmations = 1;

    return (this.getBlock().getHeight() !== undefined && latestBlock.getHeight() - this.getBlock().getHeight() >=  minConfirmations - 1);
};

/**
 * Returns the transaction type
 *
 * @param  {Array.Endpoint} The list of wallet endpoints (used to identify change)
 * @return {Integer}        The transaction amount in Satoshis
 */
Verso.Bitcoin.Tx.prototype.getAmount = function (ep) {
    ep = Verso.Bitcoin.Endpoint.toList(ep);

    var amount = this.getOuts()
                       .filter(function (to) { return ep.some(function (e) { return e.sameAs(to.getEndpoint()); }); })
                       .reduce(function (prev, curr) { return prev + curr.getAmount(); }, 0) -
                 this.getIns()
                       .filter(function (ti) { return ep.some(function (e) { return e.sameAs(ti.getEndpoint()); }); })
                       .reduce(function (prev, curr) { return prev + curr.getAmount(); }, 0);

    var otherOut = this.getOuts().filter(function (to) { return !ep.some(function (e) { return e.sameAs(to.getEndpoint()); }); });

    if (amount < 0 && (otherOut.length > 0 || this.getOuts().length === 0)) {
        return amount + this.getFees();
    }
    else if (amount <= 0 && otherOut.length === 0 && this.getOuts().length > 0) {
        return -this.getOuts().reduce(function (prev, curr) { return prev + curr.getAmount(); }, 0);
    }

    return amount;
};

/**
 * Returns the main endpoint of the transaction (e.g. largest output for outgoing transactions, largest input for incoming transactions)
 *
 * @param  {Array.Endpoint} The list of wallet endpoints (used to identify change)
 * @return {Integer}        The main endpoint
 */
Verso.Bitcoin.Tx.prototype.getMainEndpoint = function (ep) {
    var amount = this.getOuts()
                   .filter(function (to) { return ep.some(function (e) { return e.sameAs(to.getEndpoint()); }); })
                   .reduce(function (prev, curr) { return prev + curr.getAmount(); }, 0) -
                 this.getIns()
                   .filter(function (ti) { return ep.some(function (e) { return e.sameAs(ti.getEndpoint()); }); })
                   .reduce(function (prev, curr) { return prev + curr.getAmount(); }, 0);

    var otherOut = this.getOuts().filter(function (to) { return !ep.some(function (e) { return e.sameAs(to.getEndpoint()); }); });

    if (amount < 0 && otherOut.length > 0) {
        return otherOut.sort(function (a, b) { return b.getAmount() - a.getAmount(); })[0].getEndpoint();
    }
    else if (amount <= 0 && otherOut.length === 0 && this.getOuts().length > 0) {
        return this.getOuts().sort(function (a, b) { return b.getAmount() - a.getAmount(); })[0].getEndpoint();
    }
    else if (amount > 0) {
        return this.getIns()
                        .filter(function (ti) { return !ep.some(function (e) { return e.sameAs(ti.getEndpoint()); }); })
                        .sort(function (a, b) { return b.getAmount() - a.getAmount(); })[0]
                        .getEndpoint();
    }

    return false;
};

/**
 * Bitcoin block
 *
 * @param {Integer} [height] The height of the block
 */
Verso.Bitcoin.Block = function (height) {
    this.getHeight = function () { return height; };
};


/**
 * Bitcoin wallet
 *
 * @constructor
 * @param  {Endpoint} ep                 Endpoint or list of enpoints used by the wallet
 * @param  {Function} [changeMethod]     Function selecting the change address, main address by default
 * @param  {Number}   [minConfirmations] Minimum number of confirmations for balance (2 by default)
 * @param  {Number}   [defaultFee]       Default fee amount in Satoshis (50000 by default)
 * @param  {Object}   [provider]         Object providing Bitcoin services (Verso.Bitcoin.Providers.Blockchain by default)
 */
Verso.Bitcoin.Wallet = function (ep, changeMethod, minConfirmations, defaultFee, provider) {
    var bitcoin = Verso.Bitcoin,
        encoding = Verso.Encoding;

    var that = this;
    var endpoints = [];
    var transactions = [];
    var balance = 0;
    var balancePending = 0;
    var onTx = [];
    var onBalance = [];
    var fetchTime;
    var unspents;

    if (changeMethod === undefined || changeMethod === null)
        changeMethod = function (e) { return that.getEndpoint(); };
    if (minConfirmations === undefined || minConfirmations < 1)
        minConfirmations = 2;
    if (defaultFee === undefined)
        defaultFee = 10000; // TODO: Make this dependent on transaction size
    if (provider === undefined)
        provider = bitcoin.Providers.Blockchain;

    /** Adds enpoints to the wallet */
    this.addEndpoints = function (e) {
        e = bitcoin.Endpoint.toList(e);

        for (var i = 0; i < e.length; i++) {
            var exists = false;

            for (var j = 0; j < endpoints.length; j++) {
                if (endpoints[j].sameAs(e[i])) {
                    if (!e[i].isWatchOnly())
                        endpoints[j] = e[i];
                    exists = true;
                    break;
                }
            }

            if (!exists) {
                endpoints.push(e[i]);
            }
        }
    };

    this.addEndpoints(ep);

    /** Returns the main endpoint */
    this.getEndpoint = function () {
        return endpoints[0];
    };

    /** Returns a copy of the wallet endpoints */
    this.getEndpoints = function () {
        return endpoints.slice(0);
    };

    /** Returns the next endpoint used for change and adds it to the wallet endpoints */
    this.nextChangeEndpoint = function () {
        var change = changeMethod(that);
        that.addEndpoints(change);

        return change;
    };

    /** Sets the change method */
    this.setChangeMethod = function (method) {
        changeMethod = method;
    };

    /** Returns the Bitcoin service provider */
    this.getProvider = function () {
        return provider;
    };

    /** Makes all endpoints watch-only */
    this.makeWatchOnly = function () {
        endpoints = endpoints.map( function(ep) { return ep.asWatchOnly(); });
    };

    /** Returns a spendable copy of the wallet */
    this.makeSpendable = function (eps) {
        eps = bitcoin.Endpoint.toList(eps);

        endpoints = endpoints.map(function (ep) {
            e = eps.filter(function (ee) { return ee.sameAs(ep); });

            if (e.length > 0)
                return e[0];
            return ep;
        });
    };

    /** Adds transactions to the wallet */
    this.addTransactions = function (txs, all) {
        if(!Array.isArray(txs))
            txs = [txs];

        var newTx = [];
        var newConfirm = false;
        var i;

        for (i = 0; i < txs.length; i++) {
            if (!txs[i].hasEndpoints(that.getEndpoints())) {
                continue;
            }

            var exists = transactions.some(function (t) { return t.sameAs(txs[i]); });

            if (!exists) {
                transactions.push(txs[i]);
                newTx.push(txs[i]);
            } else if(txs[i].getBlock().getHeight() !== undefined) {
                var tx = transactions.filter(function (t) { return t.sameAs(txs[i]); })[0];

                if (tx.getBlock().getHeight() === undefined) {
                    tx.setBlock(txs[i].getBlock());
                    newConfirm = true;
                }
            }
        }

        if (newTx.length > 0 || newConfirm) {
            for (i = 0; i < onTx.length; i++) {
                try {
                    onTx[i](that, newTx);
                } catch (e) {}
            }
        }

        if (all)
            fetched = true;
    };

    /** Returns a copy of the wallet transactions */
    this.getTransactions = function () {
        return transactions.slice(0);
    };

    /** Clears transactions kept in the wallet */
    this.clearTransactions = function () {
        transactions = [];
    };

    /** Adds a transaction event handler */
    this.addTransactionEventHandler = function (event) {
        onTx.push(event);
    };

    /** Removes a transaction event handler */
    this.removeTransactionEventHandler = function (event) {
        var i = onTx.indexOf(event);

        if (i > -1)
            onTx.splice(i, 1);
    };

    provider.subscribeBlock(function (block) {
        // Check whether previously unconfirmed txs are now in blockchain
        if (transactions.some(function (tx) { return tx.getBlock().getHeight() === undefined; }))
            that.fetch();
    });

    this.setBalance = function (bal, pending) {
        if (pending === undefined)
            pending = balancePending;

        if (bal != balance || balancePending != pending) {
            balance = bal;
            balancePending = pending;

            for (var i = 0; i < onBalance.length; i++) {
                try {
                    onBalance[i](that, balance, balancePending);
                } catch (e) { }
            }
        }
    };

    /** Returns the confirmed wallet balance */
    this.getBalance = function () {
        return balance;
    };

    /** Returns the unconfirmed wallet balance */
    this.getBalancePending = function () {
        return balancePending;
    };

    /** Adds a balance event handler */
    this.addBalanceEventHandler = function (event) {
        onBalance.push(event);
    };

    /** Removes a balance event handler */
    this.removeBalanceEventHandler = function (event) {
        var i = onBalance.indexOf(event);

        if (i > -1)
            onBalance.splice(i, 1);
    };

    /** Returns the minimum number of confirmations used to compute balance */
    this.getMinConfirmations = function () {
        return minConfirmations;
    };

    /** Returns the default fee */
    this.getDefaultFee = function () {
        return defaultFee;
    };

    /** Sets the default fee */
    this.setDefaultFee = function (fee) {
        defaultFee = fee;
    };

    /** Returns the time of the last fetch */
    this.getFetchTime = function () {
        return fetchTime;
    };

    /** Sets the time of last fetch */
    this.setFetchTime = function (time) {
        if(fetchTime === undefined || time > fetchTime)
            fetchTime = time;
    };

    /** Sets the usable unspents */
    this.setUnspents = function (u) {
        unspents = u;
    };

    /** Returns the fee in satoshis for the next payment */
    this.getCurrentFee = function () {
        return this.getDefaultFee();
    };
};

/**
 * Fetches all wallet information (e.g. transactions, balance, latest block, unspent)
 *
 * @param  {Function} [onResult]  Callback for transactions, balance, pending balance and unspent outputs
 * @param  {Function} [onBalance] Callback for balance, pending balance and unspent outputs
 * @param  {Function} [onError]   Callback in case of error
 */
Verso.Bitcoin.Wallet.prototype.fetch = function (onResult, onError) {
    var that = this;

    this.getProvider().fetchTx(
        that.getEndpoints(),
        function (txs) {
            that.addTransactions(txs, true);

            that.getProvider().fetchUnspent(that.getEndpoints(), function (ins) {
                var bal;
                var pending;

                var usable = ins.filter(function (i) {
                    var conf = i.confirmations >= that.getMinConfirmations();

                    var tx = that.getTransactions().filter(function (t) { return t.sameAs(i.getHash()); });

                    // Allow using unconfirmed inputs if they come from the wallet (e.g. change)
                    return conf || (tx.length == 1 && tx[0].getIns().every(function (ii) { return that.getEndpoints().some(function (ep) { return ep.sameAs(ii.getEndpoint()); }); }));
                });

                bal = usable.reduce(function (i, j) { return i + j.getAmount(); }, 0);
                pending = ins.reduce(function (i, j) { return i + j.getAmount(); }, 0) - bal;

                that.setBalance(bal, pending);
                that.setUnspents(usable);

                that.setFetchTime(new Date());

                try
                {
                    if (onResult)
                        onResult(txs, bal, pending, usable);
                }
                catch (e) {
                }
            },
            onError);
        },
        onError
    );
};

/**
 * Sends Bitcoins from the wallet to a given address
 *
 * @param  {Endpoint|String|ByteArray} to          The destination endpoint (can be the public hash in Base58Check or byte array format)
 * @param  {Number}                    amount      The amount to send (in satoshis)
 * @param  {Number}                    [fee]       The fee for the transaction
 * @param  {Function}                  [onSuccess] Callback in case of success
 * @param  {Function}                  [onError]   Callback in case of error
 */
Verso.Bitcoin.Wallet.prototype.send = function (to, amount, fee, onSuccess, onError) {
    var encoding = Verso.Encoding;
    var bitcoin = Verso.Bitcoin;

    if (to === undefined) {
        throw new Verso.Error("Invalid destination");
    }
    if (amount === undefined || amount <= 0) {
        throw new Verso.Error("Invalid amount");
    }
    if (fee === undefined) {
        fee = this.getDefaultFee();
    } else if (fee > 1e5) {
        fee = 1e5;
    }
    if (!(to instanceof bitcoin.Endpoint)) {
        to = new bitcoin.Endpoint(to);
    }

    var that = this;
    amount = Math.round(amount); // in satoshis
    fee = Math.round(fee);

    this.fetch(
        function (txs, balance, pending, ins) {
            try {
                // Select inputs
                ins = ins.filter(function (i) { return !i.getEndpoint().isWatchOnly(); })
                         .sort(function (a, b) { // Sort by decreasing age
                             var blocka, blockb;

                             var txa = txs.filter(function (t) {
                                 return t.sameAs(a.getHash());
                             })[0];
                             if (txa !== undefined) {
                                blocka = txa.getBlock().getHeight();
                             } else {
                                blocka = 0;
                             }

                             var txb = txs.filter(function (t) {
                                 return t.sameAs(b.getHash());
                             })[0];
                             if (txb !== undefined) {
                                blockb = txb.getBlock().getHeight();
                             } else {
                                blockb = 0;
                             }

                             if (blocka === undefined && blockb === undefined) {
                                 return 0;
                             } else if (blocka === undefined && blockb !== undefined) {
                                 return 1;
                             } else if (blockb === undefined && blocka !== undefined) {
                                 return -1;
                             } else {
                                 return blocka - blockb;
                             }
                         });

                balance = 0;
                var i = 0, selectedIns = [];
                while (i < ins.length && balance < amount + fee) {
                    balance += ins[i].getAmount();
                    selectedIns.push(ins[i]);
                    i++;
                }

                var change = balance - (amount + fee);

                if (change >= 0) {
                    var outs = [new bitcoin.TxOut(to, amount)];

                    if (change > 0)
                        outs.push(new bitcoin.TxOut(that.nextChangeEndpoint(), change));

                    that.getProvider().send(new Verso.Bitcoin.Tx(selectedIns, outs), onSuccess, onError);
                }
                else if (onError) {
                    onError(new Verso.BalanceError("Insufficient balance!"));
                }
            }
            catch (err) {
                if (onError)
                    onError(new Verso.Error("Transaction interrupted!"));
            }
        },
        onError
    );
};

/**
* Redeem an Endpoint
*
* @param  {Endpoint|String|ByteArray} source      The source endpoint
* @param  {Number}                    [fee]       The fee for the transaction
* @param  {Function}                  [onSuccess] Callback in case of success
* @param  {Function}                  [onError]   Callback in case of error
*/
Verso.Bitcoin.Wallet.prototype.redeem = function (source, fee, onSuccess, onError) {
    var that = this;

    this.getProvider().fetchUnspent(source, function (ins) {
        try {
            var balance = ins.reduce(function (i, j) { return i + j.getAmount(); }, 0);

            if (fee === undefined) {
                fee = this.getDefaultFee();
            } else if (fee > 1e5) {
                fee = 1e5;
            }

            if (balance > 0) {
                var outs = [new bitcoin.TxOut(that.getEndpoint(), balance - fee)];

                that.getProvider().send(new Verso.Bitcoin.Tx(ins, outs), onSuccess, onError);
            }
            else if (onError) {
                onError(new Verso.BalanceError("No funds to redeem!"));
            }
        }
        catch (err) {
            if (onError)
                onError(new Verso.Error("Transaction interrupted!"));
        }
    },
    onError
    );
};

/**
 * Wrapper for main services of Blockchain.info (in particular, unspent outputs, address transactions history, transaction broadcast)
 */
Verso.Bitcoin.Providers.Blockchain = (function () {
    var encoding = Verso.Encoding,
        bitcoin = Verso.Bitcoin,
        that = this;

    var latestBlock = new Verso.Bitcoin.Block(); // Keeps track of latest block (updated when adequate service is called)
    var onBlock;

    var setLatestBlock = function (block) {
        if (latestBlock.getHeight() === undefined || block.getHeight() > latestBlock.getHeight()) {
            latestBlock = block;

            if (onBlock) {
                try {
                    onBlock(latestBlock);
                } catch (err) {

                }
            }
        }
    };

    /** Returns the latest block */
    var getLatestBlock = function () {
        return latestBlock;
    };

    /** Subscribes a callback to a new-block event */
    var subscribeBlock = function (callback) { // TODO: allow for multiple callbacks
        onBlock = callback;
    };

    var fetch = function (url, onSuccess, onError, data, method) {
        jQuery.ajax({
            type: (method === undefined) ? "GET" : method,
            url: url,
            data: data,
            success: function (res) {
                if (onSuccess)
                    onSuccess(res);
            },
            error: function (xhr, opt, err) {
                if (onError)
                    onError(new Verso.ConnectionError("Error connecting the server!", xhr));
            }
        });
    };

    var foldEndpoints = function (ep) {
        var addr = "";
        for (var i = 0; i < ep.length; i++) {
            addr += ep[i].getAddress();
            if (i < ep.length - 1)
                addr += "|";
        }

        return addr;
    };

    /**
     * Fetches unspent outputs of a sent of endpoints
     *
     * @memberOf Verso.Providers.Blockchain
     * @param {Endpoint} ep        An endpoint or an array of endpoints
     * @param {Function} onUnspent Function called with unspent outputs in case of success
     * @param {Function} onError   Function called in case of error
     */
    var fetchUnspent = function (ep, onUnspent, onError) {
        ep = bitcoin.Endpoint.toList(ep);

        var addr = foldEndpoints(ep);

        var url = "https://blockchain.info/unspent";
        var data = { cors: true, active: addr };

        var parseUnspent = function (data) {
            var txs = data.unspent_outputs;

            var unspent = [];

            for (var i = 0; i < txs.length; i++) {
                var conf = parseInt(txs[i].confirmations);
                var script = encoding.base16ToBytes(txs[i].script);

                var hash = encoding.base16ToBytes(txs[i].tx_hash).reverse();
                var amount = parseInt(txs[i].value, 10);
                var index = txs[i].tx_output_n;
                var sequence = [0xFF, 0xFF, 0xFF, 0xFF];

                if (script.length == 25 && script[0] == 118 && script[1] == 169 && script[23] == 136 && script[24] == 172) { // accept only standard tx for the timing
                    var e = new bitcoin.Endpoint(script.slice(3, 23));

                    for (var j = 0; j < ep.length; j++) {
                        if (ep[j].sameAs(e)) {
                            e = ep[j];
                            break;
                        }
                    }

                    if (e !== null) {
                        var tin = new bitcoin.TxIn(e, amount, hash, index, script, sequence);
                        tin.confirmations = conf;

                        unspent.push(tin);
                    }
                }
            }

            return unspent;
        };

        fetch(url,
            function (data) {
                try {
                    if (onUnspent)
                        onUnspent(parseUnspent(data));
                }
                catch (e) {
                    if (onError)
                        onError(new Verso.ConnectionError("Cannot parse server data!"));
                }
            },
            function (error) {
                if (error.xhr.responseText === "No free outputs to spend") {
                    if (onUnspent)
                        onUnspent([]);
                } else {
                    if (onError)
                        onError(error);
                }
            }, data);
    };

    /**
     * Fetches transactions related to a set of endpoints
     *
     * @memberOf Verso.Providers.Blockchain
     * @param {Endpoint} ep        An endpoint or an array of endpoints
     * @param {Function} onSuccess Function called with parsed transactions in case of success
     * @param {Function} onError   Function called in case of error
     */
    var fetchTx = function (ep, onSuccess, onError) {
        var parseTx = function (txs) {
            var res = [];

            for (var i = 0; i < txs.length; i++) {
                var hash = encoding.base16ToBytes(txs[i].hash);// seems that it is already big endian      .reverse();
                var time = new Date(parseInt(txs[i].time) * 1000); // unix timestamp
                var idx = txs[i].tx_index;
                var block;
                var k, amount, endpoint;

                if (txs[i].block_height !== undefined) {
                    block = new bitcoin.Block(parseInt(txs[i].block_height));
                }
                else {
                    block = new bitcoin.Block();
                }

                var txin = [];
                for (k = 0; k < txs[i].inputs.length; k++) {
                    amount = parseInt(txs[i].inputs[k].prev_out.value, 10);
                    endpoint = new bitcoin.Endpoint(txs[i].inputs[k].prev_out.addr);

                    txin.push(new bitcoin.TxIn(endpoint, amount));
                }

                var txout = [];
                for (k = 0; k < txs[i].out.length; k++) {
                    amount = parseInt(txs[i].out[k].value, 10);
                    endpoint = new bitcoin.Endpoint(txs[i].out[k].addr);

                    txout.push(new bitcoin.TxOut(endpoint, amount));
                }

                res.push(new bitcoin.Tx(txin, txout, hash, block, time, idx));
            }

            return res;
        };

        var that = this;
        ep = bitcoin.Endpoint.toList(ep);

        var addr = foldEndpoints(ep);

        var url = "https://blockchain.info/multiaddr";
        var data = { cors: true, active: addr };

        fetch(url, function (data) {
            var parsed;

            try {
                setLatestBlock(new bitcoin.Block(data.info.latest_block.height));

                if (onSuccess)
                    onSuccess(parseTx(data.txs));
            }
            catch (e) {
                if (onError)
                    onError(new Verso.ConnectionError("Cannot parse server data!"));
            }
        }, onError, data);
    };

    /**
     * Fetches the latest block found
     *
     * @memberOf Verso.Providers.Blockchain
     * @param {Function} onSuccess Function called with the latest block in case of success
     * @param {Function} onError   Function called in case of error
     */
    var fetchLatestBlock = function (onSuccess, onError) {
        var url = "https://blockchain.info/q/getblockcount";
        var data = { cors: true };

        var onFetchSuccess = function (data) {
            try {
                setLatestBlock(new bitcoin.Block(parseInt(data)));

                if (onSuccess)
                    onSuccess(latestBlock);
            } catch (e) {
                if (onError)
                    onError(new Verso.ConnectionError("Cannot parse server data!"));
            }
        };

        fetch(url, onFetchSuccess, onError, data);
    };

    /**
     * Broadcasts a transaction through Blockchain.info
     *
     * @memberOf Verso.Providers.Blockchain
     * @param {Verso.Bitcoin.Transaction} tx Transaction to broadcast
     * @param {Function} onSuccess Function called with the latest block in case of success
     * @param {Function} onError   Function called in case of error
     */
    var send = function (tx, onSuccess, onError) {
        tx = encoding.bytesToBase16(tx.serialize());

        var url = 'https://blockchain.info/pushtx';
        var data = { cors: true, tx: tx };

        fetch(url, onSuccess, onError, data, "POST");
    };

    return {
        getLatestBlock: getLatestBlock,
        subscribeBlock: subscribeBlock,
        fetchUnspent: fetchUnspent,
        fetchTx: fetchTx,
        fetchLatestBlock: fetchLatestBlock,
        send: send
    };
})();